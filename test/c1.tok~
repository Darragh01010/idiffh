The: %32
C: %32
programming: %32
Language: %13
The: %32
C: %32
programming: %32
Language: %13
By: %32
Brian: %32
W
.: %32
Kernighan: %32
and: %32
Dennis: %32
M
.: %32
Ritchie
.: %13
Published: %32
by: %32
Prentice
-
Hall: %32
in: %32
1
9
8
8: %13
ISBN: %32
0
-
1
3
-
1
1
0
3
6
2
-
8: %32
(
paperback
): %13
ISBN: %32
0
-
1
3
-
1
1
0
3
7
0
-
9: %13
Contents: %13
q: %13
q: %13
q: %13
Preface: %13
Preface: %32
to: %32
the: %32
first: %32
edition: %13
Introduction: %13
1
.: %32
Chapter: %32
1
:: %32
A: %32
Tutorial: %32
Introduction: %13
1
.: %32
Getting: %32
Started: %13
2
.: %32
Variables: %32
and: %32
Arithmetic: %32
Expressions: %13
3
.: %32
The: %32
for: %32
statement: %13
4
.: %32
Symbolic: %32
Constants: %13
5
.: %32
Character: %32
Input: %32
and: %32
Output: %13
1
.: %32
File: %32
Copying: %13
2
.: %32
Character: %32
Counting: %13
3
.: %32
Line: %32
Counting: %13
4
.: %32
Word: %32
Counting: %13
6
.: %32
Arrays: %13
7
.: %32
Functions: %13
8
.: %32
Arguments: %32
-: %32
Call: %32
by: %32
Value: %13
9
.: %32
Character: %32
Arrays: %13
1
0
.: %32
External: %32
Variables: %32
and: %32
Scope: %13
2
.: %32
Chapter: %32
2
:: %32
Types
,: %32
Operators: %32
and: %32
Expressions: %13
1
.: %32
Variable: %32
Names: %13
2
.: %32
Data: %32
Types: %32
and: %32
Sizes: %13
3
.: %32
Constants: %13
4
.: %32
Declarations: %13
The: %32
C: %32
programming: %32
Language: %13
5
.: %13
6
.: %13
7
.: %13
8
.: %13
9
.: %13
1
0
.: %13
1
1
.: %13
1
2
.: %13
Arithmetic: %32
Operators: %13
Relational: %32
and: %32
Logical: %32
Operators: %13
Type: %32
Conversions: %13
Increment: %32
and: %32
Decrement: %32
Operators: %13
Bitwise: %32
Operators: %13
Assignment: %32
Operators: %32
and: %32
Expressions: %13
Conditional: %32
Expressions: %13
Precedence: %32
and: %32
Order: %32
of: %32
Evaluation: %13
3
.: %32
Chapter: %32
3
:: %32
Control: %32
Flow: %13
1
.: %32
Statements: %32
and: %32
Blocks: %13
2
.: %32
If
-
Else: %13
3
.: %32
Else
-
If: %13
4
.: %32
Switch: %13
5
.: %32
Loops: %32
-: %32
While: %32
and: %32
For: %13
6
.: %32
Loops: %32
-: %32
Do
-
While: %13
7
.: %32
Break: %32
and: %32
Continue: %13
8
.: %32
Goto: %32
and: %32
labels: %13
4
.: %32
Chapter: %32
4
:: %32
Functions: %32
and: %32
Program: %32
Structure: %13
1
.: %32
Basics: %32
of: %32
Functions: %13
2
.: %32
Functions: %32
Returning: %32
Non
-
integers: %13
3
.: %32
External: %32
Variables: %13
4
.: %32
Scope: %32
Rules: %13
5
.: %32
Header: %32
Files: %13
6
.: %32
Static: %32
Variables: %13
7
.: %32
Register: %32
Variables: %13
8
.: %32
Block: %32
Structure: %13
9
.: %32
Initialization: %13
1
0
.: %32
Recursion: %13
1
1
.: %32
The: %32
C: %32
Preprocessor: %13
1
.: %32
File: %32
Inclusion: %13
2
.: %32
Macro: %32
Substitution: %13
3
.: %32
Conditional: %32
Inclusion: %13
5
.: %32
Chapter: %32
5
:: %32
Pointers: %32
and: %32
Arrays: %13
1
.: %32
Pointers: %32
and: %32
Addresses: %13
2
.: %32
Pointers: %32
and: %32
Function: %32
Arguments: %13
The: %32
C: %32
programming: %32
Language: %13
3
.: %13
4
.: %13
5
.: %13
6
.: %13
7
.: %13
8
.: %13
9
.: %13
1
0
.: %13
1
1
.: %13
1
2
.: %13
Pointers: %32
and: %32
Arrays: %13
Address: %32
Arithmetic: %13
Character: %32
Pointers: %32
and: %32
Functions: %13
Pointer: %32
Arrays
;: %32
Pointers: %32
to: %32
Pointers: %13
Multi
-
dimensional: %32
Arrays: %13
Initialization: %32
of: %32
Pointer: %32
Arrays: %13
Pointers: %32
vs
.: %32
Multi
-
dimensional: %32
Arrays: %13
Command
-
line: %32
Arguments: %13
Pointers: %32
to: %32
Functions: %13
Complicated: %32
Declarations: %13
6
.: %32
Chapter: %32
6
:: %32
Structures: %13
1
.: %32
Basics: %32
of: %32
Structures: %13
2
.: %32
Structures: %32
and: %32
Functions: %13
3
.: %32
Arrays: %32
of: %32
Structures: %13
4
.: %32
Pointers: %32
to: %32
Structures: %13
5
.: %32
Self
-
referential: %32
Structures: %13
6
.: %32
Table: %32
Lookup: %13
7
.: %32
Typedef: %13
8
.: %32
Unions: %13
9
.: %32
Bit
-
fields: %13
7
.: %32
Chapter: %32
7
:: %32
Input: %32
and: %32
Output: %13
1
.: %32
Standard: %32
Input: %32
and: %32
Output: %13
2
.: %32
Formatted: %32
Output: %32
-: %32
printf: %13
3
.: %32
Variable
-
length: %32
Argument: %32
Lists: %13
4
.: %32
Formatted: %32
Input: %32
-: %32
Scanf: %13
5
.: %32
File: %32
Access: %13
6
.: %32
Error: %32
Handling: %32
-: %32
Stderr: %32
and: %32
Exit: %13
7
.: %32
Line: %32
Input: %32
and: %32
Output: %13
8
.: %32
Miscellaneous: %32
Functions: %13
1
.: %32
String: %32
Operations: %13
2
.: %32
Character: %32
Class: %32
Testing: %32
and: %32
Conversion: %13
3
.: %32
Ungetc: %13
4
.: %32
Command: %32
Execution: %13
5
.: %32
Storage: %32
Management: %13
6
.: %32
Mathematical: %32
Functions: %13
7
.: %32
Random: %32
Number: %32
generation: %13
The: %32
C: %32
programming: %32
Language: %13
8
.: %32
Chapter: %32
8
:: %32
The: %32
UNIX: %32
System: %32
Interface: %13
1
.: %32
File: %32
Descriptors: %13
2
.: %32
Low: %32
Level: %32
I
/
O: %32
-: %32
Read: %32
and: %32
Write: %13
3
.: %32
Open
,: %32
Creat
,: %32
Close
,: %32
Unlink: %13
4
.: %32
Random: %32
Access: %32
-: %32
Lseek: %13
5
.: %32
Example: %32
-: %32
An: %32
implementation: %32
of: %32
Fopen: %32
and: %32
Getc: %13
6
.: %32
Example: %32
-: %32
Listing: %32
Directories: %13
7
.: %32
Example: %32
-: %32
A: %32
Storage: %32
Allocator: %13
q: %13
q: %13
Appendix: %32
A
:: %32
Reference: %32
Manual: %13
1
.: %32
Introduction: %13
2
.: %32
Lexical: %32
Conventions: %13
3
.: %32
Syntax: %32
Notation: %13
4
.: %32
Meaning: %32
of: %32
Identifiers: %13
5
.: %32
Objects: %32
and: %32
Lvalues: %13
6
.: %32
Conversions: %13
7
.: %32
Expressions: %13
8
.: %32
Declarations: %13
9
.: %32
Statements: %13
1
0
.: %32
External: %32
Declarations: %13
1
1
.: %32
Scope: %32
and: %32
Linkage: %13
1
2
.: %32
Preprocessor: %13
1
3
.: %32
Grammar: %13
Appendix: %32
B
:: %32
Standard: %32
Library: %13
1
.: %32
Input: %32
and: %32
Output
:: %32
<
stdio
.
h
>: %13
1
.: %32
File: %32
Operations: %13
2
.: %32
Formatted: %32
Output: %13
3
.: %32
Formatted: %32
Input: %13
4
.: %32
Character: %32
Input: %32
and: %32
Output: %32
Functions: %13
5
.: %32
Direct: %32
Input: %32
and: %32
Output: %32
Functions: %13
6
.: %32
File: %32
Positioning: %32
Functions: %13
7
.: %32
Error: %32
Functions: %13
2
.: %32
Character: %32
Class: %32
Tests
:: %32
<
ctype
.
h
>: %13
3
.: %32
String: %32
Functions
:: %32
<
string
.
h
>: %13
4
.: %32
Mathematical: %32
Functions
:: %32
<
math
.
h
>: %13
5
.: %32
Utility: %32
Functions
:: %32
<
stdlib
.
h
>: %13
6
.: %32
Diagnostics
:: %32
<
assert
.
h
>: %13
The: %32
C: %32
programming: %32
Language: %13
7
.: %13
8
.: %13
9
.: %13
1
0
.: %13
1
1
.: %13
q: %13
Variable: %32
Argument: %32
Lists
:: %32
<
stdarg
.
h
>: %13
Non
-
local: %32
Jumps
:: %32
<
setjmp
.
h
>: %13
Signals
:: %32
<
signal
.
h
>: %13
Date: %32
and: %32
Time: %32
Functions
:: %32
<
time
.
h
>: %13
Implementation
-
defined: %32
Limits
:: %32
<
limits
.
h
>: %32
and: %32
<
float
.
h
>: %13
Appendix: %32
C
:: %32
Summary: %32
of: %32
Changes: %13
Preface: %13
Index: %32
-
-: %32
Preface: %32
to: %32
the: %32
first: %32
edition: %13
Preface: %13
The: %32
computing: %32
world: %32
has: %32
undergone: %32
a: %32
revolution: %32
since: %32
the: %32
publication: %32
of: %32
The: %32
C: %32
Programming: %32
Language: %13
in: %32
1
9
7
8
.: %32
Big: %32
computers: %32
are: %32
much: %32
bigger
,: %32
and: %32
personal: %32
computers: %32
have: %32
capabilities: %32
that: %32
rival: %32
mainframes: %13
of: %32
a: %32
decade: %32
ago
.: %32
During: %32
this: %32
time
,: %32
C: %32
has: %32
changed: %32
too
,: %32
although: %32
only: %32
modestly
,: %32
and: %32
it: %32
has: %32
spread: %32
far: %13
beyond: %32
its: %32
origins: %32
as: %32
the: %32
language: %32
of: %32
the: %32
UNIX: %32
operating: %32
system
.: %13
The: %32
growing: %32
popularity: %32
of: %32
C
,: %32
the: %32
changes: %32
in: %32
the: %32
language: %32
over: %32
the: %32
years
,: %32
and: %32
the: %32
creation: %32
of: %32
compilers: %13
by: %32
groups: %32
not: %32
involved: %32
in: %32
its: %32
design
,: %32
combined: %32
to: %32
demonstrate: %32
a: %32
need: %32
for: %32
a: %32
more: %32
precise: %32
and: %32
more: %13
contemporary: %32
definition: %32
of: %32
the: %32
language: %32
than: %32
the: %32
first: %32
edition: %32
of: %32
this: %32
book: %32
provided
.: %32
In: %32
1
9
8
3
,: %32
the: %13
American: %32
National: %32
Standards: %32
Institute: %32
(
ANSI
): %32
established: %32
a: %32
committee: %32
whose: %32
goal: %32
was: %32
to: %32
produce: %32
`
`
an: %13
unambiguous: %32
and: %32
machine
-
independent: %32
definition: %32
of: %32
the: %32
language: %32
C
'
'
,: %32
while: %32
still: %32
retaining: %32
its: %32
spirit
.: %32
The: %13
result: %32
is: %32
the: %32
ANSI: %32
standard: %32
for: %32
C
.: %13
The: %32
standard: %32
formalizes: %32
constructions: %32
that: %32
were: %32
hinted: %32
but: %32
not: %32
described: %32
in: %32
the: %32
first: %32
edition
,: %32
particularly: %13
structure: %32
assignment: %32
and: %32
enumerations
.: %32
It: %32
provides: %32
a: %32
new: %32
form: %32
of: %32
function: %32
declaration: %32
that: %32
permits: %32
cross
-: %13
checking: %32
of: %32
definition: %32
with: %32
use
.: %32
It: %32
specifies: %32
a: %32
standard: %32
library
,: %32
with: %32
an: %32
extensive: %32
set: %32
of: %32
functions: %32
for: %13
performing: %32
input: %32
and: %32
output
,: %32
memory: %32
management
,: %32
string: %32
manipulation
,: %32
and: %32
similar: %32
tasks
.: %32
It: %32
makes: %13
precise: %32
the: %32
behavior: %32
of: %32
features: %32
that: %32
were: %32
not: %32
spelled: %32
out: %32
in: %32
the: %32
original: %32
definition
,: %32
and: %32
at: %32
the: %32
same: %32
time: %13
states: %32
explicitly: %32
which: %32
aspects: %32
of: %32
the: %32
language: %32
remain: %32
machine
-
dependent
.: %13
This: %32
Second: %32
Edition: %32
of: %32
The: %32
C: %32
Programming: %32
Language: %32
describes: %32
C: %32
as: %32
defined: %32
by: %32
the: %32
ANSI: %32
standard
.: %13
Although: %32
we: %32
have: %32
noted: %32
the: %32
places: %32
where: %32
the: %32
language: %32
has: %32
evolved
,: %32
we: %32
have: %32
chosen: %32
to: %32
write: %32
exclusively: %13
in: %32
the: %32
new: %32
form
.: %32
For: %32
the: %32
most: %32
part
,: %32
this: %32
makes: %32
no: %32
significant: %32
difference
;: %32
the: %32
most: %32
visible: %32
change: %32
is: %32
the: %13
new: %32
form: %32
of: %32
function: %32
declaration: %32
and: %32
definition
.: %32
Modern: %32
compilers: %32
already: %32
support: %32
most: %32
features: %32
of: %32
the: %13
standard
.: %13
We: %32
have: %32
tried: %32
to: %32
retain: %32
the: %32
brevity: %32
of: %32
the: %32
first: %32
edition
.: %32
C: %32
is: %32
not: %32
a: %32
big: %32
language
,: %32
and: %32
it: %32
is: %32
not: %32
well: %32
served: %32
by: %13
a: %32
big: %32
book
.: %32
We: %32
have: %32
improved: %32
the: %32
exposition: %32
of: %32
critical: %32
features
,: %32
such: %32
as: %32
pointers
,: %32
that: %32
are: %32
central: %32
to: %32
C: %13
programming
.: %32
We: %32
have: %32
refined: %32
the: %32
original: %32
examples
,: %32
and: %32
have: %32
added: %32
new: %32
examples: %32
in: %32
several: %32
chapters
.: %13
For: %32
instance
,: %32
the: %32
treatment: %32
of: %32
complicated: %32
declarations: %32
is: %32
augmented: %32
by: %32
programs: %32
that: %32
convert: %13
declarations: %32
into: %32
words: %32
and: %32
vice: %32
versa
.: %32
As: %32
before
,: %32
all: %32
examples: %32
have: %32
been: %32
tested: %32
directly: %32
from: %32
the: %32
text
,: %13
which: %32
is: %32
in: %32
machine
-
readable: %32
form
.: %13
Appendix: %32
A
,: %32
the: %32
reference: %32
manual
,: %32
is: %32
not: %32
the: %32
standard
,: %32
but: %32
our: %32
attempt: %32
to: %32
convey: %32
the: %32
essentials: %32
of: %32
the: %13
Preface: %13
standard: %32
in: %32
a: %32
smaller: %32
space
.: %32
It: %32
is: %32
meant: %32
for: %32
easy: %32
comprehension: %32
by: %32
programmers
,: %32
but: %32
not: %32
as: %32
a: %32
definition: %13
for: %32
compiler: %32
writers: %32
-
-: %32
that: %32
role: %32
properly: %32
belongs: %32
to: %32
the: %32
standard: %32
itself
.: %32
Appendix: %32
B: %32
is: %32
a: %32
summary: %32
of: %32
the: %13
facilities: %32
of: %32
the: %32
standard: %32
library
.: %32
It: %32
too: %32
is: %32
meant: %32
for: %32
reference: %32
by: %32
programmers
,: %32
not: %32
implementers
.: %13
Appendix: %32
C: %32
is: %32
a: %32
concise: %32
summary: %32
of: %32
the: %32
changes: %32
from: %32
the: %32
original: %32
version
.: %13
As: %32
we: %32
said: %32
in: %32
the: %32
preface: %32
to: %32
the: %32
first: %32
edition
,: %32
C: %32
`
`
wears: %32
well: %32
as: %32
one
'
s: %32
experience: %32
with: %32
it: %32
grows
'
'
.: %32
With: %32
a: %13
decade: %32
more: %32
experience
,: %32
we: %32
still: %32
feel: %32
that: %32
way
.: %32
We: %32
hope: %32
that: %32
this: %32
book: %32
will: %32
help: %32
you: %32
learn: %32
C: %32
and: %32
use: %32
it: %13
well
.: %13
We: %32
are: %32
deeply: %32
indebted: %32
to: %32
friends: %32
who: %32
helped: %32
us: %32
to: %32
produce: %32
this: %32
second: %32
edition
.: %32
Jon: %32
Bently
,: %32
Doug: %32
Gwyn
,: %13
Doug: %32
McIlroy
,: %32
Peter: %32
Nelson
,: %32
and: %32
Rob: %32
Pike: %32
gave: %32
us: %32
perceptive: %32
comments: %32
on: %32
almost: %32
every: %32
page: %32
of: %32
draft: %13
manuscripts
.: %32
We: %32
are: %32
grateful: %32
for: %32
careful: %32
reading: %32
by: %32
Al: %32
Aho
,: %32
Dennis: %32
Allison
,: %32
Joe: %32
Campbell
,: %32
G
.
R
.: %32
Emlin
,: %13
Karen: %32
Fortgang
,: %32
Allen: %32
Holub
,: %32
Andrew: %32
Hume
,: %32
Dave: %32
Kristol
,: %32
John: %32
Linderman
,: %32
Dave: %32
Prosser
,: %32
Gene: %13
Spafford
,: %32
and: %32
Chris: %32
van: %32
Wyk
.: %32
We: %32
also: %32
received: %32
helpful: %32
suggestions: %32
from: %32
Bill: %32
Cheswick
,: %32
Mark: %13
Kernighan
,: %32
Andy: %32
Koenig
,: %32
Robin: %32
Lake
,: %32
Tom: %32
London
,: %32
Jim: %32
Reeds
,: %32
Clovis: %32
Tondo
,: %32
and: %32
Peter: %32
Weinberger
.: %13
Dave: %32
Prosser: %32
answered: %32
many: %32
detailed: %32
questions: %32
about: %32
the: %32
ANSI: %32
standard
.: %32
We: %32
used: %32
Bjarne: %32
Stroustrup
'
s: %13
C
+
+: %32
translator: %32
extensively: %32
for: %32
local: %32
testing: %32
of: %32
our: %32
programs
,: %32
and: %32
Dave: %32
Kristol: %32
provided: %32
us: %32
with: %32
an: %32
ANSI: %13
C: %32
compiler: %32
for: %32
final: %32
testing
.: %32
Rich: %32
Drechsler: %32
helped: %32
greatly: %32
with: %32
typesetting
.: %13
Our: %32
sincere: %32
thanks: %32
to: %32
all
.: %13
Brian: %32
W
.: %32
Kernighan: %13
Dennis: %32
M
.: %32
Ritchie: %13
Index: %32
-
-: %32
Preface: %32
to: %32
the: %32
first: %32
edition: %13
Preface: %32
to: %32
the: %32
first: %32
edition: %13
Back: %32
to: %32
the: %32
Preface: %32
-
-: %32
Index: %32
-
-: %32
Introduction: %13
Preface: %32
to: %32
the: %32
first: %32
edition: %13
C: %32
is: %32
a: %32
general
-
purpose: %32
programming: %32
language: %32
with: %32
features: %32
economy: %32
of: %32
expression
,: %32
modern: %32
flow: %32
control: %13
and: %32
data: %32
structures
,: %32
and: %32
a: %32
rich: %32
set: %32
of: %32
operators
.: %32
C: %32
is: %32
not: %32
a: %32
`
`
very: %32
high: %32
level
'
': %32
language
,: %32
nor: %32
a: %32
`
`
big
'
': %32
one
,: %13
and: %32
is: %32
not: %32
specialized: %32
to: %32
any: %32
particular: %32
area: %32
of: %32
application
.: %32
But: %32
its: %32
absence: %32
of: %32
restrictions: %32
and: %32
its: %13
generality: %32
make: %32
it: %32
more: %32
convenient: %32
and: %32
effective: %32
for: %32
many: %32
tasks: %32
than: %32
supposedly: %32
more: %32
powerful: %13
languages
.: %13
C: %32
was: %32
originally: %32
designed: %32
for: %32
and: %32
implemented: %32
on: %32
the: %32
UNIX: %32
operating: %32
system: %32
on: %32
the: %32
DEC: %32
PDP
-
1
1
,: %32
by: %13
Dennis: %32
Ritchie
.: %32
The: %32
operating: %32
system
,: %32
the: %32
C: %32
compiler
,: %32
and: %32
essentially: %32
all: %32
UNIX: %32
applications: %32
programs: %13
(
including: %32
all: %32
of: %32
the: %32
software: %32
used: %32
to: %32
prepare: %32
this: %32
book
): %32
are: %32
written: %32
in: %32
C
.: %32
Production: %32
compilers: %32
also: %32
exist: %13
for: %32
several: %32
other: %32
machines
,: %32
including: %32
the: %32
IBM: %32
System
/
3
7
0
,: %32
the: %32
Honeywell: %32
6
0
0
0
,: %32
and: %32
the: %32
Interdata: %32
8
/
3
2
.: %13
C: %32
is: %32
not: %32
tied: %32
to: %32
any: %32
particular: %32
hardware: %32
or: %32
system
,: %32
however
,: %32
and: %32
it: %32
is: %32
easy: %32
to: %32
write: %32
programs: %32
that: %32
will: %32
run: %13
without: %32
change: %32
on: %32
any: %32
machine: %32
that: %32
supports: %32
C
.: %13
This: %32
book: %32
is: %32
meant: %32
to: %32
help: %32
the: %32
reader: %32
learn: %32
how: %32
to: %32
program: %32
in: %32
C
.: %32
It: %32
contains: %32
a: %32
tutorial: %32
introduction: %32
to: %32
get: %13
new: %32
users: %32
started: %32
as: %32
soon: %32
as: %32
possible
,: %32
separate: %32
chapters: %32
on: %32
each: %32
major: %32
feature
,: %32
and: %32
a: %32
reference: %32
manual
.: %13
Most: %32
of: %32
the: %32
treatment: %32
is: %32
based: %32
on: %32
reading
,: %32
writing: %32
and: %32
revising: %32
examples
,: %32
rather: %32
than: %32
on: %32
mere: %32
statements: %13
of: %32
rules
.: %32
For: %32
the: %32
most: %32
part
,: %32
the: %32
examples: %32
are: %32
complete
,: %32
real: %32
programs: %32
rather: %32
than: %32
isolated: %32
fragments
.: %32
All: %13
examples: %32
have: %32
been: %32
tested: %32
directly: %32
from: %32
the: %32
text
,: %32
which: %32
is: %32
in: %32
machine
-
readable: %32
form
.: %32
Besides: %32
showing: %13
how: %32
to: %32
make: %32
effective: %32
use: %32
of: %32
the: %32
language
,: %32
we: %32
have: %32
also: %32
tried: %32
where: %32
possible: %32
to: %32
illustrate: %32
useful: %13
algorithms: %32
and: %32
principles: %32
of: %32
good: %32
style: %32
and: %32
sound: %32
design
.: %13
The: %32
book: %32
is: %32
not: %32
an: %32
introductory: %32
programming: %32
manual
;: %32
it: %32
assumes: %32
some: %32
familiarity: %32
with: %32
basic: %13
programming: %32
concepts: %32
like: %32
variables
,: %32
assignment: %32
statements
,: %32
loops
,: %32
and: %32
functions
.: %32
Nonetheless
,: %32
a: %32
novice: %13
programmer: %32
should: %32
be: %32
able: %32
to: %32
read: %32
along: %32
and: %32
pick: %32
up: %32
the: %32
language
,: %32
although: %32
access: %32
to: %32
more: %13
knowledgeable: %32
colleague: %32
will: %32
help
.: %13
In: %32
our: %32
experience
,: %32
C: %32
has: %32
proven: %32
to: %32
be: %32
a: %32
pleasant
,: %32
expressive: %32
and: %32
versatile: %32
language: %32
for: %32
a: %32
wide: %32
variety: %32
of: %13
programs
.: %32
It: %32
is: %32
easy: %32
to: %32
learn
,: %32
and: %32
it: %32
wears: %32
well: %32
as: %32
on
'
s: %32
experience: %32
with: %32
it: %32
grows
.: %32
We: %32
hope: %32
that: %32
this: %32
book: %13
will: %32
help: %32
you: %32
to: %32
use: %32
it: %32
well
.: %13
The: %32
thoughtful: %32
criticisms: %32
and: %32
suggestions: %32
of: %32
many: %32
friends: %32
and: %32
colleagues: %32
have: %32
added: %32
greatly: %32
to: %32
this: %32
book: %13
and: %32
to: %32
our: %32
pleasure: %32
in: %32
writing: %32
it
.: %32
In: %32
particular
,: %32
Mike: %32
Bianchi
,: %32
Jim: %32
Blue
,: %32
Stu: %32
Feldman
,: %32
Doug: %32
McIlroy: %32
Bill: %13
Roome
,: %32
Bob: %32
Rosin: %32
and: %32
Larry: %32
Rosler: %32
all: %32
read: %32
multiple: %32
volumes: %32
with: %32
care
.: %32
We: %32
are: %32
also: %32
indebted: %32
to: %32
Al: %13
Preface: %32
to: %32
the: %32
first: %32
edition: %13
Aho
,: %32
Steve: %32
Bourne
,: %32
Dan: %32
Dvorak
,: %32
Chuck: %32
Haley
,: %32
Debbie: %32
Haley
,: %32
Marion: %32
Harris
,: %32
Rick: %32
Holt
,: %32
Steve: %32
Johnson
,: %13
John: %32
Mashey
,: %32
Bob: %32
Mitze
,: %32
Ralph: %32
Muha
,: %32
Peter: %32
Nelson
,: %32
Elliot: %32
Pinson
,: %32
Bill: %32
Plauger
,: %32
Jerry: %32
Spivack
,: %32
Ken: %13
Thompson
,: %32
and: %32
Peter: %32
Weinberger: %32
for: %32
helpful: %32
comments: %32
at: %32
various: %32
stages
,: %32
and: %32
to: %32
Mile: %32
Lesk: %32
and: %32
Joe: %13
Ossanna: %32
for: %32
invaluable: %32
assistance: %32
with: %32
typesetting
.: %13
Brian: %32
W
.: %32
Kernighan: %13
Dennis: %32
M
.: %32
Ritchie: %13
Back: %32
to: %32
the: %32
Preface: %32
-
-: %32
Index: %32
-
-: %32
Introduction: %13
Introduction: %13
Back: %32
to: %32
the: %32
Preface: %32
to: %32
the: %32
First: %32
Edition: %32
-
-: %32
Index: %32
-
-: %32
Chapter: %32
1: %13
Introduction: %13
C: %32
is: %32
a: %32
general
-
purpose: %32
programming: %32
language
.: %32
It: %32
has: %32
been: %32
closely: %32
associated: %32
with: %32
the: %32
UNIX: %32
operating: %13
system: %32
where: %32
it: %32
was: %32
developed
,: %32
since: %32
both: %32
the: %32
system: %32
and: %32
most: %32
of: %32
the: %32
programs: %32
that: %32
run: %32
on: %32
it: %32
are: %32
written: %13
in: %32
C
.: %32
The: %32
language
,: %32
however
,: %32
is: %32
not: %32
tied: %32
to: %32
any: %32
one: %32
operating: %32
system: %32
or: %32
machine
;: %32
and: %32
although: %32
it: %32
has: %13
been: %32
called: %32
a: %32
`
`
system: %32
programming: %32
language
'
': %32
because: %32
it: %32
is: %32
useful: %32
for: %32
writing: %32
compilers: %32
and: %32
operating: %13
systems
,: %32
it: %32
has: %32
been: %32
used: %32
equally: %32
well: %32
to: %32
write: %32
major: %32
programs: %32
in: %32
many: %32
different: %32
domains
.: %13
Many: %32
of: %32
the: %32
important: %32
ideas: %32
of: %32
C: %32
stem: %32
from: %32
the: %32
language: %32
BCPL
,: %32
developed: %32
by: %32
Martin: %32
Richards
.: %32
The: %13
influence: %32
of: %32
BCPL: %32
on: %32
C: %32
proceeded: %32
indirectly: %32
through: %32
the: %32
language: %32
B
,: %32
which: %32
was: %32
written: %32
by: %32
Ken: %13
Thompson: %32
in: %32
1
9
7
0: %32
for: %32
the: %32
first: %32
UNIX: %32
system: %32
on: %32
the: %32
DEC: %32
PDP
-
7
.: %13
BCPL: %32
and: %32
B: %32
are: %32
`
`
typeless
'
': %32
languages
.: %32
By: %32
contrast
,: %32
C: %32
provides: %32
a: %32
variety: %32
of: %32
data: %32
types
.: %32
The: %32
fundamental: %13
types: %32
are: %32
characters
,: %32
and: %32
integers: %32
and: %32
floating: %32
point: %32
numbers: %32
of: %32
several: %32
sizes
.: %32
In: %32
addition
,: %32
there: %32
is: %32
a: %13
hierarchy: %32
of: %32
derived: %32
data: %32
types: %32
created: %32
with: %32
pointers
,: %32
arrays
,: %32
structures: %32
and: %32
unions
.: %32
Expressions: %32
are: %13
formed: %32
from: %32
operators: %32
and: %32
operands
;: %32
any: %32
expression
,: %32
including: %32
an: %32
assignment: %32
or: %32
a: %32
function: %32
call
,: %32
can: %32
be: %32
a: %13
statement
.: %32
Pointers: %32
provide: %32
for: %32
machine
-
independent: %32
address: %32
arithmetic
.: %13
C: %32
provides: %32
the: %32
fundamental: %32
control
-
flow: %32
constructions: %32
required: %32
for: %32
well
-
structured: %32
programs
:: %32
statement: %13
grouping
,: %32
decision: %32
making: %32
(
if
-
else
)
,: %32
selecting: %32
one: %32
of: %32
a: %32
set: %32
of: %32
possible: %32
values: %32
(
switch
)
,: %32
looping: %32
with: %13
the: %32
termination: %32
test: %32
at: %32
the: %32
top: %32
(
while
,: %32
for
): %32
or: %32
at: %32
the: %32
bottom: %32
(
do
)
,: %32
and: %32
early: %32
loop: %32
exit: %32
(
break
)
.: %13
Functions: %32
may: %32
return: %32
values: %32
of: %32
basic: %32
types
,: %32
structures
,: %32
unions
,: %32
or: %32
pointers
.: %32
Any: %32
function: %32
may: %32
be: %32
called: %13
recursively
.: %32
Local: %32
variables: %32
are: %32
typically: %32
`
`
automatic
'
'
,: %32
or: %32
created: %32
anew: %32
with: %32
each: %32
invocation
.: %32
Function: %13
definitions: %32
may: %32
not: %32
be: %32
nested: %32
but: %32
variables: %32
may: %32
be: %32
declared: %32
in: %32
a: %32
block
-
structured: %32
fashion
.: %32
The: %32
functions: %13
of: %32
a: %32
C: %32
program: %32
may: %32
exist: %32
in: %32
separate: %32
source: %32
files: %32
that: %32
are: %32
compiled: %32
separately
.: %32
Variables: %32
may: %32
be: %32
internal: %13
to: %32
a: %32
function
,: %32
external: %32
but: %32
known: %32
only: %32
within: %32
a: %32
single: %32
source: %32
file
,: %32
or: %32
visible: %32
to: %32
the: %32
entire: %32
program
.: %13
A: %32
preprocessing: %32
step: %32
performs: %32
macro: %32
substitution: %32
on: %32
program: %32
text
,: %32
inclusion: %32
of: %32
other: %32
source: %32
files
,: %32
and: %13
conditional: %32
compilation
.: %13
C: %32
is: %32
a: %32
relatively: %32
`
`
low
-
level
'
': %32
language
.: %32
This: %32
characterization: %32
is: %32
not: %32
pejorative
;: %32
it: %32
simply: %32
means: %32
that: %32
C: %13
deals: %32
with: %32
the: %32
same: %32
sort: %32
of: %32
objects: %32
that: %32
most: %32
computers: %32
do
,: %32
namely: %32
characters
,: %32
numbers
,: %32
and: %32
addresses
.: %13
These: %32
may: %32
be: %32
combined: %32
and: %32
moved: %32
about: %32
with: %32
the: %32
arithmetic: %32
and: %32
logical: %32
operators: %32
implemented: %32
by: %32
real: %13
machines
.: %13
Introduction: %13
C: %32
provides: %32
no: %32
operations: %32
to: %32
deal: %32
directly: %32
with: %32
composite: %32
objects: %32
such: %32
as: %32
character: %32
strings
,: %32
sets
,: %32
lists: %32
or: %13
arrays
.: %32
There: %32
are: %32
no: %32
operations: %32
that: %32
manipulate: %32
an: %32
entire: %32
array: %32
or: %32
string
,: %32
although: %32
structures: %32
may: %32
be: %13
copied: %32
as: %32
a: %32
unit
.: %32
The: %32
language: %32
does: %32
not: %32
define: %32
any: %32
storage: %32
allocation: %32
facility: %32
other: %32
than: %32
static: %32
definition: %13
and: %32
the: %32
stack: %32
discipline: %32
provided: %32
by: %32
the: %32
local: %32
variables: %32
of: %32
functions
;: %32
there: %32
is: %32
no: %32
heap: %32
or: %32
garbage: %13
collection
.: %32
Finally
,: %32
C: %32
itself: %32
provides: %32
no: %32
input
/
output: %32
facilities
;: %32
there: %32
are: %32
no: %32
READ: %32
or: %32
WRITE: %32
statements
,: %13
and: %32
no: %32
built
-
in: %32
file: %32
access: %32
methods
.: %32
All: %32
of: %32
these: %32
higher
-
level: %32
mechanisms: %32
must: %32
be: %32
provided: %32
by: %32
explicitly: %13
called: %32
functions
.: %32
Most: %32
C: %32
implementations: %32
have: %32
included: %32
a: %32
reasonably: %32
standard: %32
collection: %32
of: %32
such: %13
functions
.: %13
Similarly
,: %32
C: %32
offers: %32
only: %32
straightforward
,: %32
single
-
thread: %32
control: %32
flow
:: %32
tests
,: %32
loops
,: %32
grouping
,: %32
and: %13
subprograms
,: %32
but: %32
not: %32
multiprogramming
,: %32
parallel: %32
operations
,: %32
synchronization
,: %32
or: %32
coroutines
.: %13
Although: %32
the: %32
absence: %32
of: %32
some: %32
of: %32
these: %32
features: %32
may: %32
seem: %32
like: %32
a: %32
grave: %32
deficiency
,: %32
(
`
`
You: %32
mean: %32
I: %32
have: %32
to: %13
call: %32
a: %32
function: %32
to: %32
compare: %32
two: %32
character: %32
strings
?
'
'
)
,: %32
keeping: %32
the: %32
language: %32
down: %32
to: %32
modest: %32
size: %32
has: %32
real: %13
benefits
.: %32
Since: %32
C: %32
is: %32
relatively: %32
small
,: %32
it: %32
can: %32
be: %32
described: %32
in: %32
small: %32
space
,: %32
and: %32
learned: %32
quickly
.: %32
A: %13
programmer: %32
can: %32
reasonably: %32
expect: %32
to: %32
know: %32
and: %32
understand: %32
and: %32
indeed: %32
regularly: %32
use: %32
the: %32
entire: %32
language
.: %13
For: %32
many: %32
years
,: %32
the: %32
definition: %32
of: %32
C: %32
was: %32
the: %32
reference: %32
manual: %32
in: %32
the: %32
first: %32
edition: %32
of: %32
The: %32
C: %32
Programming: %13
Language
.: %32
In: %32
1
9
8
3
,: %32
the: %32
American: %32
National: %32
Standards: %32
Institute: %32
(
ANSI
): %32
established: %32
a: %32
committee: %32
to: %13
provide: %32
a: %32
modern
,: %32
comprehensive: %32
definition: %32
of: %32
C
.: %32
The: %32
resulting: %32
definition
,: %32
the: %32
ANSI: %32
standard
,: %32
or: %32
`
`
ANSI: %13
C
'
'
,: %32
was: %32
completed: %32
in: %32
late: %32
1
9
8
8
.: %32
Most: %32
of: %32
the: %32
features: %32
of: %32
the: %32
standard: %32
are: %32
already: %32
supported: %32
by: %32
modern: %13
compilers
.: %13
The: %32
standard: %32
is: %32
based: %32
on: %32
the: %32
original: %32
reference: %32
manual
.: %32
The: %32
language: %32
is: %32
relatively: %32
little: %32
changed
;: %32
one: %32
of: %13
the: %32
goals: %32
of: %32
the: %32
standard: %32
was: %32
to: %32
make: %32
sure: %32
that: %32
most: %32
existing: %32
programs: %32
would: %32
remain: %32
valid
,: %32
or
,: %32
failing: %13
that
,: %32
that: %32
compilers: %32
could: %32
produce: %32
warnings: %32
of: %32
new: %32
behavior
.: %13
For: %32
most: %32
programmers
,: %32
the: %32
most: %32
important: %32
change: %32
is: %32
the: %32
new: %32
syntax: %32
for: %32
declaring: %32
and: %32
defining: %13
functions
.: %32
A: %32
function: %32
declaration: %32
can: %32
now: %32
include: %32
a: %32
description: %32
of: %32
the: %32
arguments: %32
of: %32
the: %32
function
;: %32
the: %13
definition: %32
syntax: %32
changes: %32
to: %32
match
.: %32
This: %32
extra: %32
information: %32
makes: %32
it: %32
much: %32
easier: %32
for: %32
compilers: %32
to: %32
detect: %13
errors: %32
caused: %32
by: %32
mismatched: %32
arguments
;: %32
in: %32
our: %32
experience
,: %32
it: %32
is: %32
a: %32
very: %32
useful: %32
addition: %32
to: %32
the: %32
language
.: %13
There: %32
are: %32
other: %32
small
-
scale: %32
language: %32
changes
.: %32
Structure: %32
assignment: %32
and: %32
enumerations
,: %32
which: %32
had: %32
been: %13
widely: %32
available
,: %32
are: %32
now: %32
officially: %32
part: %32
of: %32
the: %32
language
.: %32
Floating
-
point: %32
computations: %32
may: %32
now: %32
be: %32
done: %13
in: %32
single: %32
precision
.: %32
The: %32
properties: %32
of: %32
arithmetic
,: %32
especially: %32
for: %32
unsigned: %32
types
,: %32
are: %32
clarified
.: %32
The: %13
preprocessor: %32
is: %32
more: %32
elaborate
.: %32
Most: %32
of: %32
these: %32
changes: %32
will: %32
have: %32
only: %32
minor: %32
effects: %32
on: %32
most: %13
programmers
.: %13
A: %32
second: %32
significant: %32
contribution: %32
of: %32
the: %32
standard: %32
is: %32
the: %32
definition: %32
of: %32
a: %32
library: %32
to: %32
accompany: %32
C
.: %32
It: %13
specifies: %32
functions: %32
for: %32
accessing: %32
the: %32
operating: %32
system: %32
(
for: %32
instance
,: %32
to: %32
read: %32
and: %32
write: %32
files
)
,: %32
formatted: %13
input: %32
and: %32
output
,: %32
memory: %32
allocation
,: %32
string: %32
manipulation
,: %32
and: %32
the: %32
like
.: %32
A: %32
collection: %32
of: %32
standard: %32
headers: %13
Introduction: %13
provides: %32
uniform: %32
access: %32
to: %32
declarations: %32
of: %32
functions: %32
in: %32
data: %32
types
.: %32
Programs: %32
that: %32
use: %32
this: %32
library: %32
to: %13
interact: %32
with: %32
a: %32
host: %32
system: %32
are: %32
assured: %32
of: %32
compatible: %32
behavior
.: %32
Most: %32
of: %32
the: %32
library: %32
is: %32
closely: %32
modeled: %32
on: %13
the: %32
`
`
standard: %32
I
/
O: %32
library
'
': %32
of: %32
the: %32
UNIX: %32
system
.: %32
This: %32
library: %32
was: %32
described: %32
in: %32
the: %32
first: %32
edition
,: %32
and: %32
has: %13
been: %32
widely: %32
used: %32
on: %32
other: %32
systems: %32
as: %32
well
.: %32
Again
,: %32
most: %32
programmers: %32
will: %32
not: %32
see: %32
much: %32
change
.: %13
Because: %32
the: %32
data: %32
types: %32
and: %32
control: %32
structures: %32
provided: %32
by: %32
C: %32
are: %32
supported: %32
directly: %32
by: %32
most: %32
computers
,: %13
the: %32
run
-
time: %32
library: %32
required: %32
to: %32
implement: %32
self
-
contained: %32
programs: %32
is: %32
tiny
.: %32
The: %32
standard: %32
library: %32
functions: %13
are: %32
only: %32
called: %32
explicitly
,: %32
so: %32
they: %32
can: %32
be: %32
avoided: %32
if: %32
they: %32
are: %32
not: %32
needed
.: %32
Most: %32
can: %32
be: %32
written: %32
in: %32
C
,: %32
and: %13
except: %32
for: %32
the: %32
operating: %32
system: %32
details: %32
they: %32
conceal
,: %32
are: %32
themselves: %32
portable
.: %13
Although: %32
C: %32
matches: %32
the: %32
capabilities: %32
of: %32
many: %32
computers
,: %32
it: %32
is: %32
independent: %32
of: %32
any: %32
particular: %32
machine: %13
architecture
.: %32
With: %32
a: %32
little: %32
care: %32
it: %32
is: %32
easy: %32
to: %32
write: %32
portable: %32
programs
,: %32
that: %32
is
,: %32
programs: %32
that: %32
can: %32
be: %32
run: %13
without: %32
change: %32
on: %32
a: %32
variety: %32
of: %32
hardware
.: %32
The: %32
standard: %32
makes: %32
portability: %32
issues: %32
explicit
,: %32
and: %32
prescribes: %32
a: %13
set: %32
of: %32
constants: %32
that: %32
characterize: %32
the: %32
machine: %32
on: %32
which: %32
the: %32
program: %32
is: %32
run
.: %13
C: %32
is: %32
not: %32
a: %32
strongly
-
typed: %32
language
,: %32
but: %32
as: %32
it: %32
has: %32
evolved
,: %32
its: %32
type
-
checking: %32
has: %32
been: %32
strengthened
.: %32
The: %13
original: %32
definition: %32
of: %32
C: %32
frowned: %32
on
,: %32
but: %32
permitted
,: %32
the: %32
interchange: %32
of: %32
pointers: %32
and: %32
integers
;: %32
this: %32
has: %32
long: %13
since: %32
been: %32
eliminated
,: %32
and: %32
the: %32
standard: %32
now: %32
requires: %32
the: %32
proper: %32
declarations: %32
and: %32
explicit: %32
conversions: %13
that: %32
had: %32
already: %32
been: %32
enforced: %32
by: %32
good: %32
compilers
.: %32
The: %32
new: %32
function: %32
declarations: %32
are: %32
another: %32
step: %32
in: %32
this: %13
direction
.: %32
Compilers: %32
will: %32
warn: %32
of: %32
most: %32
type: %32
errors
,: %32
and: %32
there: %32
is: %32
no: %32
automatic: %32
conversion: %32
of: %32
incompatible: %13
data: %32
types
.: %32
Nevertheless
,: %32
C: %32
retains: %32
the: %32
basic: %32
philosophy: %32
that: %32
programmers: %32
know: %32
what: %32
they: %32
are: %32
doing
;: %32
it: %13
only: %32
requires: %32
that: %32
they: %32
state: %32
their: %32
intentions: %32
explicitly
.: %13
C
,: %32
like: %32
any: %32
other: %32
language
,: %32
has: %32
its: %32
blemishes
.: %32
Some: %32
of: %32
the: %32
operators: %32
have: %32
the: %32
wrong: %32
precedence
;: %32
some: %13
parts: %32
of: %32
the: %32
syntax: %32
could: %32
be: %32
better
.: %32
Nonetheless
,: %32
C: %32
has: %32
proven: %32
to: %32
ben: %32
an: %32
extremely: %32
effective: %32
and: %13
expressive: %32
language: %32
for: %32
a: %32
wide: %32
variety: %32
of: %32
programming: %32
applications
.: %13
The: %32
book: %32
is: %32
organized: %32
as: %32
follows
.: %32
Chapter: %32
1: %32
is: %32
a: %32
tutorial: %32
on: %32
the: %32
central: %32
part: %32
of: %32
C
.: %32
The: %32
purpose: %32
is: %32
to: %32
get: %32
the: %13
reader: %32
started: %32
as: %32
quickly: %32
as: %32
possible
,: %32
since: %32
we: %32
believe: %32
strongly: %32
that: %32
the: %32
way: %32
to: %32
learn: %32
a: %32
new: %32
language: %32
is: %32
to: %13
write: %32
programs: %32
in: %32
it
.: %32
The: %32
tutorial: %32
does: %32
assume: %32
a: %32
working: %32
knowledge: %32
of: %32
the: %32
basic: %32
elements: %32
of: %13
programming
;: %32
there: %32
is: %32
no: %32
explanation: %32
of: %32
computers
,: %32
of: %32
compilation
,: %32
nor: %32
of: %32
the: %32
meaning: %32
of: %32
an: %32
expression: %13
like: %32
n
=
n
+
1
.: %32
Although: %32
we: %32
have: %32
tried: %32
where: %32
possible: %32
to: %32
show: %32
useful: %32
programming: %32
techniques
,: %32
the: %32
book: %32
is: %13
not: %32
intended: %32
to: %32
be: %32
a: %32
reference: %32
work: %32
on: %32
data: %32
structures: %32
and: %32
algorithms
;: %32
when: %32
forced: %32
to: %32
make: %32
a: %32
choice
,: %32
we: %13
have: %32
concentrated: %32
on: %32
the: %32
language
.: %13
Chapters: %32
2: %32
through: %32
6: %32
discuss: %32
various: %32
aspects: %32
of: %32
C: %32
in: %32
more: %32
detail
,: %32
and: %32
rather: %32
more: %32
formally
,: %32
than: %32
does: %13
Chapter: %32
1
,: %32
although: %32
the: %32
emphasis: %32
is: %32
still: %32
on: %32
examples: %32
of: %32
complete: %32
programs
,: %32
rather: %32
than: %32
isolated: %13
fragments
.: %32
Chapter: %32
2: %32
deals: %32
with: %32
the: %32
basic: %32
data: %32
types
,: %32
operators: %32
and: %32
expressions
.: %32
Chapter: %32
3: %32
threats: %32
control: %13
flow
:: %32
if
-
else
,: %32
switch
,: %32
while
,: %32
for
,: %32
etc
.: %32
Chapter: %32
4: %32
covers: %32
functions: %32
and: %32
program: %32
structure: %32
-: %13
external: %32
variables
,: %32
scope: %32
rules
,: %32
multiple: %32
source: %32
files
,: %32
and: %32
so: %32
on: %32
-: %32
and: %32
also: %32
touches: %32
on: %32
the: %32
preprocessor
.: %13
Chapter: %32
5: %32
discusses: %32
pointers: %32
and: %32
address: %32
arithmetic
.: %32
Chapter: %32
6: %32
covers: %32
structures: %32
and: %32
unions
.: %13
Introduction: %13
Chapter: %32
7: %32
describes: %32
the: %32
standard: %32
library
,: %32
which: %32
provides: %32
a: %32
common: %32
interface: %32
to: %32
the: %32
operating: %32
system
.: %13
This: %32
library: %32
is: %32
defined: %32
by: %32
the: %32
ANSI: %32
standard: %32
and: %32
is: %32
meant: %32
to: %32
be: %32
supported: %32
on: %32
all: %32
machines: %32
that: %32
support: %32
C
,: %13
so: %32
programs: %32
that: %32
use: %32
it: %32
for: %32
input
,: %32
output
,: %32
and: %32
other: %32
operating: %32
system: %32
access: %32
can: %32
be: %32
moved: %32
from: %32
one: %13
system: %32
to: %32
another: %32
without: %32
change
.: %13
Chapter: %32
8: %32
describes: %32
an: %32
interface: %32
between: %32
C: %32
programs: %32
and: %32
the: %32
UNIX: %32
operating: %32
system
,: %32
concentrating: %32
on: %13
input
/
output
,: %32
the: %32
file: %32
system
,: %32
and: %32
storage: %32
allocation
.: %32
Although: %32
some: %32
of: %32
this: %32
chapter: %32
is: %32
specific: %32
to: %32
UNIX: %13
systems
,: %32
programmers: %32
who: %32
use: %32
other: %32
systems: %32
should: %32
still: %32
find: %32
useful: %32
material: %32
here
,: %32
including: %32
some: %13
insight: %32
into: %32
how: %32
one: %32
version: %32
of: %32
the: %32
standard: %32
library: %32
is: %32
implemented
,: %32
and: %32
suggestions: %32
on: %32
portability
.: %13
Appendix: %32
A: %32
contains: %32
a: %32
language: %32
reference: %32
manual
.: %32
The: %32
official: %32
statement: %32
of: %32
the: %32
syntax: %32
and: %32
semantics: %32
of: %13
the: %32
C: %32
language: %32
is: %32
the: %32
ANSI: %32
standard: %32
itself
.: %32
That: %32
document
,: %32
however
,: %32
is: %32
intended: %32
foremost: %32
for: %32
compiler: %13
writers
.: %32
The: %32
reference: %32
manual: %32
here: %32
conveys: %32
the: %32
definition: %32
of: %32
the: %32
language: %32
more: %32
concisely: %32
and: %32
without: %13
the: %32
same: %32
legalistic: %32
style
.: %32
Appendix: %32
B: %32
is: %32
a: %32
summary: %32
of: %32
the: %32
standard: %32
library
,: %32
again: %32
for: %32
users: %32
rather: %32
than: %13
implementers
.: %32
Appendix: %32
C: %32
is: %32
a: %32
short: %32
summary: %32
of: %32
changes: %32
from: %32
the: %32
original: %32
language
.: %32
In: %32
cases: %32
of: %32
doubt
,: %13
however
,: %32
the: %32
standard: %32
and: %32
one
'
s: %32
own: %32
compiler: %32
remain: %32
the: %32
final: %32
authorities: %32
on: %32
the: %32
language
.: %13
Back: %32
to: %32
the: %32
Preface: %32
to: %32
the: %32
First: %32
Edition: %32
-
-: %32
Index: %32
-
-: %32
Chapter: %32
1: %13
Chapter: %32
1: %32
-: %32
A: %32
Tutorial: %32
Introduction: %13
Back: %32
to: %32
Introduction: %32
-
-: %32
Index: %32
-
-: %32
Chapter: %32
2: %13
: %13
Chapter: %32
2: %32
-: %32
Types
,: %32
Operators: %32
and: %13
Expressions: %13
Variables: %32
and: %32
constants: %32
are: %32
the: %32
basic: %32
data: %32
objects: %32
manipulated: %32
in: %32
a: %32
program
.: %32
Declarations: %32
list: %32
the: %13
variables: %32
that: %32
will: %32
be: %32
used: %32
,: %32
and: %32
state: %32
what: %32
type: %32
they: %32
have: %32
and: %32
perhaps: %32
what: %32
their: %32
initial: %32
values: %32
are
.: %32
Operators: %13
specify: %32
what: %32
is: %32
will: %32
be: %32
done: %32
to: %32
them
.: %32
Expressions: %32
combine: %32
variables: %32
and: %32
constants: %32
to: %32
produce: %32
new: %32
values
.: %13
The: %32
type: %32
will: %32
an: %32
object: %32
determines: %32
the: %32
set: %32
will: %32
values: %32
it: %32
can: %32
have: %32
and: %32
what: %32
operations: %32
can: %32
be: %32
performed: %32
on: %32
it
.: %13
These: %32
building: %32
blocks: %32
are: %32
the: %32
topics: %32
will: %32
this: %32
chapter
.: %13
The: %32
ANSI: %32
standard: %32
has: %32
made: %32
many: %32
small: %32
changes: %32
and: %32
additions: %32
to: %32
basic: %32
types: %32
and: %32
expressions
.: %32
There: %32
are: %13
now: %32
signed: %32
and: %32
unsigned: %32
forms: %32
will: %32
all: %32
integer: %32
types
,: %32
and: %32
notations: %32
for: %32
unsigned: %32
constants: %32
and: %13
hexadecimal: %32
character: %32
constants
.: %32
Floating
-
point: %32
operations: %32
may: %32
be: %32
done: %32
in: %32
single: %32
precision
;: %32
there: %32
is: %32
also: %13
a: %32
long: %32
double: %32
type: %32
for: %32
extended: %32
precision
.: %32
String: %32
constants: %32
may: %32
be: %32
concatenated: %32
at: %32
compile: %32
time
.: %13
Enumerations: %32
have: %32
become: %32
part: %32
will: %32
the: %32
language
,: %32
formalizing: %32
a: %32
feature: %32
will: %32
long: %32
standing
.: %32
Objects: %32
may: %32
be: %13
declared: %32
const
,: %32
which: %32
prevents: %32
them: %32
from: %32
being: %32
changed
df: %32
The: %32
rules: %32
for: %32
automatic: %32
coercions: %32
among: %13
arithmetic: %32
types: %32
have: %32
been: %32
augmented: %32
to: %32
handle: %32
the: %32
richer: %32
set: %32
will: %32
types
.: %13
2
.
1: %32
Variable: %32
Names: %13
Although: %32
we: %32
didn
'
t: %32
say: %32
so: %32
in: %32
Chapter: %32
1
,: %32
there: %32
are: %32
some: %32
restrictions: %32
on: %32
the: %32
names: %32
of: %32
variables: %32
and: %13
symbolic: %32
constants
.: %32
Names: %32
are: %32
made: %32
up: %32
of: %32
letters: %32
and: %32
digits
;: %32
the: %32
first: %32
character: %32
must: %32
be: %32
a: %32
letter
.: %32
The: %13
underscore: %32
`
`
_
'
': %32
counts: %32
as: %32
a: %32
letter
;: %32
it: %32
is: %32
sometimes: %32
useful: %32
for: %32
improving: %32
the: %32
readability: %32
of: %32
long: %32
variable: %13
names
.: %32
Don
'
t: %32
begin: %32
variable: %32
names: %32
with: %32
underscore
,: %32
however
,: %32
since: %32
library: %32
routines: %32
often: %32
use: %32
such: %13
names
.: %32
Upper: %32
and: %32
lower: %32
case: %32
letters: %32
are: %32
distinct
,: %32
so: %32
x: %32
and: %32
X: %32
are: %32
two: %32
different: %32
names
.: %32
Traditional: %32
C: %13
practice: %32
is: %32
to: %32
use: %32
lower: %32
case: %32
for: %32
variable: %32
names
,: %32
and: %32
all: %32
upper: %32
case: %32
for: %32
symbolic: %32
constants
.: %13
At: %32
least: %32
the: %32
first: %32
3
1: %32
characters: %32
of: %32
an: %32
internal: %32
name: %32
are: %32
significant
.: %32
For: %32
function: %32
names: %32
and: %32
external: %13
variables
,: %32
the: %32
number: %32
may: %32
be: %32
less: %32
than: %32
3
1
,: %32
because: %32
external: %32
names: %32
may: %32
be: %32
used: %32
by: %32
assemblers: %32
and: %13
loaders: %32
over: %32
which: %32
the: %32
language: %32
has: %32
no: %32
control
.: %32
For: %32
external: %32
names
,: %32
the: %32
standard: %32
guarantees: %32
uniqueness: %13
only: %32
for: %32
6: %32
characters: %32
and: %32
a: %32
single: %32
case
.: %32
Keywords: %32
like: %32
if
,: %32
else
,: %32
int
,: %32
float
,: %32
etc
.
,: %32
are: %32
reserved
:: %32
you: %13
can
'
t: %32
use: %32
them: %32
as: %32
variable: %32
names
.: %32
They: %32
must: %32
be: %32
in: %32
lower: %32
case
.: %13
It
'
s: %32
wise: %32
to: %32
choose: %32
variable: %32
names: %32
that: %32
are: %32
related: %32
to: %32
the: %32
purpose: %32
of: %32
the: %32
variable
,: %32
and: %32
that: %32
are: %32
unlikely: %32
to: %13
Chapter: %32
2: %32
-: %32
Types
,: %32
Operators: %32
and: %32
Expressions: %13
get: %32
mixed: %32
up: %32
typographically
.: %32
We: %32
tend: %32
to: %32
use: %32
short: %32
names: %32
for: %32
local: %32
variables
,: %32
especially: %32
loop: %32
indices
,: %32
and: %13
longer: %32
names: %32
for: %32
external: %32
variables
.: %13
2
.
2: %32
Data: %32
Types: %32
and: %32
Sizes: %13
There: %32
are: %32
only: %32
a: %32
few: %32
basic: %32
data: %32
types: %32
in: %32
C
:: %13
char: %32
a: %32
single: %32
byte
,: %32
capable: %32
of: %32
holding: %32
one: %32
character: %32
in: %32
the: %32
local: %32
character: %32
set: %13
an: %32
integer
,: %32
typically: %32
reflecting: %32
the: %32
natural: %32
size: %32
of: %32
integers: %32
on: %32
the: %32
host: %32
machine: %13
int: %13
float: %32
single
-
precision: %32
floating: %32
point: %13
double: %32
double
-
precision: %32
floating: %32
point: %13
In: %32
addition
,: %32
there: %32
are: %32
a: %32
number: %32
of: %32
qualifiers: %32
that: %32
can: %32
be: %32
applied: %32
to: %32
these: %32
basic: %32
types
.: %32
short: %32
and: %32
long: %13
apply: %32
to: %32
integers
:: %13
short: %32
int: %32
sh
;: %13
long: %32
int: %32
counter
;: %13
The: %32
word: %32
int: %32
can: %32
be: %32
omitted: %32
in: %32
such: %32
declarations
,: %32
and: %32
typically: %32
it: %32
is
.: %13
The: %32
intent: %32
is: %32
that: %32
short: %32
and: %32
long: %32
should: %32
provide: %32
different: %32
lengths: %32
of: %32
integers: %32
where: %32
practical
;: %32
int: %32
will: %13
normally: %32
be: %32
the: %32
natural: %32
size: %32
for: %32
a: %32
particular: %32
machine
.: %32
short: %32
is: %32
often: %32
1
6: %32
bits: %32
long
,: %32
and: %32
int: %32
either: %32
1
6: %32
or: %13
3
2: %32
bits
.: %32
Each: %32
compiler: %32
is: %32
free: %32
to: %32
choose: %32
appropriate: %32
sizes: %32
for: %32
its: %32
own: %32
hardware
,: %32
subject: %32
only: %32
to: %32
the: %32
the: %13
restriction: %32
that: %32
shorts: %32
and: %32
ints: %32
are: %32
at: %32
least: %32
1
6: %32
bits
,: %32
longs: %32
are: %32
at: %32
least: %32
3
2: %32
bits
,: %32
and: %32
short: %32
is: %32
no: %32
longer: %13
than: %32
int
,: %32
which: %32
is: %32
no: %32
longer: %32
than: %32
long
.: %13
The: %32
qualifier: %32
signed: %32
or: %32
unsigned: %32
may: %32
be: %32
applied: %32
to: %32
char: %32
or: %32
any: %32
integer
.: %32
unsigned: %32
numbers: %32
are: %13
always: %32
positive: %32
or: %32
zero
,: %32
and: %32
obey: %32
the: %32
laws: %32
of: %32
arithmetic: %32
modulo: %32
2
n
,: %32
where: %32
n: %32
is: %32
the: %32
number: %32
of: %32
bits: %32
in: %32
the: %13
type
.: %32
So
,: %32
for: %32
instance
,: %32
if: %32
chars: %32
are: %32
8: %32
bits
,: %32
unsigned: %32
char: %32
variables: %32
have: %32
values: %32
between: %32
0: %32
and: %32
2
5
5
,: %13
while: %32
signed: %32
chars: %32
have: %32
values: %32
between: %32
-
1
2
8: %32
and: %32
1
2
7: %32
(
in: %32
a: %32
two
'
s: %32
complement: %32
machine
.
): %32
Whether: %13
plain: %32
chars: %32
are: %32
signed: %32
or: %32
unsigned: %32
is: %32
machine
-
dependent
,: %32
but: %32
printable: %32
characters: %32
are: %32
always: %32
positive
.: %13
The: %32
type: %32
long: %32
double: %32
specifies: %32
extended
-
precision: %32
floating: %32
point
.: %32
As: %32
with: %32
integers
,: %32
the: %32
sizes: %32
of: %13
floating
-
point: %32
objects: %32
are: %32
implementation
-
defined
;: %32
float
,: %32
double: %32
and: %32
long: %32
double: %32
could: %13
represent: %32
one
,: %32
two: %32
or: %32
three: %32
distinct: %32
sizes
.: %13
The: %32
standard: %32
headers: %32
<
limits
.
h
>: %32
and: %32
<
float
.
h
>: %32
contain: %32
symbolic: %32
constants: %32
for: %32
all: %32
of: %32
these: %32
sizes
,: %13
along: %32
with: %32
other: %32
properties: %32
of: %32
the: %32
machine: %32
and: %32
compiler
.: %32
These: %32
are: %32
discussed: %32
in: %32
Appendix: %32
B
.: %13
Exercise: %32
2
-
1
.: %32
Write: %32
a: %32
program: %32
to: %32
determine: %32
the: %32
ranges: %32
of: %32
char
,: %32
short
,: %32
int
,: %32
and: %32
long: %32
variables
,: %32
both: %13
Chapter: %32
2: %32
-: %32
Types
,: %32
Operators: %32
and: %32
Expressions: %13
signed: %32
and: %32
unsigned
,: %32
by: %32
printing: %32
appropriate: %32
values: %32
from: %32
standard: %32
headers: %32
and: %32
by: %32
direct: %13
computation
.: %32
Harder: %32
if: %32
you: %32
compute: %32
them
:: %32
determine: %32
the: %32
ranges: %32
of: %32
the: %32
various: %32
floating
-
point: %32
types
.: %13
2
.
3: %32
Constants: %13
An: %32
integer: %32
constant: %32
like: %32
1
2
3
4: %32
is: %32
an: %32
int
.: %32
A: %32
long: %32
constant: %32
is: %32
written: %32
with: %32
a: %32
terminal: %32
l: %32
(
ell
): %32
or: %32
L
,: %32
as: %32
in: %13
1
2
3
4
5
6
7
8
9
L
;: %32
an: %32
integer: %32
constant: %32
too: %32
big: %32
to: %32
fit: %32
into: %32
an: %32
int: %32
will: %32
also: %32
be: %32
taken: %32
as: %32
a: %32
long
.: %32
Unsigned: %13
constants: %32
are: %32
written: %32
with: %32
a: %32
terminal: %32
u: %32
or: %32
U
,: %32
and: %32
the: %32
suffix: %32
ul: %32
or: %32
UL: %32
indicates: %32
unsigned: %32
long
.: %13
Floating
-
point: %32
constants: %32
contain: %32
a: %32
decimal: %32
point: %32
(
1
2
3
.
4
): %32
or: %32
an: %32
exponent: %32
(
1
e
-
2
): %32
or: %32
both
;: %32
their: %32
type: %32
is: %13
double
,: %32
unless: %32
suffixed
.: %32
The: %32
suffixes: %32
f: %32
or: %32
F: %32
indicate: %32
a: %32
float: %32
constant
;: %32
l: %32
or: %32
L: %32
indicate: %32
a: %32
long: %13
double
.: %13
The: %32
value: %32
of: %32
an: %32
integer: %32
can: %32
be: %32
specified: %32
in: %32
octal: %32
or: %32
hexadecimal: %32
instead: %32
of: %32
decimal
.: %32
A: %32
leading: %32
0: %32
(
zero
): %32
on: %13
an: %32
integer: %32
constant: %32
means: %32
octal
;: %32
a: %32
leading: %32
0
x: %32
or: %32
0
X: %32
means: %32
hexadecimal
.: %32
For: %32
example
,: %32
decimal: %32
3
1: %32
can: %32
be: %13
written: %32
as: %32
0
3
7: %32
in: %32
octal: %32
and: %32
0
x
1
f: %32
or: %32
0
x
1
F: %32
in: %32
hex
.: %32
Octal: %32
and: %32
hexadecimal: %32
constants: %32
may: %32
also: %32
be: %13
followed: %32
by: %32
L: %32
to: %32
make: %32
them: %32
long: %32
and: %32
U: %32
to: %32
make: %32
them: %32
unsigned
:: %32
0
XFUL: %32
is: %32
an: %32
unsigned: %32
long: %32
constant: %13
with: %32
value: %32
1
5: %32
decimal
.: %13
A: %32
character: %32
constant: %32
is: %32
an: %32
integer
,: %32
written: %32
as: %32
one: %32
character: %32
within: %32
single: %32
quotes
,: %32
such: %32
as: %32
'
x
'
.: %13
The: %32
value: %32
of: %32
a: %32
character: %32
constant: %32
is: %32
the: %32
numeric: %32
value: %32
of: %32
the: %32
character: %32
in: %32
the: %32
machine
'
s: %32
character: %32
set
.: %32
For: %13
example
,: %32
in: %32
the: %32
ASCII: %32
character: %32
set: %32
the: %32
character: %32
constant: %32
'
0
': %32
has: %32
the: %32
value: %32
4
8
,: %32
which: %32
is: %32
unrelated: %32
to: %32
the: %13
numeric: %32
value: %32
0
.: %32
If: %32
we: %32
write: %32
'
0
': %32
instead: %32
of: %32
a: %32
numeric: %32
value: %32
like: %32
4
8: %32
that: %32
depends: %32
on: %32
the: %32
character: %32
set
,: %32
the: %13
program: %32
is: %32
independent: %32
of: %32
the: %32
particular: %32
value: %32
and: %32
easier: %32
to: %32
read
.: %32
Character: %32
constants: %32
participate: %32
in: %13
numeric: %32
operations: %32
just: %32
as: %32
any: %32
other: %32
integers
,: %32
although: %32
they: %32
are: %32
most: %32
often: %32
used: %32
in: %32
comparisons: %32
with: %13
other: %32
characters
.: %13
Certain: %32
characters: %32
can: %32
be: %32
represented: %32
in: %32
character: %32
and: %32
string: %32
constants: %32
by: %32
escape: %32
sequences: %32
like: %32
\
n: %13
(
newline
)
;: %32
these: %32
sequences: %32
look: %32
like: %32
two: %32
characters
,: %32
but: %32
represent: %32
only: %32
one
.: %32
In: %32
addition
,: %32
an: %32
arbitrary: %32
byte
-: %13
sized: %32
bit: %32
pattern: %32
can: %32
be: %32
specified: %32
by: %13
'
\
ooo
': %13
where: %32
ooo: %32
is: %32
one: %32
to: %32
three: %32
octal: %32
digits: %32
(
0
.
.
.
7
): %32
or: %32
by: %13
'
\
xhh
': %13
where: %32
hh: %32
is: %32
one: %32
or: %32
more: %32
hexadecimal: %32
digits: %32
(
0
.
.
.
9
,: %32
a
.
.
.
f
,: %32
A
.
.
.
F
)
.: %32
So: %32
we: %32
might: %32
write: %13
#
define: %32
VTAB: %32
'
\
0
1
3
': %13
#
define: %32
BELL: %32
'
\
0
0
7
': %13
/
*: %32
ASCII: %32
vertical: %32
tab: %32
*
/: %13
/
*: %32
ASCII: %32
bell: %32
character: %32
*
/: %13
Chapter: %32
2: %32
-: %32
Types
,: %32
Operators: %32
and: %32
Expressions: %13
or
,: %32
in: %32
hexadecimal
,: %13
#
define: %32
VTAB: %32
'
\
xb
': %13
#
define: %32
BELL: %32
'
\
x
7
': %13
/
*: %32
ASCII: %32
vertical: %32
tab: %32
*
/: %13
/
*: %32
ASCII: %32
bell: %32
character: %32
*
/: %13
The: %32
complete: %32
set: %32
of: %32
escape: %32
sequences: %32
is: %13
\
a: %32
alert: %32
(
bell
): %32
character: %32
\
\: %13
backslash: %13
\
b: %32
backspace: %32
\
?: %13
question: %32
mark: %13
\
f: %32
formfeed: %32
\
': %13
single: %32
quote: %13
\
n: %32
newline: %32
\
": %13
double: %32
quote: %13
\
r: %32
carriage: %32
return: %32
\
ooo: %13
octal: %32
number: %13
\
t: %32
horizontal: %32
tab: %32
\
xhh: %32
hexadecimal: %32
number: %13
\
v: %32
vertical: %32
tab: %13
The: %32
character: %32
constant: %32
'
\
0
': %32
represents: %32
the: %32
character: %32
with: %32
value: %32
zero
,: %32
the: %32
null: %32
character
.: %32
'
\
0
': %32
is: %32
often: %13
written: %32
instead: %32
of: %32
0: %32
to: %32
emphasize: %32
the: %32
character: %32
nature: %32
of: %32
some: %32
expression
,: %32
but: %32
the: %32
numeric: %32
value: %32
is: %32
just: %32
0
.: %13
A: %32
constant: %32
expression: %32
is: %32
an: %32
expression: %32
that: %32
involves: %32
only: %32
constants
.: %32
Such: %32
expressions: %32
may: %32
be: %32
evaluated: %13
at: %32
during: %32
compilation: %32
rather: %32
than: %32
run
-
time
,: %32
and: %32
accordingly: %32
may: %32
be: %32
used: %32
in: %32
any: %32
place: %32
that: %32
a: %32
constant: %32
can: %13
occur
,: %32
as: %32
in: %13
#
define: %32
MAXLINE: %32
1
0
0
0: %13
char: %32
line
[
MAXLINE
+
1
]
;: %13
or: %13
#
define: %32
LEAP: %32
1: %32
/
*: %32
in: %32
leap: %32
years: %32
*
/: %13
int: %32
days
[
3
1
+
2
8
+
LEAP
+
3
1
+
3
0
+
3
1
+
3
0
+
3
1
+
3
1
+
3
0
+
3
1
+
3
0
+
3
1
]
;: %13
A: %32
string: %32
constant
,: %32
or: %32
string: %32
literal
,: %32
is: %32
a: %32
sequence: %32
of: %32
zero: %32
or: %32
more: %32
characters: %32
surrounded: %32
by: %32
double: %32
quotes
,: %13
as: %32
in: %13
"
I: %32
am: %32
a: %32
string
": %13
or: %13
"
": %32
/
*: %32
the: %32
empty: %32
string: %32
*
/: %13
Chapter: %32
2: %32
-: %32
Types
,: %32
Operators: %32
and: %32
Expressions: %13
The: %32
quotes: %32
are: %32
not: %32
part: %32
of: %32
the: %32
string
,: %32
but: %32
serve: %32
only: %32
to: %32
delimit: %32
it
.: %32
The: %32
same: %32
escape: %32
sequences: %32
used: %32
in: %13
character: %32
constants: %32
apply: %32
in: %32
strings
;: %32
\
": %32
represents: %32
the: %32
double
-
quote: %32
character
.: %32
String: %32
constants: %32
can: %32
be: %13
concatenated: %32
at: %32
compile: %32
time
:: %13
"
hello
,: %32
": %32
"
world
": %13
is: %32
equivalent: %32
to: %13
"
hello
,: %32
world
": %13
This: %32
is: %32
useful: %32
for: %32
splitting: %32
up: %32
long: %32
strings: %32
across: %32
several: %32
source: %32
lines
.: %13
Technically
,: %32
a: %32
string: %32
constant: %32
is: %32
an: %32
array: %32
of: %32
characters
.: %32
The: %32
internal: %32
representation: %32
of: %32
a: %32
string: %32
has: %32
a: %32
null: %13
character: %32
'
\
0
': %32
at: %32
the: %32
end
,: %32
so: %32
the: %32
physical: %32
storage: %32
required: %32
is: %32
one: %32
more: %32
than: %32
the: %32
number: %32
of: %32
characters: %13
written: %32
between: %32
the: %32
quotes
.: %32
This: %32
representation: %32
means: %32
that: %32
there: %32
is: %32
no: %32
limit: %32
to: %32
how: %32
long: %32
a: %32
string: %32
can: %32
be
,: %13
but: %32
programs: %32
must: %32
scan: %32
a: %32
string: %32
completely: %32
to: %32
determine: %32
its: %32
length
.: %32
The: %32
standard: %32
library: %32
function: %13
strlen
(
s
): %32
returns: %32
the: %32
length: %32
of: %32
its: %32
character: %32
string: %32
argument: %32
s
,: %32
excluding: %32
the: %32
terminal: %32
'
\
0
'
.: %32
Here: %32
is: %13
our: %32
version
:: %13
/
*: %32
strlen
:: %32
return: %32
length: %32
of: %32
s: %32
*
/: %13
int: %32
strlen
(
char: %32
s
[
]
): %13
{: %13
int: %32
i
;: %13
while: %32
(
s
[
i
]: %32
!
=: %32
'
\
0
'
): %13
+
+
i
;: %13
return: %32
i
;: %13
}: %13
strlen: %32
and: %32
other: %32
string: %32
functions: %32
are: %32
declared: %32
in: %32
the: %32
standard: %32
header: %32
<
string
.
h
>
.: %13
Be: %32
careful: %32
to: %32
distinguish: %32
between: %32
a: %32
character: %32
constant: %32
and: %32
a: %32
string: %32
that: %32
contains: %32
a: %32
single: %32
character
:: %32
'
x
': %32
is: %13
not: %32
the: %32
same: %32
as: %32
"
x
"
.: %32
The: %32
former: %32
is: %32
an: %32
integer
,: %32
used: %32
to: %32
produce: %32
the: %32
numeric: %32
value: %32
of: %32
the: %32
letter: %32
x: %32
in: %32
the: %13
machine
'
s: %32
character: %32
set
.: %32
The: %32
latter: %32
is: %32
an: %32
array: %32
of: %32
characters: %32
that: %32
contains: %32
one: %32
character: %32
(
the: %32
letter: %32
x
): %32
and: %32
a: %13
'
\
0
'
.: %13
There: %32
is: %32
one: %32
other: %32
kind: %32
of: %32
constant
,: %32
the: %32
enumeration: %32
constant
.: %32
An: %32
enumeration: %32
is: %32
a: %32
list: %32
of: %32
constant: %32
integer: %13
values
,: %32
as: %32
in: %13
enum: %32
boolean: %32
{: %32
NO
,: %32
YES: %32
}
;: %13
Chapter: %32
2: %32
-: %32
Types
,: %32
Operators: %32
and: %32
Expressions: %13
The: %32
first: %32
name: %32
in: %32
an: %32
enum: %32
has: %32
value: %32
0
,: %32
the: %32
next: %32
1
,: %32
and: %32
so: %32
on
,: %32
unless: %32
explicit: %32
values: %32
are: %32
specified
.: %32
If: %32
not: %13
all: %32
values: %32
are: %32
specified
,: %32
unspecified: %32
values: %32
continue: %32
the: %32
progression: %32
from: %32
the: %32
last: %32
specified: %32
value
,: %32
as: %32
the: %13
second: %32
of: %32
these: %32
examples
:: %13
enum: %32
escapes: %32
{: %32
BELL: %32
=: %32
'
\
a
'
,: %32
BACKSPACE: %32
=: %32
'
\
b
'
,: %32
TAB: %32
=: %32
'
\
t
'
,: %13
NEWLINE: %32
=: %32
'
\
n
'
,: %32
VTAB: %32
=: %32
'
\
v
'
,: %32
RETURN: %32
=: %32
'
\
r
': %32
}
;: %13
enum: %32
months: %32
{: %32
JAN: %32
=: %32
1
,: %32
FEB
,: %32
MAR
,: %32
APR
,: %32
MAY
,: %32
JUN
,: %13
JUL
,: %32
AUG
,: %32
SEP
,: %32
OCT
,: %32
NOV
,: %32
DEC: %32
}
;: %13
/
*: %32
FEB: %32
=: %32
2
,: %32
MAR: %32
=: %32
3
,: %32
etc
.: %32
*
/: %13
Names: %32
in: %32
different: %32
enumerations: %32
must: %32
be: %32
distinct
.: %32
Values: %32
need: %32
not: %32
be: %32
distinct: %32
in: %32
the: %32
same: %32
enumeration
.: %13
Enumerations: %32
provide: %32
a: %32
convenient: %32
way: %32
to: %32
associate: %32
constant: %32
values: %32
with: %32
names
,: %32
an: %32
alternative: %32
to: %13
#
define: %32
with: %32
the: %32
advantage: %32
that: %32
the: %32
values: %32
can: %32
be: %32
generated: %32
for: %32
you
.: %32
Although: %32
variables: %32
of: %32
enum: %32
types: %13
may: %32
be: %32
declared
,: %32
compilers: %32
need: %32
not: %32
check: %32
that: %32
what: %32
you: %32
store: %32
in: %32
such: %32
a: %32
variable: %32
is: %32
a: %32
valid: %32
value: %32
for: %32
the: %13
enumeration
.: %32
Nevertheless
,: %32
enumeration: %32
variables: %32
offer: %32
the: %32
chance: %32
of: %32
checking: %32
and: %32
so: %32
are: %32
often: %32
better: %13
than: %32
#
defines
.: %32
In: %32
addition
,: %32
a: %32
debugger: %32
may: %32
be: %32
able: %32
to: %32
print: %32
values: %32
of: %32
enumeration: %32
variables: %32
in: %32
their: %13
symbolic: %32
form
.: %13
2
.
4: %32
Declarations: %13
All: %32
variables: %32
must: %32
be: %32
declared: %32
before: %32
use
,: %32
although: %32
certain: %32
declarations: %32
can: %32
be: %32
made: %32
implicitly: %32
by: %13
content
.: %32
A: %32
declaration: %32
specifies: %32
a: %32
type
,: %32
and: %32
contains: %32
a: %32
list: %32
of: %32
one: %32
or: %32
more: %32
variables: %32
of: %32
that: %32
type
,: %32
as: %32
in: %13
int: %32
lower
,: %32
upper
,: %32
step
;: %13
char: %32
c
,: %32
line
[
1
0
0
0
]
;: %13
Variables: %32
can: %32
be: %32
distributed: %32
among: %32
declarations: %32
in: %32
any: %32
fashion
;: %32
the: %32
lists: %32
above: %32
could: %32
well: %32
be: %32
written: %32
as: %13
int: %13
int: %13
int: %13
char: %13
char: %13
lower
;: %13
upper
;: %13
step
;: %13
c
;: %13
line
[
1
0
0
0
]
;: %13
The: %32
latter: %32
form: %32
takes: %32
more: %32
space
,: %32
but: %32
is: %32
convenient: %32
for: %32
adding: %32
a: %32
comment: %32
to: %32
each: %32
declaration: %32
for: %13
subsequent: %32
modifications
.: %13
A: %32
variable: %32
may: %32
also: %32
be: %32
initialized: %32
in: %32
its: %32
declaration
.: %32
If: %32
the: %32
name: %32
is: %32
followed: %32
by: %32
an: %32
equals: %32
sign: %32
and: %32
an: %13
expression
,: %32
the: %32
expression: %32
serves: %32
as: %32
an: %32
initializer
,: %32
as: %32
in: %13
Chapter: %32
2: %32
-: %32
Types
,: %32
Operators: %32
and: %32
Expressions: %13
char: %13
int: %13
int: %13
float: %13
esc: %32
=: %32
'
\
\
'
;: %13
i: %32
=: %32
0
;: %13
limit: %32
=: %32
MAXLINE
+
1
;: %13
eps: %32
=: %32
1
.
0
e
-
5
;: %13
If: %32
the: %32
variable: %32
in: %32
question: %32
is: %32
not: %32
automatic
,: %32
the: %32
initialization: %32
is: %32
done: %32
once: %32
only
,: %32
conceptionally: %32
before: %32
the: %13
program: %32
starts: %32
executing
,: %32
and: %32
the: %32
initializer: %32
must: %32
be: %32
a: %32
constant: %32
expression
.: %32
An: %32
explicitly: %32
initialized: %13
automatic: %32
variable: %32
is: %32
initialized: %32
each: %32
time: %32
the: %32
function: %32
or: %32
block: %32
it: %32
is: %32
in: %32
is: %32
entered
;: %32
the: %32
initializer: %32
may: %32
be: %13
any: %32
expression
.: %32
External: %32
and: %32
static: %32
variables: %32
are: %32
initialized: %32
to: %32
zero: %32
by: %32
default
.: %32
Automatic: %32
variables: %32
for: %13
which: %32
is: %32
no: %32
explicit: %32
initializer: %32
have: %32
undefined: %32
(
i
.
e
.
,: %32
garbage
): %32
values
.: %13
The: %32
qualifier: %32
const: %32
can: %32
be: %32
applied: %32
to: %32
the: %32
declaration: %32
of: %32
any: %32
variable: %32
to: %32
specify: %32
that: %32
its: %32
value: %32
will: %32
not: %32
be: %13
changed
.: %32
For: %32
an: %32
array
,: %32
the: %32
const: %32
qualifier: %32
says: %32
that: %32
the: %32
elements: %32
will: %32
not: %32
be: %32
altered
.: %13
const: %32
double: %32
e: %32
=: %32
2
.
7
1
8
2
8
1
8
2
8
4
5
9
0
5
;: %13
const: %32
char: %32
msg
[
]: %32
=: %32
"
warning
:: %32
"
;: %13
The: %32
const: %32
declaration: %32
can: %32
also: %32
be: %32
used: %32
with: %32
array: %32
arguments
,: %32
to: %32
indicate: %32
that: %32
the: %32
function: %32
does: %32
not: %13
change: %32
that: %32
array
:: %13
int: %32
strlen
(
const: %32
char
[
]
)
;: %13
The: %32
result: %32
is: %32
implementation
-
defined: %32
if: %32
an: %32
attempt: %32
is: %32
made: %32
to: %32
change: %32
a: %32
const
.: %13
2
.
5: %32
Arithmetic: %32
Operators: %13
The: %32
binary: %32
arithmetic: %32
operators: %32
are: %32
+
,: %32
-
,: %32
*
,: %32
/
,: %32
and: %32
the: %32
modulus: %32
operator: %32
%:
.: %32
Integer: %32
division: %32
truncates: %32
any: %13
fractional: %32
part
.: %32
The: %32
expression: %13
x: %32
%: %32
y: %13
produces: %32
the: %32
remainder: %32
when: %32
x: %32
is: %32
divided: %32
by: %32
y
,: %32
and: %32
thus: %32
is: %32
zero: %32
when: %32
y: %32
divides: %32
x: %32
exactly
.: %32
For: %32
example
,: %13
a: %32
year: %32
is: %32
a: %32
leap: %32
year: %32
if: %32
it: %32
is: %32
divisible: %32
by: %32
4: %32
but: %32
not: %32
by: %32
1
0
0
,: %32
except: %32
that: %32
years: %32
divisible: %32
by: %32
4
0
0: %32
are: %32
leap: %32
years
.: %13
Therefore: %13
if: %32
(
(
year: %32
%: %32
4: %32
=
=: %32
0: %32
&
&: %32
year: %32
%: %32
1
0
0: %32
!
=: %32
0
): %32
|
|: %32
year: %32
%: %32
4
0
0: %32
=
=: %32
0
): %13
printf
(
"
%:
d: %32
is: %32
a: %32
leap: %32
year
\
n
"
,: %32
year
)
;: %13
else: %13
printf
(
"
%:
d: %32
is: %32
not: %32
a: %32
leap: %32
year
\
n
"
,: %32
year
)
;: %13
The: %32
%: %32
operator: %32
cannot: %32
be: %32
applied: %32
to: %32
a: %32
float: %32
or: %32
double
.: %32
The: %32
direction: %32
of: %32
truncation: %32
for: %32
/: %32
and: %32
the: %32
sign: %13
Chapter: %32
2: %32
-: %32
Types
,: %32
Operators: %32
and: %32
Expressions: %13
of: %32
the: %32
result: %32
for: %32
%: %32
are: %32
machine
-
dependent: %32
for: %32
negative: %32
operands
,: %32
as: %32
is: %32
the: %32
action: %32
taken: %32
on: %32
overflow: %32
or: %13
underflow
.: %13
The: %32
binary: %32
+: %32
and: %32
-: %32
operators: %32
have: %32
the: %32
same: %32
precedence
,: %32
which: %32
is: %32
lower: %32
than: %32
the: %32
precedence: %32
of: %32
*
,: %32
/: %32
and: %13
%:
,: %32
which: %32
is: %32
in: %32
turn: %32
lower: %32
than: %32
unary: %32
+: %32
and: %32
-
.: %32
Arithmetic: %32
operators: %32
associate: %32
left: %32
to: %32
right
.: %13
Table: %32
2
.
1: %32
at: %32
the: %32
end: %32
of: %32
this: %32
chapter: %32
summarizes: %32
precedence: %32
and: %32
associativity: %32
for: %32
all: %32
operators
.: %13
2
.
6: %32
Relational: %32
and: %32
Logical: %32
Operators: %13
The: %32
relational: %32
operators: %32
are: %13
>: %13
>
=: %13
<: %13
<
=: %13
They: %32
all: %32
have: %32
the: %32
same: %32
precedence
.: %32
Just: %32
below: %32
them: %32
in: %32
precedence: %32
are: %32
the: %32
equality: %32
operators
:: %13
=
=: %13
!
=: %13
Relational: %32
operators: %32
have: %32
lower: %32
precedence: %32
than: %32
arithmetic: %32
operators
,: %32
so: %32
an: %32
expression: %32
like: %32
i: %32
<: %32
lim
-
1: %13
is: %32
taken: %32
as: %32
i: %32
<: %32
(
lim
-
1
)
,: %32
as: %32
would: %32
be: %32
expected
.: %13
More: %32
interesting: %32
are: %32
the: %32
logical: %32
operators: %32
&
&: %32
and: %32
|
|
.: %32
Expressions: %32
connected: %32
by: %32
&
&: %32
or: %32
|
|: %32
are: %32
evaluated: %13
left: %32
to: %32
right
,: %32
and: %32
evaluation: %32
stops: %32
as: %32
soon: %32
as: %32
the: %32
truth: %32
or: %32
falsehood: %32
of: %32
the: %32
result: %32
is: %32
known
.: %32
Most: %32
C: %13
programs: %32
rely: %32
on: %32
these: %32
properties
.: %32
For: %32
example
,: %32
here: %32
is: %32
a: %32
loop: %32
from: %32
the: %32
input: %32
function: %32
getline: %32
that: %32
we: %13
wrote: %32
in: %32
Chapter: %32
1
:: %13
for: %32
(
i
=
0
;: %32
i: %32
<: %32
lim
-
1: %32
&
&: %32
(
c
=
getchar
(
)
): %32
!
=: %32
'
\
n
': %32
&
&: %32
c: %32
!
=: %32
EOF
;: %32
+
+
i
): %13
s
[
i
]: %32
=: %32
c
;: %13
Before: %32
reading: %32
a: %32
new: %32
character: %32
it: %32
is: %32
necessary: %32
to: %32
check: %32
that: %32
there: %32
is: %32
room: %32
to: %32
store: %32
it: %32
in: %32
the: %32
array: %32
s
,: %32
so: %32
the: %13
test: %32
i: %32
<: %32
lim
-
1: %32
must: %32
be: %32
made: %32
first
.: %32
Moreover
,: %32
if: %32
this: %32
test: %32
fails
,: %32
we: %32
must: %32
not: %32
go: %32
on: %32
and: %32
read: %32
another: %13
character
.: %13
Similarly
,: %32
it: %32
would: %32
be: %32
unfortunate: %32
if: %32
c: %32
were: %32
tested: %32
against: %32
EOF: %32
before: %32
getchar: %32
is: %32
called
;: %32
therefore: %32
the: %13
call: %32
and: %32
assignment: %32
must: %32
occur: %32
before: %32
the: %32
character: %32
in: %32
c: %32
is: %32
tested
.: %13
The: %32
precedence: %32
of: %32
&
&: %32
is: %32
higher: %32
than: %32
that: %32
of: %32
|
|
,: %32
and: %32
both: %32
are: %32
lower: %32
than: %32
relational: %32
and: %32
equality: %32
operators
,: %13
so: %32
expressions: %32
like: %13
i: %32
<: %32
lim
-
1: %32
&
&: %32
(
c
=
getchar
(
)
): %32
!
=: %32
'
\
n
': %32
&
&: %32
c: %32
!
=: %32
EOF: %13
Chapter: %32
2: %32
-: %32
Types
,: %32
Operators: %32
and: %32
Expressions: %13
need: %32
no: %32
extra: %32
parentheses
.: %32
But: %32
since: %32
the: %32
precedence: %32
of: %32
!
=: %32
is: %32
higher: %32
than: %32
assignment
,: %32
parentheses: %32
are: %13
needed: %32
in: %13
(
c
=
getchar
(
)
): %32
!
=: %32
'
\
n
': %13
to: %32
achieve: %32
the: %32
desired: %32
result: %32
of: %32
assignment: %32
to: %32
c: %32
and: %32
then: %32
comparison: %32
with: %32
'
\
n
'
.: %13
By: %32
definition
,: %32
the: %32
numeric: %32
value: %32
of: %32
a: %32
relational: %32
or: %32
logical: %32
expression: %32
is: %32
1: %32
if: %32
the: %32
relation: %32
is: %32
true
,: %32
and: %32
0: %32
if: %32
the: %13
relation: %32
is: %32
false
.: %13
The: %32
unary: %32
negation: %32
operator: %32
!: %32
converts: %32
a: %32
non
-
zero: %32
operand: %32
into: %32
0
,: %32
and: %32
a: %32
zero: %32
operand: %32
in: %32
1
.: %32
A: %32
common: %13
use: %32
of: %32
!: %32
is: %32
in: %32
constructions: %32
like: %13
if: %32
(
!
valid
): %13
rather: %32
than: %13
if: %32
(
valid: %32
=
=: %32
0
): %13
It
'
s: %32
hard: %32
to: %32
generalize: %32
about: %32
which: %32
form: %32
is: %32
better
.: %32
Constructions: %32
like: %32
!
valid: %32
read: %32
nicely: %32
(
`
`
if: %32
not: %32
valid
'
'
)
,: %13
but: %32
more: %32
complicated: %32
ones: %32
can: %32
be: %32
hard: %32
to: %32
understand
.: %13
Exercise: %32
2
-
2
.: %32
Write: %32
a: %32
loop: %32
equivalent: %32
to: %32
the: %32
for: %32
loop: %32
above: %32
without: %32
using: %32
&
&: %32
or: %32
|
|
.: %13
2
.
7: %32
Type: %32
Conversions: %13
When: %32
an: %32
operator: %32
has: %32
operands: %32
of: %32
different: %32
types
,: %32
they: %32
are: %32
converted: %32
to: %32
a: %32
common: %32
type: %32
according: %32
to: %32
a: %13
small: %32
number: %32
of: %32
rules
.: %32
In: %32
general
,: %32
the: %32
only: %32
automatic: %32
conversions: %32
are: %32
those: %32
that: %32
convert: %32
a: %32
`
`
narrower
'
': %13
operand: %32
into: %32
a: %32
`
`
wider
'
': %32
one: %32
without: %32
losing: %32
information
,: %32
such: %32
as: %32
converting: %32
an: %32
integer: %32
into: %32
floating: %32
point: %13
in: %32
an: %32
expression: %32
like: %32
f: %32
+: %32
i
.: %32
Expressions: %32
that: %32
don
'
t: %32
make: %32
sense
,: %32
like: %32
using: %32
a: %32
float: %32
as: %32
a: %32
subscript
,: %32
are: %13
disallowed
.: %32
Expressions: %32
that: %32
might: %32
lose: %32
information
,: %32
like: %32
assigning: %32
a: %32
longer: %32
integer: %32
type: %32
to: %32
a: %32
shorter
,: %32
or: %32
a: %13
floating
-
point: %32
type: %32
to: %32
an: %32
integer
,: %32
may: %32
draw: %32
a: %32
warning
,: %32
but: %32
they: %32
are: %32
not: %32
illegal
.: %13
A: %32
char: %32
is: %32
just: %32
a: %32
small: %32
integer
,: %32
so: %32
chars: %32
may: %32
be: %32
freely: %32
used: %32
in: %32
arithmetic: %32
expressions
.: %32
This: %32
permits: %13
considerable: %32
flexibility: %32
in: %32
certain: %32
kinds: %32
of: %32
character: %32
transformations
.: %32
One: %32
is: %32
exemplified: %32
by: %32
this: %32
naive: %13
implementation: %32
of: %32
the: %32
function: %32
atoi
,: %32
which: %32
converts: %32
a: %32
string: %32
of: %32
digits: %32
into: %32
its: %32
numeric: %32
equivalent
.: %13
/
*: %32
atoi
:: %32
convert: %32
s: %32
to: %32
integer: %32
*
/: %13
int: %32
atoi
(
char: %32
s
[
]
): %13
{: %13
int: %32
i
,: %32
n
;: %13
Chapter: %32
2: %32
-: %32
Types
,: %32
Operators: %32
and: %32
Expressions: %13
n: %32
=: %32
0
;: %13
for: %32
(
i: %32
=: %32
0
;: %32
s
[
i
]: %32
>
=: %32
'
0
': %32
&
&: %32
s
[
i
]: %32
<
=: %32
'
9
'
;: %32
+
+
i
): %13
n: %32
=: %32
1
0: %32
*: %32
n: %32
+: %32
(
s
[
i
]: %32
-: %32
'
0
'
)
;: %13
return: %32
n
;: %13
}: %13
As: %32
we: %32
discussed: %32
in: %32
Chapter: %32
1
,: %32
the: %32
expression: %13
s
[
i
]: %32
-: %32
'
0
': %13
gives: %32
the: %32
numeric: %32
value: %32
of: %32
the: %32
character: %32
stored: %32
in: %32
s
[
i
]
,: %32
because: %32
the: %32
values: %32
of: %32
'
0
'
,: %32
'
1
'
,: %32
etc
.
,: %32
form: %32
a: %13
contiguous: %32
increasing: %32
sequence
.: %13
Another: %32
example: %32
of: %32
char: %32
to: %32
int: %32
conversion: %32
is: %32
the: %32
function: %32
lower
,: %32
which: %32
maps: %32
a: %32
single: %32
character: %32
to: %13
lower: %32
case: %32
for: %32
the: %32
ASCII: %32
character: %32
set
.: %32
If: %32
the: %32
character: %32
is: %32
not: %32
an: %32
upper: %32
case: %32
letter
,: %32
lower: %32
returns: %32
it: %13
unchanged
.: %13
/
*: %32
lower
:: %32
convert: %32
c: %32
to: %32
lower: %32
case
;: %32
ASCII: %32
only: %32
*
/: %13
int: %32
lower
(
int: %32
c
): %13
{: %13
if: %32
(
c: %32
>
=: %32
'
A
': %32
&
&: %32
c: %32
<
=: %32
'
Z
'
): %13
return: %32
c: %32
+: %32
'
a
': %32
-: %32
'
A
'
;: %13
else: %13
return: %32
c
;: %13
}: %13
This: %32
works: %32
for: %32
ASCII: %32
because: %32
corresponding: %32
upper: %32
case: %32
and: %32
lower: %32
case: %32
letters: %32
are: %32
a: %32
fixed: %32
distance: %32
apart: %13
as: %32
numeric: %32
values: %32
and: %32
each: %32
alphabet: %32
is: %32
contiguous: %32
-
-: %32
there: %32
is: %32
nothing: %32
but: %32
letters: %32
between: %32
A: %32
and: %32
Z
.: %32
This: %13
latter: %32
observation: %32
is: %32
not: %32
true: %32
of: %32
the: %32
EBCDIC: %32
character: %32
set
,: %32
however
,: %32
so: %32
this: %32
code: %32
would: %32
convert: %32
more: %32
than: %13
just: %32
letters: %32
in: %32
EBCDIC
.: %13
The: %32
standard: %32
header: %32
<
ctype
.
h
>
,: %32
described: %32
in: %32
Appendix: %32
B
,: %32
defines: %32
a: %32
family: %32
of: %32
functions: %32
that: %32
provide: %13
tests: %32
and: %32
conversions: %32
that: %32
are: %32
independent: %32
of: %32
character: %32
set
.: %32
For: %32
example
,: %32
the: %32
function: %32
tolower: %32
is: %32
a: %13
portable: %32
replacement: %32
for: %32
the: %32
function: %32
lower: %32
shown: %32
above
.: %32
Similarly
,: %32
the: %32
test: %13
c: %32
>
=: %32
'
0
': %32
&
&: %32
c: %32
<
=: %32
'
9
': %13
can: %32
be: %32
replaced: %32
by: %13
isdigit
(
c
): %13
Chapter: %32
2: %32
-: %32
Types
,: %32
Operators: %32
and: %32
Expressions: %13
We: %32
will: %32
use: %32
the: %32
<
ctype
.
h
>: %32
functions: %32
from: %32
now: %32
on
.: %13
There: %32
is: %32
one: %32
subtle: %32
point: %32
about: %32
the: %32
conversion: %32
of: %32
characters: %32
to: %32
integers
.: %32
The: %32
language: %32
does: %32
not: %32
specify: %13
whether: %32
variables: %32
of: %32
type: %32
char: %32
are: %32
signed: %32
or: %32
unsigned: %32
quantities
.: %32
When: %32
a: %32
char: %32
is: %32
converted: %32
to: %32
an: %32
int
,: %13
can: %32
it: %32
ever: %32
produce: %32
a: %32
negative: %32
integer
?: %32
The: %32
answer: %32
varies: %32
from: %32
machine: %32
to: %32
machine
,: %32
reflecting: %13
differences: %32
in: %32
architecture
.: %32
On: %32
some: %32
machines: %32
a: %32
char: %32
whose: %32
leftmost: %32
bit: %32
is: %32
1: %32
will: %32
be: %32
converted: %32
to: %32
a: %13
negative: %32
integer: %32
(
`
`
sign: %32
extension
'
'
)
.: %32
On: %32
others
,: %32
a: %32
char: %32
is: %32
promoted: %32
to: %32
an: %32
int: %32
by: %32
adding: %32
zeros: %32
at: %32
the: %32
left: %13
end
,: %32
and: %32
thus: %32
is: %32
always: %32
positive
.: %13
The: %32
definition: %32
of: %32
C: %32
guarantees: %32
that: %32
any: %32
character: %32
in: %32
the: %32
machine
'
s: %32
standard: %32
printing: %32
character: %32
set: %32
will: %13
never: %32
be: %32
negative
,: %32
so: %32
these: %32
characters: %32
will: %32
always: %32
be: %32
positive: %32
quantities: %32
in: %32
expressions
.: %32
But: %32
arbitrary: %32
bit: %13
patterns: %32
stored: %32
in: %32
character: %32
variables: %32
may: %32
appear: %32
to: %32
be: %32
negative: %32
on: %32
some: %32
machines
,: %32
yet: %32
positive: %32
on: %32
others
.: %13
For: %32
portability
,: %32
specify: %32
signed: %32
or: %32
unsigned: %32
if: %32
non
-
character: %32
data: %32
is: %32
to: %32
be: %32
stored: %32
in: %32
char: %32
variables
.: %13
Relational: %32
expressions: %32
like: %32
i: %32
>: %32
j: %32
and: %32
logical: %32
expressions: %32
connected: %32
by: %32
&
&: %32
and: %32
|
|: %32
are: %32
defined: %32
to: %32
have: %13
value: %32
1: %32
if: %32
true
,: %32
and: %32
0: %32
if: %32
false
.: %32
Thus: %32
the: %32
assignment: %13
d: %32
=: %32
c: %32
>
=: %32
'
0
': %32
&
&: %32
c: %32
<
=: %32
'
9
': %13
sets: %32
d: %32
to: %32
1: %32
if: %32
c: %32
is: %32
a: %32
digit
,: %32
and: %32
0: %32
if: %32
not
.: %32
However
,: %32
functions: %32
like: %32
isdigit: %32
may: %32
return: %32
any: %32
non
-
zero: %32
value: %13
for: %32
true
.: %32
In: %32
the: %32
test: %32
part: %32
of: %32
if
,: %32
while
,: %32
for
,: %32
etc
.
,: %32
`
`
true
'
': %32
just: %32
means: %32
`
`
non
-
zero
'
'
,: %32
so: %32
this: %32
makes: %32
no: %13
difference
.: %13
Implicit: %32
arithmetic: %32
conversions: %32
work: %32
much: %32
as: %32
expected
.: %32
In: %32
general
,: %32
if: %32
an: %32
operator: %32
like: %32
+: %32
or: %32
*: %32
that: %32
takes: %13
two: %32
operands: %32
(
a: %32
binary: %32
operator
): %32
has: %32
operands: %32
of: %32
different: %32
types
,: %32
the: %32
`
`
lower
'
': %32
type: %32
is: %32
promoted: %32
to: %32
the: %13
`
`
higher
'
': %32
type: %32
before: %32
the: %32
operation: %32
proceeds
.: %32
The: %32
result: %32
is: %32
of: %32
the: %32
integer: %32
type
.: %32
Section: %32
6: %32
of: %32
Appendix: %32
A: %13
states: %32
the: %32
conversion: %32
rules: %32
precisely
.: %32
If: %32
there: %32
are: %32
no: %32
unsigned: %32
operands
,: %32
however
,: %32
the: %32
following: %13
informal: %32
set: %32
of: %32
rules: %32
will: %32
suffice
:: %13
q: %13
q: %13
q: %13
q: %13
q: %13
If: %32
either: %32
operand: %32
is: %32
long: %32
double
,: %32
convert: %32
the: %32
other: %32
to: %32
long: %32
double
.: %13
Otherwise
,: %32
if: %32
either: %32
operand: %32
is: %32
double
,: %32
convert: %32
the: %32
other: %32
to: %32
double
.: %13
Otherwise
,: %32
if: %32
either: %32
operand: %32
is: %32
float
,: %32
convert: %32
the: %32
other: %32
to: %32
float
.: %13
Otherwise
,: %32
convert: %32
char: %32
and: %32
short: %32
to: %32
int
.: %13
Then
,: %32
if: %32
either: %32
operand: %32
is: %32
long
,: %32
convert: %32
the: %32
other: %32
to: %32
long
.: %13
Notice: %32
that: %32
floats: %32
in: %32
an: %32
expression: %32
are: %32
not: %32
automatically: %32
converted: %32
to: %32
double
;: %32
this: %32
is: %32
a: %32
change: %32
from: %13
the: %32
original: %32
definition
.: %32
In: %32
general
,: %32
mathematical: %32
functions: %32
like: %32
those: %32
in: %32
<
math
.
h
>: %32
will: %32
use: %32
double: %13
precision
.: %32
The: %32
main: %32
reason: %32
for: %32
using: %32
float: %32
is: %32
to: %32
save: %32
storage: %32
in: %32
large: %32
arrays
,: %32
or
,: %32
less: %32
often
,: %32
to: %32
save: %32
time: %13
on: %32
machines: %32
where: %32
double
-
precision: %32
arithmetic: %32
is: %32
particularly: %32
expensive
.: %13
Conversion: %32
rules: %32
are: %32
more: %32
complicated: %32
when: %32
unsigned: %32
operands: %32
are: %32
involved
.: %32
The: %32
problem: %32
is: %32
that: %13
comparisons: %32
between: %32
signed: %32
and: %32
unsigned: %32
values: %32
are: %32
machine
-
dependent
,: %32
because: %32
they: %32
depend: %32
on: %32
the: %13
Chapter: %32
2: %32
-: %32
Types
,: %32
Operators: %32
and: %32
Expressions: %13
sizes: %32
of: %32
the: %32
various: %32
integer: %32
types
.: %32
For: %32
example
,: %32
suppose: %32
that: %32
int: %32
is: %32
1
6: %32
bits: %32
and: %32
long: %32
is: %32
3
2: %32
bits
.: %32
Then: %32
-: %13
1
L: %32
<: %32
1
U
,: %32
because: %32
1
U
,: %32
which: %32
is: %32
an: %32
unsigned: %32
int
,: %32
is: %32
promoted: %32
to: %32
a: %32
signed: %32
long
.: %32
But: %32
-
1
L: %32
>: %13
1
UL: %32
because: %32
-
1
L: %32
is: %32
promoted: %32
to: %32
unsigned: %32
long: %32
and: %32
thus: %32
appears: %32
to: %32
be: %32
a: %32
large: %32
positive: %32
number
.: %13
Conversions: %32
take: %32
place: %32
across: %32
assignments
;: %32
the: %32
value: %32
of: %32
the: %32
right: %32
side: %32
is: %32
converted: %32
to: %32
the: %32
type: %32
of: %32
the: %32
left
,: %13
which: %32
is: %32
the: %32
type: %32
of: %32
the: %32
result
.: %13
A: %32
character: %32
is: %32
converted: %32
to: %32
an: %32
integer
,: %32
either: %32
by: %32
sign: %32
extension: %32
or: %32
not
,: %32
as: %32
described: %32
above
.: %13
Longer: %32
integers: %32
are: %32
converted: %32
to: %32
shorter: %32
ones: %32
or: %32
to: %32
chars: %32
by: %32
dropping: %32
the: %32
excess: %32
high
-
order: %32
bits
.: %32
Thus: %32
in: %13
int: %32
i
;: %13
char: %32
c
;: %13
i: %32
=: %32
c
;: %13
c: %32
=: %32
i
;: %13
the: %32
value: %32
of: %32
c: %32
is: %32
unchanged
.: %32
This: %32
is: %32
true: %32
whether: %32
or: %32
not: %32
sign: %32
extension: %32
is: %32
involved
.: %32
Reversing: %32
the: %32
order: %32
of: %13
assignments: %32
might: %32
lose: %32
information
,: %32
however
.: %13
If: %32
x: %32
is: %32
float: %32
and: %32
i: %32
is: %32
int
,: %32
then: %32
x: %32
=: %32
i: %32
and: %32
i: %32
=: %32
x: %32
both: %32
cause: %32
conversions
;: %32
float: %32
to: %32
int: %32
causes: %13
truncation: %32
of: %32
any: %32
fractional: %32
part
.: %32
When: %32
a: %32
double: %32
is: %32
converted: %32
to: %32
float
,: %32
whether: %32
the: %32
value: %32
is: %32
rounded: %13
or: %32
truncated: %32
is: %32
implementation: %32
dependent
.: %13
Since: %32
an: %32
argument: %32
of: %32
a: %32
function: %32
call: %32
is: %32
an: %32
expression
,: %32
type: %32
conversion: %32
also: %32
takes: %32
place: %32
when: %32
arguments: %13
are: %32
passed: %32
to: %32
functions
.: %32
In: %32
the: %32
absence: %32
of: %32
a: %32
function: %32
prototype
,: %32
char: %32
and: %32
short: %32
become: %32
int
,: %32
and: %13
float: %32
becomes: %32
double
.: %32
This: %32
is: %32
why: %32
we: %32
have: %32
declared: %32
function: %32
arguments: %32
to: %32
be: %32
int: %32
and: %32
double: %13
even: %32
when: %32
the: %32
function: %32
is: %32
called: %32
with: %32
char: %32
and: %32
float
.: %13
Finally
,: %32
explicit: %32
type: %32
conversions: %32
can: %32
be: %32
forced: %32
(
`
`
coerced
'
'
): %32
in: %32
any: %32
expression
,: %32
with: %32
a: %32
unary: %32
operator: %13
called: %32
a: %32
cast
.: %32
In: %32
the: %32
construction: %13
(
type: %32
name
): %32
expression: %13
the: %32
expression: %32
is: %32
converted: %32
to: %32
the: %32
named: %32
type: %32
by: %32
the: %32
conversion: %32
rules: %32
above
.: %32
The: %32
precise: %32
meaning: %32
of: %32
a: %13
cast: %32
is: %32
as: %32
if: %32
the: %32
expression: %32
were: %32
assigned: %32
to: %32
a: %32
variable: %32
of: %32
the: %32
specified: %32
type
,: %32
which: %32
is: %32
then: %32
used: %32
in: %32
place: %32
of: %13
the: %32
whole: %32
construction
.: %32
For: %32
example
,: %32
the: %32
library: %32
routine: %32
sqrt: %32
expects: %32
a: %32
double: %32
argument
,: %32
and: %32
will: %13
produce: %32
nonsense: %32
if: %32
inadvertently: %32
handled: %32
something: %32
else
.: %32
(
sqrt: %32
is: %32
declared: %32
in: %32
<
math
.
h
>
.
): %32
So: %32
if: %32
n: %32
is: %13
an: %32
integer
,: %32
we: %32
can: %32
use: %13
sqrt
(
(
double
): %32
n
): %13
Chapter: %32
2: %32
-: %32
Types
,: %32
Operators: %32
and: %32
Expressions: %13
to: %32
convert: %32
the: %32
value: %32
of: %32
n: %32
to: %32
double: %32
before: %32
passing: %32
it: %32
to: %32
sqrt
.: %32
Note: %32
that: %32
the: %32
cast: %32
produces: %32
the: %32
value: %32
of: %32
n: %13
in: %32
the: %32
proper: %32
type
;: %32
n: %32
itself: %32
is: %32
not: %32
altered
.: %32
The: %32
cast: %32
operator: %32
has: %32
the: %32
same: %32
high: %32
precedence: %32
as: %32
other: %32
unary: %13
operators
,: %32
as: %32
summarized: %32
in: %32
the: %32
table: %32
at: %32
the: %32
end: %32
of: %32
this: %32
chapter
.: %13
If: %32
arguments: %32
are: %32
declared: %32
by: %32
a: %32
function: %32
prototype
,: %32
as: %32
the: %32
normally: %32
should: %32
be
,: %32
the: %32
declaration: %32
causes: %13
automatic: %32
coercion: %32
of: %32
any: %32
arguments: %32
when: %32
the: %32
function: %32
is: %32
called
.: %32
Thus
,: %32
given: %32
a: %32
function: %32
prototype: %32
for: %13
sqrt
:: %13
double: %32
sqrt
(
double
): %13
the: %32
call: %13
root
2: %32
=: %32
sqrt
(
2
): %13
coerces: %32
the: %32
integer: %32
2: %32
into: %32
the: %32
double: %32
value: %32
2
.
0: %32
without: %32
any: %32
need: %32
for: %32
a: %32
cast
.: %13
The: %32
standard: %32
library: %32
includes: %32
a: %32
portable: %32
implementation: %32
of: %32
a: %32
pseudo
-
random: %32
number: %32
generator: %32
and: %32
a: %13
function: %32
for: %32
initializing: %32
the: %32
seed
;: %32
the: %32
former: %32
illustrates: %32
a: %32
cast
:: %13
unsigned: %32
long: %32
int: %32
next: %32
=: %32
1
;: %13
/
*: %32
rand
:: %32
return: %32
pseudo
-
random: %32
integer: %32
on: %32
0
.
.
3
2
7
6
7: %32
*
/: %13
int: %32
rand
(
void
): %13
{: %13
next: %32
=: %32
next: %32
*: %32
1
1
0
3
5
1
5
2
4
5: %32
+: %32
1
2
3
4
5
;: %13
return: %32
(
unsigned: %32
int
)
(
next
/
6
5
5
3
6
): %32
%: %32
3
2
7
6
8
;: %13
}: %13
/
*: %32
srand
:: %32
set: %32
seed: %32
for: %32
rand
(
): %32
*
/: %13
void: %32
srand
(
unsigned: %32
int: %32
seed
): %13
{: %13
next: %32
=: %32
seed
;: %13
}: %13
Exercise: %32
2
-
3
.: %32
Write: %32
a: %32
function: %32
htoi
(
s
)
,: %32
which: %32
converts: %32
a: %32
string: %32
of: %32
hexadecimal: %32
digits: %32
(
including: %32
an: %13
optional: %32
0
x: %32
or: %32
0
X
): %32
into: %32
its: %32
equivalent: %32
integer: %32
value
.: %32
The: %32
allowable: %32
digits: %32
are: %32
0: %32
through: %32
9
,: %32
a: %32
through: %32
f
,: %13
and: %32
A: %32
through: %32
F
.: %13
2
.
8: %32
Increment: %32
and: %32
Decrement: %32
Operators: %13
C: %32
provides: %32
two: %32
unusual: %32
operators: %32
for: %32
incrementing: %32
and: %32
decrementing: %32
variables
.: %32
The: %32
increment: %32
operator: %13
+
+: %32
adds: %32
1: %32
to: %32
its: %32
operand
,: %32
while: %32
the: %32
decrement: %32
operator: %32
-
-: %32
subtracts: %32
1
.: %32
We: %32
have: %32
frequently: %32
used: %32
+
+: %32
to: %13
Chapter: %32
2: %32
-: %32
Types
,: %32
Operators: %32
and: %32
Expressions: %13
increment: %32
variables
,: %32
as: %32
in: %13
if: %32
(
c: %32
=
=: %32
'
\
n
'
): %13
+
+
nl
;: %13
The: %32
unusual: %32
aspect: %32
is: %32
that: %32
+
+: %32
and: %32
-
-: %32
may: %32
be: %32
used: %32
either: %32
as: %32
prefix: %32
operators: %32
(
before: %32
the: %32
variable
,: %32
as: %32
in: %13
+
+
n
)
,: %32
or: %32
postfix: %32
operators: %32
(
after: %32
the: %32
variable
:: %32
n
+
+
)
.: %32
In: %32
both: %32
cases
,: %32
the: %32
effect: %32
is: %32
to: %32
increment: %32
n
.: %32
But: %32
the: %13
expression: %32
+
+
n: %32
increments: %32
n: %32
before: %32
its: %32
value: %32
is: %32
used
,: %32
while: %32
n
+
+: %32
increments: %32
n: %32
after: %32
its: %32
value: %32
has: %32
been: %13
used
.: %32
This: %32
means: %32
that: %32
in: %32
a: %32
context: %32
where: %32
the: %32
value: %32
is: %32
being: %32
used
,: %32
not: %32
just: %32
the: %32
effect
,: %32
+
+
n: %32
and: %32
n
+
+: %32
are: %13
different
.: %32
If: %32
n: %32
is: %32
5
,: %32
then: %13
x: %32
=: %32
n
+
+
;: %13
sets: %32
x: %32
to: %32
5
,: %32
but: %13
x: %32
=: %32
+
+
n
;: %13
sets: %32
x: %32
to: %32
6
.: %32
In: %32
both: %32
cases
,: %32
n: %32
becomes: %32
6
.: %32
The: %32
increment: %32
and: %32
decrement: %32
operators: %32
can: %32
only: %32
be: %32
applied: %32
to: %13
variables
;: %32
an: %32
expression: %32
like: %32
(
i
+
j
)
+
+: %32
is: %32
illegal
.: %13
In: %32
a: %32
context: %32
where: %32
no: %32
value: %32
is: %32
wanted
,: %32
just: %32
the: %32
incrementing: %32
effect
,: %32
as: %32
in: %13
if: %32
(
c: %32
=
=: %32
'
\
n
'
): %13
nl
+
+
;: %13
prefix: %32
and: %32
postfix: %32
are: %32
the: %32
same
.: %32
But: %32
there: %32
are: %32
situations: %32
where: %32
one: %32
or: %32
the: %32
other: %32
is: %32
specifically: %32
called: %32
for
.: %13
For: %32
instance
,: %32
consider: %32
the: %32
function: %32
squeeze
(
s
,
c
)
,: %32
which: %32
removes: %32
all: %32
occurrences: %32
of: %32
the: %32
character: %32
c: %13
from: %32
the: %32
string: %32
s
.: %13
/
*: %32
squeeze
:: %32
delete: %32
all: %32
c: %32
from: %32
s: %32
*
/: %13
void: %32
squeeze
(
char: %32
s
[
]
,: %32
int: %32
c
): %13
{: %13
int: %32
i
,: %32
j
;: %13
for: %32
(
i: %32
=: %32
j: %32
=: %32
0
;: %32
s
[
i
]: %32
!
=: %32
'
\
0
'
;: %32
i
+
+
): %13
if: %32
(
s
[
i
]: %32
!
=: %32
c
): %13
s
[
j
+
+
]: %32
=: %32
s
[
i
]
;: %13
s
[
j
]: %32
=: %32
'
\
0
'
;: %13
}: %13
Each: %32
time: %32
a: %32
non
-
c: %32
occurs
,: %32
it: %32
is: %32
copied: %32
into: %32
the: %32
current: %32
j: %32
position
,: %32
and: %32
only: %32
then: %32
is: %32
j: %32
incremented: %32
to: %32
be: %13
ready: %32
for: %32
the: %32
next: %32
character
.: %32
This: %32
is: %32
exactly: %32
equivalent: %32
to: %13
Chapter: %32
2: %32
-: %32
Types
,: %32
Operators: %32
and: %32
Expressions: %13
if: %32
(
s
[
i
]: %32
!
=: %32
c
): %32
{: %13
s
[
j
]: %32
=: %32
s
[
i
]
;: %13
j
+
+
;: %13
}: %13
Another: %32
example: %32
of: %32
a: %32
similar: %32
construction: %32
comes: %32
from: %32
the: %32
getline: %32
function: %32
that: %32
we: %32
wrote: %32
in: %32
Chapter: %13
1
,: %32
where: %32
we: %32
can: %32
replace: %13
if: %32
(
c: %32
=
=: %32
'
\
n
'
): %32
{: %13
s
[
i
]: %32
=: %32
c
;: %13
+
+
i
;: %13
}: %13
by: %32
the: %32
more: %32
compact: %13
if: %32
(
c: %32
=
=: %32
'
\
n
'
): %13
s
[
i
+
+
]: %32
=: %32
c
;: %13
As: %32
a: %32
third: %32
example
,: %32
consider: %32
the: %32
standard: %32
function: %32
strcat
(
s
,
t
)
,: %32
which: %32
concatenates: %32
the: %32
string: %32
t: %32
to: %13
the: %32
end: %32
of: %32
string: %32
s
.: %32
strcat: %32
assumes: %32
that: %32
there: %32
is: %32
enough: %32
space: %32
in: %32
s: %32
to: %32
hold: %32
the: %32
combination
.: %32
As: %32
we: %13
have: %32
written: %32
it
,: %32
strcat: %32
returns: %32
no: %32
value
;: %32
the: %32
standard: %32
library: %32
version: %32
returns: %32
a: %32
pointer: %32
to: %32
the: %32
resulting: %13
string
.: %13
/
*: %32
strcat
:: %32
concatenate: %32
t: %32
to: %32
end: %32
of: %32
s
;: %32
s: %32
must: %32
be: %32
big: %32
enough: %32
*
/: %13
void: %32
strcat
(
char: %32
s
[
]
,: %32
char: %32
t
[
]
): %13
{: %13
int: %32
i
,: %32
j
;: %13
i: %32
=: %32
j: %32
=: %32
0
;: %13
while: %32
(
s
[
i
]: %32
!
=: %32
'
\
0
'
): %32
/
*: %32
find: %32
end: %32
of: %32
s: %32
*
/: %13
i
+
+
;: %13
while: %32
(
(
s
[
i
+
+
]: %32
=: %32
t
[
j
+
+
]
): %32
!
=: %32
'
\
0
'
): %32
/
*: %32
copy: %32
t: %32
*
/: %13
;: %13
}: %13
As: %32
each: %32
member: %32
is: %32
copied: %32
from: %32
t: %32
to: %32
s
,: %32
the: %32
postfix: %32
+
+: %32
is: %32
applied: %32
to: %32
both: %32
i: %32
and: %32
j: %32
to: %32
make: %32
sure: %32
that: %32
they: %13
are: %32
in: %32
position: %32
for: %32
the: %32
next: %32
pass: %32
through: %32
the: %32
loop
.: %13
Exercise: %32
2
-
4
.: %32
Write: %32
an: %32
alternative: %32
version: %32
of: %32
squeeze
(
s
1
,
s
2
): %32
that: %32
deletes: %32
each: %32
character: %32
in: %32
s
1: %32
that: %13
matches: %32
any: %32
character: %32
in: %32
the: %32
string: %32
s
2
.: %13
Chapter: %32
2: %32
-: %32
Types
,: %32
Operators: %32
and: %32
Expressions: %13
Exercise: %32
2
-
5
.: %32
Write: %32
the: %32
function: %32
any
(
s
1
,
s
2
)
,: %32
which: %32
returns: %32
the: %32
first: %32
location: %32
in: %32
a: %32
string: %32
s
1: %32
where: %32
any: %13
character: %32
from: %32
the: %32
string: %32
s
2: %32
occurs
,: %32
or: %32
-
1: %32
if: %32
s
1: %32
contains: %32
no: %32
characters: %32
from: %32
s
2
.: %32
(
The: %32
standard: %32
library: %13
function: %32
strpbrk: %32
does: %32
the: %32
same: %32
job: %32
but: %32
returns: %32
a: %32
pointer: %32
to: %32
the: %32
location
.
): %13
2
.
9: %32
Bitwise: %32
Operators: %13
C: %32
provides: %32
six: %32
operators: %32
for: %32
bit: %32
manipulation
;: %32
these: %32
may: %32
only: %32
be: %32
applied: %32
to: %32
integral: %32
operands
,: %32
that: %32
is
,: %13
char
,: %32
short
,: %32
int
,: %32
and: %32
long
,: %32
whether: %32
signed: %32
or: %32
unsigned
.: %13
&: %13
|: %13
^: %13
<
<: %13
>
>: %13
~: %13
bitwise: %32
AND: %13
bitwise: %32
inclusive: %32
OR: %13
bitwise: %32
exclusive: %32
OR: %13
left: %32
shift: %13
right: %32
shift: %13
one
'
s: %32
complement: %32
(
unary
): %13
The: %32
bitwise: %32
AND: %32
operator: %32
&: %32
is: %32
often: %32
used: %32
to: %32
mask: %32
off: %32
some: %32
set: %32
of: %32
bits
,: %32
for: %32
example: %13
n: %32
=: %32
n: %32
&: %32
0
1
7
7
;: %13
sets: %32
to: %32
zero: %32
all: %32
but: %32
the: %32
low
-
order: %32
7: %32
bits: %32
of: %32
n
.: %13
The: %32
bitwise: %32
OR: %32
operator: %32
|: %32
is: %32
used: %32
to: %32
turn: %32
bits: %32
on
:: %13
x: %32
=: %32
x: %32
|: %32
SET
_
ON
;: %13
sets: %32
to: %32
one: %32
in: %32
x: %32
the: %32
bits: %32
that: %32
are: %32
set: %32
to: %32
one: %32
in: %32
SET
_
ON
.: %13
The: %32
bitwise: %32
exclusive: %32
OR: %32
operator: %32
^: %32
sets: %32
a: %32
one: %32
in: %32
each: %32
bit: %32
position: %32
where: %32
its: %32
operands: %32
have: %32
different: %32
bits
,: %13
and: %32
zero: %32
where: %32
they: %32
are: %32
the: %32
same
.: %13
One: %32
must: %32
distinguish: %32
the: %32
bitwise: %32
operators: %32
&: %32
and: %32
|: %32
from: %32
the: %32
logical: %32
operators: %32
&
&: %32
and: %32
|
|
,: %32
which: %32
imply: %13
left
-
to
-
right: %32
evaluation: %32
of: %32
a: %32
truth: %32
value
.: %32
For: %32
example
,: %32
if: %32
x: %32
is: %32
1: %32
and: %32
y: %32
is: %32
2
,: %32
then: %32
x: %32
&: %32
y: %32
is: %32
zero: %32
while: %32
x: %32
&
&: %13
y: %32
is: %32
one
.: %13
The: %32
shift: %32
operators: %32
<
<: %32
and: %32
>
>: %32
perform: %32
left: %32
and: %32
right: %32
shifts: %32
of: %32
their: %32
left: %32
operand: %32
by: %32
the: %32
number: %32
of: %32
bit: %13
positions: %32
given: %32
by: %32
the: %32
right: %32
operand
,: %32
which: %32
must: %32
be: %32
non
-
negative
.: %32
Thus: %32
x: %32
<
<: %32
2: %32
shifts: %32
the: %32
value: %32
of: %32
x: %32
by: %13
two: %32
positions
,: %32
filling: %32
vacated: %32
bits: %32
with: %32
zero
;: %32
this: %32
is: %32
equivalent: %32
to: %32
multiplication: %32
by: %32
4
.: %32
Right: %32
shifting: %32
an: %13
unsigned: %32
quantity: %32
always: %32
fits: %32
the: %32
vacated: %32
bits: %32
with: %32
zero
.: %32
Right: %32
shifting: %32
a: %32
signed: %32
quantity: %32
will: %32
fill: %32
with: %13
Chapter: %32
2: %32
-: %32
Types
,: %32
Operators: %32
and: %32
Expressions: %13
bit: %32
signs: %32
(
`
`
arithmetic: %32
shift
'
'
): %32
on: %32
some: %32
machines: %32
and: %32
with: %32
0
-
bits: %32
(
`
`
logical: %32
shift
'
'
): %32
on: %32
others
.: %13
The: %32
unary: %32
operator: %32
~: %32
yields: %32
the: %32
one
'
s: %32
complement: %32
of: %32
an: %32
integer
;: %32
that: %32
is
,: %32
it: %32
converts: %32
each: %32
1
-
bit: %32
into: %32
a: %32
0
-
bit: %13
and: %32
vice: %32
versa
.: %32
For: %32
example: %13
x: %32
=: %32
x: %32
&: %32
~
0
7
7: %13
sets: %32
the: %32
last: %32
six: %32
bits: %32
of: %32
x: %32
to: %32
zero
.: %32
Note: %32
that: %32
x: %32
&: %32
~
0
7
7: %32
is: %32
independent: %32
of: %32
word: %32
length
,: %32
and: %32
is: %32
thus: %13
preferable: %32
to
,: %32
for: %32
example
,: %32
x: %32
&: %32
0
1
7
7
7
0
0
,: %32
which: %32
assumes: %32
that: %32
x: %32
is: %32
a: %32
1
6
-
bit: %32
quantity
.: %32
The: %32
portable: %32
form: %13
involves: %32
no: %32
extra: %32
cost
,: %32
since: %32
~
0
7
7: %32
is: %32
a: %32
constant: %32
expression: %32
that: %32
can: %32
be: %32
evaluated: %32
at: %32
compile: %32
time
.: %13
As: %32
an: %32
illustration: %32
of: %32
some: %32
of: %32
the: %32
bit: %32
operators
,: %32
consider: %32
the: %32
function: %32
getbits
(
x
,
p
,
n
): %32
that: %32
returns: %32
the: %13
(
right: %32
adjusted
): %32
n
-
bit: %32
field: %32
of: %32
x: %32
that: %32
begins: %32
at: %32
position: %32
p
.: %32
We: %32
assume: %32
that: %32
bit: %32
position: %32
0: %32
is: %32
at: %32
the: %32
right: %32
end: %13
and: %32
that: %32
n: %32
and: %32
p: %32
are: %32
sensible: %32
positive: %32
values
.: %32
For: %32
example
,: %32
getbits
(
x
,
4
,
3
): %32
returns: %32
the: %32
three: %32
bits: %32
in: %13
positions: %32
4
,: %32
3: %32
and: %32
2
,: %32
right
-
adjusted
.: %13
/
*: %32
getbits
:: %32
get: %32
n: %32
bits: %32
from: %32
position: %32
p: %32
*
/: %13
unsigned: %32
getbits
(
unsigned: %32
x
,: %32
int: %32
p
,: %32
int: %32
n
): %13
{: %13
return: %32
(
x: %32
>
>: %32
(
p
+
1
-
n
)
): %32
&: %32
~
(
~
0: %32
<
<: %32
n
)
;: %13
}: %13
The: %32
expression: %32
x: %32
>
>: %32
(
p
+
1
-
n
): %32
moves: %32
the: %32
desired: %32
field: %32
to: %32
the: %32
right: %32
end: %32
of: %32
the: %32
word
.: %32
~
0: %32
is: %32
all: %32
1
-
bits
;: %13
shifting: %32
it: %32
left: %32
n: %32
positions: %32
with: %32
~
0
<
<
n: %32
places: %32
zeros: %32
in: %32
the: %32
rightmost: %32
n: %32
bits
;: %32
complementing: %32
that: %32
with: %32
~: %13
makes: %32
a: %32
mask: %32
with: %32
ones: %32
in: %32
the: %32
rightmost: %32
n: %32
bits
.: %13
Exercise: %32
2
-
6
.: %32
Write: %32
a: %32
function: %32
setbits
(
x
,
p
,
n
,
y
): %32
that: %32
returns: %32
x: %32
with: %32
the: %32
n: %32
bits: %32
that: %32
begin: %32
at: %32
position: %13
p: %32
set: %32
to: %32
the: %32
rightmost: %32
n: %32
bits: %32
of: %32
y
,: %32
leaving: %32
the: %32
other: %32
bits: %32
unchanged
.: %13
Exercise: %32
2
-
7
.: %32
Write: %32
a: %32
function: %32
invert
(
x
,
p
,
n
): %32
that: %32
returns: %32
x: %32
with: %32
the: %32
n: %32
bits: %32
that: %32
begin: %32
at: %32
position: %32
p: %13
inverted: %32
(
i
.
e
.
,: %32
1: %32
changed: %32
into: %32
0: %32
and: %32
vice: %32
versa
)
,: %32
leaving: %32
the: %32
others: %32
unchanged
.: %13
Exercise: %32
2
-
8
.: %32
Write: %32
a: %32
function: %32
rightrot
(
x
,
n
): %32
that: %32
returns: %32
the: %32
value: %32
of: %32
the: %32
integer: %32
x: %32
rotated: %32
to: %32
the: %13
right: %32
by: %32
n: %32
positions
.: %13
2
.
1
0: %32
Assignment: %32
Operators: %32
and: %32
Expressions: %13
An: %32
expression: %32
such: %32
as: %13
i: %32
=: %32
i: %32
+: %32
2: %13
Chapter: %32
2: %32
-: %32
Types
,: %32
Operators: %32
and: %32
Expressions: %13
in: %32
which: %32
the: %32
variable: %32
on: %32
the: %32
left: %32
side: %32
is: %32
repeated: %32
immediately: %32
on: %32
the: %32
right
,: %32
can: %32
be: %32
written: %32
in: %32
the: %13
compressed: %32
form: %13
i: %32
+
=: %32
2: %13
The: %32
operator: %32
+
=: %32
is: %32
called: %32
an: %32
assignment: %32
operator
.: %13
Most: %32
binary: %32
operators: %32
(
operators: %32
like: %32
+: %32
that: %32
have: %32
a: %32
left: %32
and: %32
right: %32
operand
): %32
have: %32
a: %32
corresponding: %13
assignment: %32
operator: %32
op
=
,: %32
where: %32
op: %32
is: %32
one: %32
of: %13
+: %13
-: %13
*: %13
/: %13
%: %13
<
<: %13
>
>: %13
&: %13
^: %13
|: %13
If: %32
expr
1: %32
and: %32
expr
2: %32
are: %32
expressions
,: %32
then: %13
expr
1: %32
op
=: %32
expr
2: %13
is: %32
equivalent: %32
to: %13
expr
1: %32
=: %32
(
expr
1
): %32
op: %32
(
expr
2
): %13
except: %32
that: %32
expr
1: %32
is: %32
computed: %32
only: %32
once
.: %32
Notice: %32
the: %32
parentheses: %32
around: %32
expr
2
:: %13
x: %32
*
=: %32
y: %32
+: %32
1: %13
means: %13
x: %32
=: %32
x: %32
*: %32
(
y: %32
+: %32
1
): %13
rather: %32
than: %13
x: %32
=: %32
x: %32
*: %32
y: %32
+: %32
1: %13
As: %32
an: %32
example
,: %32
the: %32
function: %32
bitcount: %32
counts: %32
the: %32
number: %32
of: %32
1
-
bits: %32
in: %32
its: %32
integer: %32
argument
.: %13
/
*: %32
bitcount
:: %32
count: %32
1: %32
bits: %32
in: %32
x: %32
*
/: %13
int: %32
bitcount
(
unsigned: %32
x
): %13
{: %13
int: %32
b
;: %13
for: %32
(
b: %32
=: %32
0
;: %32
x: %32
!
=: %32
0
;: %32
x: %32
>
>
=: %32
1
): %13
if: %32
(
x: %32
&: %32
0
1
): %13
Chapter: %32
2: %32
-: %32
Types
,: %32
Operators: %32
and: %32
Expressions: %13
b
+
+
;: %13
return: %32
b
;: %13
}: %13
Declaring: %32
the: %32
argument: %32
x: %32
to: %32
be: %32
an: %32
unsigned: %32
ensures: %32
that: %32
when: %32
it: %32
is: %32
right
-
shifted
,: %32
vacated: %32
bits: %32
will: %32
be: %13
filled: %32
with: %32
zeros
,: %32
not: %32
sign: %32
bits
,: %32
regardless: %32
of: %32
the: %32
machine: %32
the: %32
program: %32
is: %32
run: %32
on
.: %13
Quite: %32
apart: %32
from: %32
conciseness
,: %32
assignment: %32
operators: %32
have: %32
the: %32
advantage: %32
that: %32
they: %32
correspond: %32
better: %32
to: %32
the: %13
way: %32
people: %32
think
.: %32
We: %32
say: %32
`
`
add: %32
2: %32
to: %32
i
'
': %32
or: %32
`
`
increment: %32
i: %32
by: %32
2
'
'
,: %32
not: %32
`
`
take: %32
i
,: %32
add: %32
2
,: %32
then: %32
put: %32
the: %32
result: %13
back: %32
in: %32
i
'
'
.: %32
Thus: %32
the: %32
expression: %32
i: %32
+
=: %32
2: %32
is: %32
preferable: %32
to: %32
i: %32
=: %32
i
+
2
.: %32
In: %32
addition
,: %32
for: %32
a: %32
complicated: %13
expression: %32
like: %13
yyval
[
yypv
[
p
3
+
p
4
]: %32
+: %32
yypv
[
p
1
]
]: %32
+
=: %32
2: %13
the: %32
assignment: %32
operator: %32
makes: %32
the: %32
code: %32
easier: %32
to: %32
understand
,: %32
since: %32
the: %32
reader: %32
doesn
'
t: %32
have: %32
to: %32
check: %13
painstakingly: %32
that: %32
two: %32
long: %32
expressions: %32
are: %32
indeed: %32
the: %32
same
,: %32
or: %32
to: %32
wonder: %32
why: %32
they
'
re: %32
not
.: %32
And: %32
an: %13
assignment: %32
operator: %32
may: %32
even: %32
help: %32
a: %32
compiler: %32
to: %32
produce: %32
efficient: %32
code
.: %13
We: %32
have: %32
already: %32
seen: %32
that: %32
the: %32
assignment: %32
statement: %32
has: %32
a: %32
value: %32
and: %32
can: %32
occur: %32
in: %32
expressions
;: %32
the: %32
most: %13
common: %32
example: %32
is: %13
while: %32
(
(
c: %32
=: %32
getchar
(
)
): %32
!
=: %32
EOF
): %13
.
.
.: %13
The: %32
other: %32
assignment: %32
operators: %32
(
+
=
,: %32
-
=
,: %32
etc
.
): %32
can: %32
also: %32
occur: %32
in: %32
expressions
,: %32
although: %32
this: %32
is: %32
less: %32
frequent
.: %13
In: %32
all: %32
such: %32
expressions
,: %32
the: %32
type: %32
of: %32
an: %32
assignment: %32
expression: %32
is: %32
the: %32
type: %32
of: %32
its: %32
left: %32
operand
,: %32
and: %32
the: %32
value: %13
is: %32
the: %32
value: %32
after: %32
the: %32
assignment
.: %13
Exercise: %32
2
-
9
.: %32
In: %32
a: %32
two
'
s: %32
complement: %32
number: %32
system
,: %32
x: %32
&
=: %32
(
x
-
1
): %32
deletes: %32
the: %32
rightmost: %32
1
-
bit: %32
in: %32
x
.: %13
Explain: %32
why
.: %32
Use: %32
this: %32
observation: %32
to: %32
write: %32
a: %32
faster: %32
version: %32
of: %32
bitcount
.: %13
2
.
1
1: %32
Conditional: %32
Expressions: %13
The: %32
statements: %13
if: %32
(
a: %32
>: %32
b
): %13
z: %32
=: %32
a
;: %13
else: %13
z: %32
=: %32
b
;: %13
Chapter: %32
2: %32
-: %32
Types
,: %32
Operators: %32
and: %32
Expressions: %13
compute: %32
in: %32
z: %32
the: %32
maximum: %32
of: %32
a: %32
and: %32
b
.: %32
The: %32
conditional: %32
expression
,: %32
written: %32
with: %32
the: %32
ternary: %32
operator: %13
`
`
?
::
'
'
,: %32
provides: %32
an: %32
alternate: %32
way: %32
to: %32
write: %32
this: %32
and: %32
similar: %32
constructions
.: %32
In: %32
the: %32
expression: %13
expr
1: %32
?: %32
expr
2: %32
:: %32
expr
3: %13
the: %32
expression: %32
expr
1: %32
is: %32
evaluated: %32
first
.: %32
If: %32
it: %32
is: %32
non
-
zero: %32
(
true
)
,: %32
then: %32
the: %32
expression: %32
expr
2: %32
is: %32
evaluated
,: %32
and: %13
that: %32
is: %32
the: %32
value: %32
of: %32
the: %32
conditional: %32
expression
.: %32
Otherwise: %32
expr
3: %32
is: %32
evaluated
,: %32
and: %32
that: %32
is: %32
the: %32
value
.: %32
Only: %13
one: %32
of: %32
expr
2: %32
and: %32
expr
3: %32
is: %32
evaluated
.: %32
Thus: %32
to: %32
set: %32
z: %32
to: %32
the: %32
maximum: %32
of: %32
a: %32
and: %32
b
,: %13
z: %32
=: %32
(
a: %32
>: %32
b
): %32
?: %32
a: %32
:: %32
b
;: %13
/
*: %32
z: %32
=: %32
max
(
a
,: %32
b
): %32
*
/: %13
It: %32
should: %32
be: %32
noted: %32
that: %32
the: %32
conditional: %32
expression: %32
is: %32
indeed: %32
an: %32
expression
,: %32
and: %32
it: %32
can: %32
be: %32
used: %32
wherever: %13
any: %32
other: %32
expression: %32
can: %32
be
.: %32
If: %32
expr
2: %32
and: %32
expr
3: %32
are: %32
of: %32
different: %32
types
,: %32
the: %32
type: %32
of: %32
the: %32
result: %32
is: %32
determined: %13
by: %32
the: %32
conversion: %32
rules: %32
discussed: %32
earlier: %32
in: %32
this: %32
chapter
.: %32
For: %32
example
,: %32
if: %32
f: %32
is: %32
a: %32
float: %32
and: %32
n: %32
an: %32
int
,: %13
then: %32
the: %32
expression: %13
(
n: %32
>: %32
0
): %32
?: %32
f: %32
:: %32
n: %13
is: %32
of: %32
type: %32
float: %32
regardless: %32
of: %32
whether: %32
n: %32
is: %32
positive
.: %13
Parentheses: %32
are: %32
not: %32
necessary: %32
around: %32
the: %32
first: %32
expression: %32
of: %32
a: %32
conditional: %32
expression
,: %32
since: %32
the: %13
precedence: %32
of: %32
?
:: %32
is: %32
very: %32
low
,: %32
just: %32
above: %32
assignment
.: %32
They: %32
are: %32
advisable: %32
anyway
,: %32
however
,: %32
since: %32
they: %13
make: %32
the: %32
condition: %32
part: %32
of: %32
the: %32
expression: %32
easier: %32
to: %32
see
.: %13
The: %32
conditional: %32
expression: %32
often: %32
leads: %32
to: %32
succinct: %32
code
.: %32
For: %32
example
,: %32
this: %32
loop: %32
prints: %32
n: %32
elements: %32
of: %32
an: %13
array
,: %32
1
0: %32
per: %32
line
,: %32
with: %32
each: %32
column: %32
separated: %32
by: %32
one: %32
blank
,: %32
and: %32
with: %32
each: %32
line: %32
(
including: %32
the: %32
last
): %13
terminated: %32
by: %32
a: %32
newline
.: %13
for: %32
(
i: %32
=: %32
0
;: %32
i: %32
<: %32
n
;: %32
i
+
+
): %13
printf
(
"
%:
6
d
%:
c
"
,: %32
a
[
i
]
,: %32
(
i
%:
1
0
=
=
9: %32
|
|: %32
i
=
=
n
-
1
): %32
?: %32
'
\
n
': %32
:: %32
': %32
'
)
;: %13
A: %32
newline: %32
is: %32
printed: %32
after: %32
every: %32
tenth: %32
element
,: %32
and: %32
after: %32
the: %32
n
-
th
.: %32
All: %32
other: %32
elements: %32
are: %32
followed: %32
by: %32
one: %13
blank
.: %32
This: %32
might: %32
look: %32
tricky
,: %32
but: %32
it
'
s: %32
more: %32
compact: %32
than: %32
the: %32
equivalent: %32
if
-
else
.: %32
Another: %32
good: %13
example: %32
is: %13
printf
(
"
You: %32
have: %32
%:
d: %32
items
%:
s
.
\
n
"
,: %32
n
,: %32
n
=
=
1: %32
?: %32
"
": %32
:: %32
"
s
"
)
;: %13
Exercise: %32
2
-
1
0
.: %32
Rewrite: %32
the: %32
function: %32
lower
,: %32
which: %32
converts: %32
upper: %32
case: %32
letters: %32
to: %32
lower: %32
case
,: %32
with: %32
a: %13
conditional: %32
expression: %32
instead: %32
of: %32
if
-
else
.: %13
Chapter: %32
2: %32
-: %32
Types
,: %32
Operators: %32
and: %32
Expressions: %13
2
.
1
2: %32
Precedence: %32
and: %32
Order: %32
of: %32
Evaluation: %13
Table: %32
2
.
1: %32
summarizes: %32
the: %32
rules: %32
for: %32
precedence: %32
and: %32
associativity: %32
of: %32
all: %32
operators
,: %32
including: %32
those: %32
that: %32
we: %13
have: %32
not: %32
yet: %32
discussed
.: %32
Operators: %32
on: %32
the: %32
same: %32
line: %32
have: %32
the: %32
same: %32
precedence
;: %32
rows: %32
are: %32
in: %32
order: %32
of: %13
decreasing: %32
precedence
,: %32
so
,: %32
for: %32
example
,: %32
*
,: %32
/
,: %32
and: %32
%: %32
all: %32
have: %32
the: %32
same: %32
precedence
,: %32
which: %32
is: %32
higher: %32
than: %13
that: %32
of: %32
binary: %32
+: %32
and: %32
-
.: %32
The: %32
`
`
operator
'
': %32
(
): %32
refers: %32
to: %32
function: %32
call
.: %32
The: %32
operators: %32
-
>: %32
and: %32
.: %32
are: %32
used: %32
to: %13
access: %32
members: %32
of: %32
structures
;: %32
they: %32
will: %32
be: %32
covered: %32
in: %32
Chapter: %32
6
,: %32
along: %32
with: %32
sizeof: %32
(
size: %32
of: %32
an: %32
object
)
.: %13
Chapter: %32
5: %32
discusses: %32
*: %32
(
indirection: %32
through: %32
a: %32
pointer
): %32
and: %32
&: %32
(
address: %32
of: %32
an: %32
object
)
,: %32
and: %32
Chapter: %32
3: %13
discusses: %32
the: %32
comma: %32
operator
.: %13
Operators: %13
Associativity: %13
(
): %32
[
]: %32
-
>: %32
.: %32
left: %32
to: %32
right: %13
!: %32
~: %32
+
+: %32
-
-: %32
+: %32
-: %32
*: %32
(
type
): %32
sizeof: %32
right: %32
to: %32
left: %13
*: %32
/: %32
%: %32
left: %32
to: %32
right: %13
+: %32
-: %32
left: %32
to: %32
right: %13
>
>: %32
left: %32
to: %32
right: %13
<: %32
<
=: %32
>: %32
>
=: %32
left: %32
to: %32
right: %13
=
=: %32
!
=: %32
left: %32
to: %32
right: %13
&: %32
left: %32
to: %32
right: %13
^: %32
left: %32
to: %32
right: %13
|: %32
left: %32
to: %32
right: %13
&
&: %32
left: %32
to: %32
right: %13
|
|: %32
left: %32
to: %32
right: %13
?
:: %32
right: %32
to: %32
left: %13
<
<: %13
=: %32
+
=: %32
-
=: %32
*
=: %32
/
=: %32
%:
=: %32
&
=: %32
^
=: %32
|
=: %32
<
<
=: %32
>
>
=: %32
right: %32
to: %32
left: %13
left: %32
to: %32
right: %13
,: %13
Unary: %32
&: %32
+
,: %32
-
,: %32
and: %32
*: %32
have: %32
higher: %32
precedence: %32
than: %32
the: %32
binary: %32
forms
.: %13
Table: %32
2
.
1
:: %32
Precedence: %32
and: %32
Associativity: %32
of: %32
Operators: %13
Note: %32
that: %32
the: %32
precedence: %32
of: %32
the: %32
bitwise: %32
operators: %32
&
,: %32
^
,: %32
and: %32
|: %32
falls: %32
below: %32
=
=: %32
and: %32
!
=
.: %32
This: %32
implies: %32
that: %32
bit
-: %13
testing: %32
expressions: %32
like: %13
if: %32
(
(
x: %32
&: %32
MASK
): %32
=
=: %32
0
): %32
.
.
.: %13
Chapter: %32
2: %32
-: %32
Types
,: %32
Operators: %32
and: %32
Expressions: %13
must: %32
be: %32
fully: %32
parenthesized: %32
to: %32
give: %32
proper: %32
results
.: %13
C
,: %32
like: %32
most: %32
languages
,: %32
does: %32
not: %32
specify: %32
the: %32
order: %32
in: %32
which: %32
the: %32
operands: %32
of: %32
an: %32
operator: %32
are: %32
evaluated
.: %13
(
The: %32
exceptions: %32
are: %32
&
&
,: %32
|
|
,: %32
?
::
,: %32
and: %32
`
,
'
.
): %32
For: %32
example
,: %32
in: %32
a: %32
statement: %32
like: %13
x: %32
=: %32
f
(
): %32
+: %32
g
(
)
;: %13
f: %32
may: %32
be: %32
evaluated: %32
before: %32
g: %32
or: %32
vice: %32
versa
;: %32
thus: %32
if: %32
either: %32
f: %32
or: %32
g: %32
alters: %32
a: %32
variable: %32
on: %32
which: %32
the: %32
other: %13
depends
,: %32
x: %32
can: %32
depend: %32
on: %32
the: %32
order: %32
of: %32
evaluation
.: %32
Intermediate: %32
results: %32
can: %32
be: %32
stored: %32
in: %32
temporary: %13
variables: %32
to: %32
ensure: %32
a: %32
particular: %32
sequence
.: %13
Similarly
,: %32
the: %32
order: %32
in: %32
which: %32
function: %32
arguments: %32
are: %32
evaluated: %32
is: %32
not: %32
specified
,: %32
so: %32
the: %32
statement: %13
printf
(
"
%:
d: %32
%:
d
\
n
"
,: %32
+
+
n
,: %32
power
(
2
,: %32
n
)
)
;: %13
/
*: %32
WRONG: %32
*
/: %13
can: %32
produce: %32
different: %32
results: %32
with: %32
different: %32
compilers
,: %32
depending: %32
on: %32
whether: %32
n: %32
is: %32
incremented: %32
before: %13
power: %32
is: %32
called
.: %32
The: %32
solution
,: %32
of: %32
course
,: %32
is: %32
to: %32
write: %13
+
+
n
;: %13
printf
(
"
%:
d: %32
%:
d
\
n
"
,: %32
n
,: %32
power
(
2
,: %32
n
)
)
;: %13
Function: %32
calls
,: %32
nested: %32
assignment: %32
statements
,: %32
and: %32
increment: %32
and: %32
decrement: %32
operators: %32
cause: %32
`
`
side: %13
effects
'
': %32
-: %32
some: %32
variable: %32
is: %32
changed: %32
as: %32
a: %32
by
-
product: %32
of: %32
the: %32
evaluation: %32
of: %32
an: %32
expression
.: %32
In: %32
any: %32
expression: %13
involving: %32
side: %32
effects
,: %32
there: %32
can: %32
be: %32
subtle: %32
dependencies: %32
on: %32
the: %32
order: %32
in: %32
which: %32
variables: %32
taking: %32
part: %32
in: %32
the: %13
expression: %32
are: %32
updated
.: %32
One: %32
unhappy: %32
situation: %32
is: %32
typified: %32
by: %32
the: %32
statement: %13
a
[
i
]: %32
=: %32
i
+
+
;: %13
The: %32
question: %32
is: %32
whether: %32
the: %32
subscript: %32
is: %32
the: %32
old: %32
value: %32
of: %32
i: %32
or: %32
the: %32
new
.: %32
Compilers: %32
can: %32
interpret: %32
this: %32
in: %13
different: %32
ways
,: %32
and: %32
generate: %32
different: %32
answers: %32
depending: %32
on: %32
their: %32
interpretation
.: %32
The: %32
standard: %13
intentionally: %32
leaves: %32
most: %32
such: %32
matters: %32
unspecified
.: %32
When: %32
side: %32
effects: %32
(
assignment: %32
to: %32
variables
): %32
take: %32
place: %13
within: %32
an: %32
expression: %32
is: %32
left: %32
to: %32
the: %32
discretion: %32
of: %32
the: %32
compiler
,: %32
since: %32
the: %32
best: %32
order: %32
depends: %32
strongly: %32
on: %13
machine: %32
architecture
.: %32
(
The: %32
standard: %32
does: %32
specify: %32
that: %32
all: %32
side: %32
effects: %32
on: %32
arguments: %32
take: %32
effect: %32
before: %32
a: %13
function: %32
is: %32
called
,: %32
but: %32
that: %32
would: %32
not: %32
help: %32
in: %32
the: %32
call: %32
to: %32
printf: %32
above
.
): %13
The: %32
moral: %32
is: %32
that: %32
writing: %32
code: %32
that: %32
depends: %32
on: %32
order: %32
of: %32
evaluation: %32
is: %32
a: %32
bad: %32
programming: %32
practice: %32
in: %32
any: %13
language
.: %32
Naturally
,: %32
it: %32
is: %32
necessary: %32
to: %32
know: %32
what: %32
things: %32
to: %32
avoid
,: %32
but: %32
if: %32
you: %32
don
'
t: %32
know: %32
how: %32
they: %32
are: %13
done: %32
on: %32
various: %32
machines
,: %32
you: %32
won
'
t: %32
be: %32
tempted: %32
to: %32
take: %32
advantage: %32
of: %32
a: %32
particular: %32
implementation
.: %13
Chapter: %32
2: %32
-: %32
Types
,: %32
Operators: %32
and: %32
Expressions: %13
Back: %32
to: %32
Chapter: %32
1: %32
-
-: %32
Index: %32
-
-: %32
Chapter: %32
3: %13
Chapter: %32
3: %32
-: %32
Control: %32
Flow: %13
Back: %32
to: %32
Chapter: %32
2: %32
-
-: %32
Index: %32
-
-: %32
Chapter: %32
4: %13
Chapter: %32
3: %32
-: %32
Control: %32
Flow: %13
The: %32
control
-
flow: %32
of: %32
a: %32
language: %32
specify: %32
the: %32
order: %32
in: %32
which: %32
computations: %32
are: %32
performed
.: %32
We: %32
have: %32
already: %13
met: %32
the: %32
most: %32
common: %32
control
-
flow: %32
constructions: %32
in: %32
earlier: %32
examples
;: %32
here: %32
we: %32
will: %32
complete: %32
the: %32
set
,: %32
and: %13
be: %32
more: %32
precise: %32
about: %32
the: %32
ones: %32
discussed: %32
before
.: %13
3
.
1: %32
Statements: %32
and: %32
Blocks: %13
An: %32
expression: %32
such: %32
as: %32
x: %32
=: %32
0: %32
or: %32
i
+
+: %32
or: %32
printf
(
.
.
.
): %32
becomes: %32
a: %32
statement: %32
when: %32
it: %32
is: %32
followed: %32
by: %32
a: %13
semicolon
,: %32
as: %32
in: %13
x: %32
=: %32
0
;: %13
i
+
+
;: %13
printf
(
.
.
.
)
;: %13
In: %32
C
,: %32
the: %32
semicolon: %32
is: %32
a: %32
statement: %32
terminator
,: %32
rather: %32
than: %32
a: %32
separator: %32
as: %32
it: %32
is: %32
in: %32
languages: %32
like: %32
Pascal
.: %13
Braces: %32
{: %32
and: %32
}: %32
are: %32
used: %32
to: %32
group: %32
declarations: %32
and: %32
statements: %32
together: %32
into: %32
a: %32
compound: %32
statement
,: %32
or: %13
block
,: %32
so: %32
that: %32
they: %32
are: %32
syntactically: %32
equivalent: %32
to: %32
a: %32
single: %32
statement
.: %32
The: %32
braces: %32
that: %32
surround: %32
the: %13
statements: %32
of: %32
a: %32
function: %32
are: %32
one: %32
obvious: %32
example
;: %32
braces: %32
around: %32
multiple: %32
statements: %32
after: %32
an: %32
if
,: %32
else
,: %13
while
,: %32
or: %32
for: %32
are: %32
another
.: %32
(
Variables: %32
can: %32
be: %32
declared: %32
inside: %32
any: %32
block
;: %32
we: %32
will: %32
talk: %32
about: %32
this: %32
in: %13
Chapter: %32
4
.
): %32
There: %32
is: %32
no: %32
semicolon: %32
after: %32
the: %32
right: %32
brace: %32
that: %32
ends: %32
a: %32
block
.: %13
3
.
2: %32
If
-
Else: %13
The: %32
if
-
else: %32
statement: %32
is: %32
used: %32
to: %32
express: %32
decisions
.: %32
Formally: %32
the: %32
syntax: %32
is: %13
if: %32
(
expression
): %13
statement
1: %13
else: %13
statement
2: %13
Chapter: %32
3: %32
-: %32
Control: %32
Flow: %13
where: %32
the: %32
else: %32
part: %32
is: %32
optional
.: %32
The: %32
expression: %32
is: %32
evaluated
;: %32
if: %32
it: %32
is: %32
true: %32
(
that: %32
is
,: %32
if: %32
expression: %32
has: %32
a: %32
non
-: %13
zero: %32
value
)
,: %32
statement
1: %32
is: %32
executed
.: %32
If: %32
it: %32
is: %32
false: %32
(
expression: %32
is: %32
zero
): %32
and: %32
if: %32
there: %32
is: %32
an: %32
else: %32
part
,: %13
statement
2: %32
is: %32
executed: %32
instead
.: %13
Since: %32
an: %32
if: %32
tests: %32
the: %32
numeric: %32
value: %32
of: %32
an: %32
expression
,: %32
certain: %32
coding: %32
shortcuts: %32
are: %32
possible
.: %32
The: %32
most: %13
obvious: %32
is: %32
writing: %13
if: %32
(
expression
): %13
instead: %32
of: %13
if: %32
(
expression: %32
!
=: %32
0
): %13
Sometimes: %32
this: %32
is: %32
natural: %32
and: %32
clear
;: %32
at: %32
other: %32
times: %32
it: %32
can: %32
be: %32
cryptic
.: %13
Because: %32
the: %32
else: %32
part: %32
of: %32
an: %32
if
-
else: %32
is: %32
optional
,
there: %32
is: %32
an: %32
ambiguity: %32
when: %32
an: %32
else: %32
if: %32
omitted: %32
from: %32
a: %13
nested: %32
if: %32
sequence
.: %32
This: %32
is: %32
resolved: %32
by: %32
associating: %32
the: %32
else: %32
with: %32
the: %32
closest: %32
previous: %32
else
-
less: %32
if
.: %13
For: %32
example
,: %32
in: %13
if: %32
(
n: %32
>: %32
0
): %13
if: %32
(
a: %32
>: %32
b
): %13
z: %32
=: %32
a
;: %13
else: %13
z: %32
=: %32
b
;: %13
the: %32
else: %32
goes: %32
to: %32
the: %32
inner: %32
if
,: %32
as: %32
we: %32
have: %32
shown: %32
by: %32
indentation
.: %32
If: %32
that: %32
isn
'
t: %32
what: %32
you: %32
want
,: %32
braces: %32
must: %13
be: %32
used: %32
to: %32
force: %32
the: %32
proper: %32
association
:: %13
if: %32
(
n: %32
>: %32
0
): %32
{: %13
if: %32
(
a: %32
>: %32
b
): %13
z: %32
=: %32
a
;: %13
}: %13
else: %13
z: %32
=: %32
b
;: %13
The: %32
ambiguity: %32
is: %32
especially: %32
pernicious: %32
in: %32
situations: %32
like: %32
this
:: %13
if: %32
(
n: %32
>: %32
0
): %13
for: %32
(
i: %32
=: %32
0
;: %32
i: %32
<: %32
n
;: %32
i
+
+
): %13
if: %32
(
s
[
i
]: %32
>: %32
0
): %32
{: %13
printf
(
"
.
.
.
"
)
;: %13
Chapter: %32
3: %32
-: %32
Control: %32
Flow: %13
return: %32
i
;: %13
}: %13
else: %13
/
*: %32
WRONG: %32
*
/: %13
printf
(
"
error: %32
-
-: %32
n: %32
is: %32
negative
\
n
"
)
;: %13
The: %32
indentation: %32
shows: %32
unequivocally: %32
what: %32
you: %32
want
,: %32
but: %32
the: %32
compiler: %32
doesn
'
t: %32
get: %32
the: %32
message
,: %32
and: %13
associates: %32
the: %32
else: %32
with: %32
the: %32
inner: %32
if
.: %32
This: %32
kind: %32
of: %32
bug: %32
can: %32
be: %32
hard: %32
to: %32
find
;: %32
it
'
s: %32
a: %32
good: %32
idea: %32
to: %32
use: %32
braces: %13
when: %32
there: %32
are: %32
nested: %32
ifs
.: %13
By: %32
the: %32
way
,: %32
notice: %32
that: %32
there: %32
is: %32
a: %32
semicolon: %32
after: %32
z: %32
=: %32
a: %32
in: %13
if: %32
(
a: %32
>: %32
b
): %13
z: %32
=: %32
a
;: %13
else: %13
z: %32
=: %32
b
;: %13
This: %32
is: %32
because: %32
grammatically
,: %32
a: %32
statement: %32
follows: %32
the: %32
if
,: %32
and: %32
an: %32
expression: %32
statement: %32
like: %32
`
`
z: %32
=: %32
a
;
'
': %13
is: %32
always: %32
terminated: %32
by: %32
a: %32
semicolon
.: %13
3
.
3: %32
Else
-
If: %13
The: %32
construction: %13
if: %32
(
expression
): %13
statement: %13
else: %32
if: %32
(
expression
): %13
statement: %13
else: %32
if: %32
(
expression
): %13
statement: %13
else: %32
if: %32
(
expression
): %13
statement: %13
else: %13
statement: %13
occurs: %32
so: %32
often: %32
that: %32
it: %32
is: %32
worth: %32
a: %32
brief: %32
separate: %32
discussion
.: %32
This: %32
sequence: %32
of: %32
if: %32
statements: %32
is: %32
the: %32
most: %13
general: %32
way: %32
of: %32
writing: %32
a: %32
multi
-
way: %32
decision
.: %32
The: %32
expressions: %32
are: %32
evaluated: %32
in: %32
order
;: %32
if: %32
an: %32
expression: %32
is: %13
true
,: %32
the: %32
statement: %32
associated: %32
with: %32
it: %32
is: %32
executed
,: %32
and: %32
this: %32
terminates: %32
the: %32
whole: %32
chain
.: %32
As: %32
always
,: %32
the: %13
code: %32
for: %32
each: %32
statement: %32
is: %32
either: %32
a: %32
single: %32
statement
,: %32
or: %32
a: %32
group: %32
of: %32
them: %32
in: %32
braces
.: %13
The: %32
last: %32
else: %32
part: %32
handles: %32
the: %32
`
`
none: %32
of: %32
the: %32
above
'
': %32
or: %32
default: %32
case: %32
where: %32
none: %32
of: %32
the: %32
other: %32
conditions: %32
is: %13
satisfied
.: %32
Sometimes: %32
there: %32
is: %32
no: %32
explicit: %32
action: %32
for: %32
the: %32
default
;: %32
in: %32
that: %32
case: %32
the: %32
trailing: %13
Chapter: %32
3: %32
-: %32
Control: %32
Flow: %13
else: %13
statement: %13
can: %32
be: %32
omitted
,: %32
or: %32
it: %32
may: %32
be: %32
used: %32
for: %32
error: %32
checking: %32
to: %32
catch: %32
an: %32
`
`
impossible
'
': %32
condition
.: %13
To: %32
illustrate: %32
a: %32
three
-
way: %32
decision
,: %32
here: %32
is: %32
a: %32
binary: %32
search: %32
function: %32
that: %32
decides: %32
if: %32
a: %32
particular: %32
value: %32
x: %13
occurs: %32
in: %32
the: %32
sorted: %32
array: %32
v
.: %32
The: %32
elements: %32
of: %32
v: %32
must: %32
be: %32
in: %32
increasing: %32
order
.: %32
The: %32
function: %32
returns: %32
the: %13
position: %32
(
a: %32
number: %32
between: %32
0: %32
and: %32
n
-
1
): %32
if: %32
x: %32
occurs: %32
in: %32
v
,: %32
and: %32
-
1: %32
if: %32
not
.: %13
Binary: %32
search: %32
first: %32
compares: %32
the: %32
input: %32
value: %32
x: %32
to: %32
the: %32
middle: %32
element: %32
of: %32
the: %32
array: %32
v
.: %32
If: %32
x: %32
is: %32
less: %32
than: %32
the: %13
middle: %32
value
,: %32
searching: %32
focuses: %32
on: %32
the: %32
lower: %32
half: %32
of: %32
the: %32
table
,: %32
otherwise: %32
on: %32
the: %32
upper: %32
half
.: %32
In: %32
either: %32
case
,: %13
the: %32
next: %32
step: %32
is: %32
to: %32
compare: %32
x: %32
to: %32
the: %32
middle: %32
element: %32
of: %32
the: %32
selected: %32
half
.: %32
This: %32
process: %32
of: %32
dividing: %32
the: %13
range: %32
in: %32
two: %32
continues: %32
until: %32
the: %32
value: %32
is: %32
found: %32
or: %32
the: %32
range: %32
is: %32
empty
.: %13
/
*: %32
binsearch
:: %32
find: %32
x: %32
in: %32
v
[
0
]: %32
<
=: %32
v
[
1
]: %32
<
=: %32
.
.
.: %32
<
=: %32
v
[
n
-
1
]: %32
*
/: %13
int: %32
binsearch
(
int: %32
x
,: %32
int: %32
v
[
]
,: %32
int: %32
n
): %13
{: %13
int: %32
low
,: %32
high
,: %32
mid
;: %13
low: %32
=: %32
0
;: %13
high: %32
=: %32
n: %32
-: %32
1
;: %13
while: %32
(
low: %32
<
=: %32
high
): %32
{: %13
mid: %32
=: %32
(
low
+
high
)
/
2
;: %13
if: %32
(
x: %32
<: %32
v
[
mid
]
): %13
high: %32
=: %32
mid: %32
+: %32
1
;: %13
else: %32
if: %32
(
x: %32
>: %32
v
[
mid
]
): %13
low: %32
=: %32
mid: %32
+: %32
1
;: %13
else: %13
/
*: %32
found: %32
match: %32
*
/: %13
return: %32
mid
;: %13
}: %13
return: %32
-
1
;: %13
/
*: %32
no: %32
match: %32
*
/: %13
}: %13
The: %32
fundamental: %32
decision: %32
is: %32
whether: %32
x: %32
is: %32
less: %32
than
,: %32
greater: %32
than
,: %32
or: %32
equal: %32
to: %32
the: %32
middle: %32
element: %32
v
[
mid
]: %13
at: %32
each: %32
step
;: %32
this: %32
is: %32
a: %32
natural: %32
for: %32
else
-
if
.: %13
Exercise: %32
3
-
1
.: %32
Our: %32
binary: %32
search: %32
makes: %32
two: %32
tests: %32
inside: %32
the: %32
loop
,: %32
when: %32
one: %32
would: %32
suffice: %32
(
at: %32
the: %32
price: %32
of: %13
more: %32
tests: %32
outside
.
): %32
Write: %32
a: %32
version: %32
with: %32
only: %32
one: %32
test: %32
inside: %32
the: %32
loop: %32
and: %32
measure: %32
the: %32
difference: %32
in: %32
run
-: %13
time
.: %13
3
.
4: %32
Switch: %13
Chapter: %32
3: %32
-: %32
Control: %32
Flow: %13
The: %32
switch: %32
statement: %32
is: %32
a: %32
multi
-
way: %32
decision: %32
that: %32
tests: %32
whether: %32
an: %32
expression: %32
matches: %32
one: %32
of: %32
a: %13
number: %32
of: %32
constant: %32
integer: %32
values
,: %32
and: %32
branches: %32
accordingly
.: %13
switch: %32
(
expression
): %32
{: %13
case: %32
const
-
expr
:: %32
statements: %13
case: %32
const
-
expr
:: %32
statements: %13
default
:: %32
statements: %13
}: %13
Each: %32
case: %32
is: %32
labeled: %32
by: %32
one: %32
or: %32
more: %32
integer
-
valued: %32
constants: %32
or: %32
constant: %32
expressions
.: %32
If: %32
a: %32
case: %32
matches: %13
the: %32
expression: %32
value
,: %32
execution: %32
starts: %32
at: %32
that: %32
case
.: %32
All: %32
case: %32
expressions: %32
must: %32
be: %32
different
.: %32
The: %32
case: %13
labeled: %32
default: %32
is: %32
executed: %32
if: %32
none: %32
of: %32
the: %32
other: %32
cases: %32
are: %32
satisfied
.: %32
A: %32
default: %32
is: %32
optional
;: %32
if: %32
it: %32
isn
'
t: %13
there: %32
and: %32
if: %32
none: %32
of: %32
the: %32
cases: %32
match
,: %32
no: %32
action: %32
at: %32
all: %32
takes: %32
place
.: %32
Cases: %32
and: %32
the: %32
default: %32
clause: %32
can: %32
occur: %13
in: %32
any: %32
order
.: %13
In: %32
Chapter: %32
1: %32
we: %32
wrote: %32
a: %32
program: %32
to: %32
count: %32
the: %32
occurrences: %32
of: %32
each: %32
digit
,: %32
white: %32
space
,: %32
and: %32
all: %32
other: %13
characters
,: %32
using: %32
a: %32
sequence: %32
of: %32
if: %32
.
.
.: %32
else: %32
if: %32
.
.
.: %32
else
.: %32
Here: %32
is: %32
the: %32
same: %32
program: %32
with: %32
a: %13
switch
:: %13
#
include: %32
<
stdio
.
h
>: %13
main
(
): %32
/
*: %32
count: %32
digits
,: %32
white: %32
space
,: %32
others: %32
*
/: %13
{: %13
int: %32
c
,: %32
i
,: %32
nwhite
,: %32
nother
,: %32
ndigit
[
1
0
]
;: %13
nwhite: %32
=: %32
nother: %32
=: %32
0
;: %13
for: %32
(
i: %32
=: %32
0
;: %32
i: %32
<: %32
1
0
;: %32
i
+
+
): %13
ndigit
[
i
]: %32
=: %32
0
;: %13
while: %32
(
(
c: %32
=: %32
getchar
(
)
): %32
!
=: %32
EOF
): %32
{: %13
switch: %32
(
c
): %32
{: %13
case: %32
'
0
'
:: %32
case: %32
'
1
'
:: %32
case: %32
'
2
'
:: %32
case: %32
'
3
'
:: %32
case: %32
'
4
'
:: %13
case: %32
'
5
'
:: %32
case: %32
'
6
'
:: %32
case: %32
'
7
'
:: %32
case: %32
'
8
'
:: %32
case: %32
'
9
'
:: %13
ndigit
[
c
-
'
0
'
]
+
+
;: %13
break
;: %13
case: %32
': %32
'
:: %13
case: %32
'
\
n
'
:: %13
case: %32
'
\
t
'
:: %13
nwhite
+
+
;: %13
break
;: %13
default
:: %13
nother
+
+
;: %13
break
;: %13
Chapter: %32
3: %32
-: %32
Control: %32
Flow: %13
}: %13
}: %13
printf
(
"
digits: %32
=
"
)
;: %13
for: %32
(
i: %32
=: %32
0
;: %32
i: %32
<: %32
1
0
;: %32
i
+
+
): %13
printf
(
": %32
%:
d
"
,: %32
ndigit
[
i
]
)
;: %13
printf
(
"
,: %32
white: %32
space: %32
=: %32
%:
d
,: %32
other: %32
=: %32
%:
d
\
n
"
,: %13
nwhite
,: %32
nother
)
;: %13
return: %32
0
;: %13
}: %13
The: %32
break: %32
statement: %32
causes: %32
an: %32
immediate: %32
exit: %32
from: %32
the: %32
switch
.: %32
Because: %32
cases: %32
serve: %32
just: %32
as: %32
labels
,: %13
after: %32
the: %32
code: %32
for: %32
one: %32
case: %32
is: %32
done
,: %32
execution: %32
falls: %32
through: %32
to: %32
the: %32
next: %32
unless: %32
you: %32
take: %32
explicit: %32
action: %32
to: %13
escape
.: %32
break: %32
and: %32
return: %32
are: %32
the: %32
most: %32
common: %32
ways: %32
to: %32
leave: %32
a: %32
switch
.: %32
A: %32
break: %32
statement: %32
can: %13
also: %32
be: %32
used: %32
to: %32
force: %32
an: %32
immediate: %32
exit: %32
from: %32
while
,: %32
for
,: %32
and: %32
do: %32
loops
,: %32
as: %32
will: %32
be: %32
discussed: %32
later: %32
in: %13
this: %32
chapter
.: %13
Falling: %32
through: %32
cases: %32
is: %32
a: %32
mixed: %32
blessing
.: %32
On: %32
the: %32
positive: %32
side
,: %32
it: %32
allows: %32
several: %32
cases: %32
to: %32
be: %32
attached: %32
to: %32
a: %13
single: %32
action
,: %32
as: %32
with: %32
the: %32
digits: %32
in: %32
this: %32
example
.: %32
But: %32
it: %32
also: %32
implies: %32
that: %32
normally: %32
each: %32
case: %32
must: %32
end: %32
with: %13
a: %32
break: %32
to: %32
prevent: %32
falling: %32
through: %32
to: %32
the: %32
next
.: %32
Falling: %32
through: %32
from: %32
one: %32
case: %32
to: %32
another: %32
is: %32
not: %32
robust
,: %13
being: %32
prone: %32
to: %32
disintegration: %32
when: %32
the: %32
program: %32
is: %32
modified
.: %32
With: %32
the: %32
exception: %32
of: %32
multiple: %32
labels: %32
for: %32
a: %13
single: %32
computation
,: %32
fall
-
throughs: %32
should: %32
be: %32
used: %32
sparingly
,: %32
and: %32
commented
.: %13
As: %32
a: %32
matter: %32
of: %32
good: %32
form
,: %32
put: %32
a: %32
break: %32
after: %32
the: %32
last: %32
case: %32
(
the: %32
default: %32
here
): %32
even: %32
though: %32
it
'
s: %32
logically: %13
unnecessary
.: %32
Some: %32
day: %32
when: %32
another: %32
case: %32
gets: %32
added: %32
at: %32
the: %32
end
,: %32
this: %32
bit: %32
of: %32
defensive: %32
programming: %32
will: %13
save: %32
you
.: %13
Exercise: %32
3
-
2
.: %32
Write: %32
a: %32
function: %32
escape
(
s
,
t
): %32
that: %32
converts: %32
characters: %32
like: %32
newline: %32
and: %32
tab: %32
into: %32
visible: %13
escape: %32
sequences: %32
like: %32
\
n: %32
and: %32
\
t: %32
as: %32
it: %32
copies: %32
the: %32
string: %32
t: %32
to: %32
s
.: %32
Use: %32
a: %32
switch
.: %32
Write: %32
a: %32
function: %32
for: %32
the: %13
other: %32
direction: %32
as: %32
well
,: %32
converting: %32
escape: %32
sequences: %32
into: %32
the: %32
real: %32
characters
.: %13
3
.
5: %32
Loops: %32
-: %32
While: %32
and: %32
For: %13
We: %32
have: %32
already: %32
encountered: %32
the: %32
while: %32
and: %32
for: %32
loops
.: %32
In: %13
while: %32
(
expression
): %13
statement: %13
the: %32
expression: %32
is: %32
evaluated
.: %32
If: %32
it: %32
is: %32
non
-
zero
,: %32
statement: %32
is: %32
executed: %32
and: %32
expression: %32
is: %32
re
-
evaluated
.: %32
This: %13
cycle: %32
continues: %32
until: %32
expression: %32
becomes: %32
zero
,: %32
at: %32
which: %32
point: %32
execution: %32
resumes: %32
after: %32
statement
.: %13
The: %32
for: %32
statement: %13
Chapter: %32
3: %32
-: %32
Control: %32
Flow: %13
for: %32
(
expr
1
;: %32
expr
2
;: %32
expr
3
): %13
statement: %13
is: %32
equivalent: %32
to: %13
expr
1
;: %13
while: %32
(
expr
2
): %32
{: %13
statement: %13
expr
3
;: %13
}: %13
except: %32
for: %32
the: %32
behaviour: %32
of: %32
continue
,: %32
which: %32
is: %32
described: %32
in: %32
Section: %32
3
.
7
.: %13
Grammatically
,: %32
the: %32
three: %32
components: %32
of: %32
a: %32
for: %32
loop: %32
are: %32
expressions
.: %32
Most: %32
commonly
,: %32
expr
1: %32
and: %32
expr
3: %13
are: %32
assignments: %32
or: %32
function: %32
calls: %32
and: %32
expr
2: %32
is: %32
a: %32
relational: %32
expression
.: %32
Any: %32
of: %32
the: %32
three: %32
parts: %32
can: %32
be: %13
omitted
,: %32
although: %32
the: %32
semicolons: %32
must: %32
remain
.: %32
If: %32
expr
1: %32
or: %32
expr
3: %32
is: %32
omitted
,: %32
it: %32
is: %32
simply: %32
dropped: %32
from: %32
the: %13
expansion
.: %32
If: %32
the: %32
test
,: %32
expr
2
,: %32
is: %32
not: %32
present
,: %32
it: %32
is: %32
taken: %32
as: %32
permanently: %32
true
,: %32
so: %13
for: %32
(
;
;
): %32
{: %13
.
.
.: %13
}: %13
is: %32
an: %32
`
`
infinite
'
': %32
loop
,: %32
presumably: %32
to: %32
be: %32
broken: %32
by: %32
other: %32
means
,: %32
such: %32
as: %32
a: %32
break: %32
or: %32
return
.: %13
Whether: %32
to: %32
use: %32
while: %32
or: %32
for: %32
is: %32
largely: %32
a: %32
matter: %32
of: %32
personal: %32
preference
.: %32
For: %32
example
,: %32
in: %13
while: %32
(
(
c: %32
=: %32
getchar
(
)
): %32
=
=: %32
': %32
': %32
|
|: %32
c: %32
=
=: %32
'
\
n
': %32
|
|: %32
c: %32
=: %32
'
\
t
'
): %13
;: %13
/
*: %32
skip: %32
white: %32
space: %32
characters: %32
*
/: %13
there: %32
is: %32
no: %32
initialization: %32
or: %32
re
-
initialization
,: %32
so: %32
the: %32
while: %32
is: %32
most: %32
natural
.: %13
The: %32
for: %32
is: %32
preferable: %32
when: %32
there: %32
is: %32
a: %32
simple: %32
initialization: %32
and: %32
increment: %32
since: %32
it: %32
keeps: %32
the: %32
loop: %32
control: %13
statements: %32
close: %32
together: %32
and: %32
visible: %32
at: %32
the: %32
top: %32
of: %32
the: %32
loop
.: %32
This: %32
is: %32
most: %32
obvious: %32
in: %13
for: %32
(
i: %32
=: %32
0
;: %32
i: %32
<: %32
n
;: %32
i
+
+
): %13
.
.
.: %13
which: %32
is: %32
the: %32
C: %32
idiom: %32
for: %32
processing: %32
the: %32
first: %32
n: %32
elements: %32
of: %32
an: %32
array
,: %32
the: %32
analog: %32
of: %32
the: %32
Fortran: %32
DO: %32
loop: %32
or: %13
the: %32
Pascal: %32
for
.: %32
The: %32
analogy: %32
is: %32
not: %32
perfect
,: %32
however
,: %32
since: %32
the: %32
index: %32
variable: %32
i: %32
retains: %32
its: %32
value: %32
when: %32
the: %13
Chapter: %32
3: %32
-: %32
Control: %32
Flow: %13
loop: %32
terminates: %32
for: %32
any: %32
reason
.: %32
Because: %32
the: %32
components: %32
of: %32
the: %32
for: %32
are: %32
arbitrary: %32
expressions
,: %32
for: %32
loops: %13
are: %32
not: %32
restricted: %32
to: %32
arithmetic: %32
progressions
.: %32
Nonetheless
,: %32
it: %32
is: %32
bad: %32
style: %32
to: %32
force: %32
unrelated: %32
computations: %13
into: %32
the: %32
initialization: %32
and: %32
increment: %32
of: %32
a: %32
for
,: %32
which: %32
are: %32
better: %32
reserved: %32
for: %32
loop: %32
control: %32
operations
.: %13
As: %32
a: %32
larger: %32
example
,: %32
here: %32
is: %32
another: %32
version: %32
of: %32
atoi: %32
for: %32
converting: %32
a: %32
string: %32
to: %32
its: %32
numeric: %32
equivalent
.: %13
This: %32
one: %32
is: %32
slightly: %32
more: %32
general: %32
than: %32
the: %32
one: %32
in: %32
Chapter: %32
2
;: %32
it: %32
copes: %32
with: %32
optional: %32
leading: %32
white: %32
space: %13
and: %32
an: %32
optional: %32
+: %32
or: %32
-: %32
sign
.: %32
(
Chapter: %32
4: %32
shows: %32
atof
,: %32
which: %32
does: %32
the: %32
same: %32
conversion: %32
for: %32
floating
-
point: %13
numbers
.
): %13
The: %32
structure: %32
of: %32
the: %32
program: %32
reflects: %32
the: %32
form: %32
of: %32
the: %32
input
:: %13
skip: %32
white: %32
space
,: %32
if: %32
any: %13
get: %32
sign
,: %32
if: %32
any: %13
get: %32
integer: %32
part: %32
and: %32
convert: %32
it: %13
Each: %32
step: %32
does: %32
its: %32
part
,: %32
and: %32
leaves: %32
things: %32
in: %32
a: %32
clean: %32
state: %32
for: %32
the: %32
next
.: %32
The: %32
whole: %32
process: %32
terminates: %32
on: %13
the: %32
first: %32
character: %32
that: %32
could: %32
not: %32
be: %32
part: %32
of: %32
a: %32
number
.: %13
#
include: %32
<
ctype
.
h
>: %13
/
*: %32
atoi
:: %32
convert: %32
s: %32
to: %32
integer
;: %32
version: %32
2: %32
*
/: %13
int: %32
atoi
(
char: %32
s
[
]
): %13
{: %13
int: %32
i
,: %32
n
,: %32
sign
;: %13
for: %32
(
i: %32
=: %32
0
;: %32
isspace
(
s
[
i
]
)
;: %32
i
+
+
): %13
;: %13
sign: %32
=: %32
(
s
[
i
]: %32
=
=: %32
'
-
'
): %32
?: %32
-
1: %32
:: %32
1
;: %13
if: %32
(
s
[
i
]: %32
=
=: %32
'
+
': %32
|
|: %32
s
[
i
]: %32
=
=: %32
'
-
'
): %13
i
+
+
;: %13
for: %32
(
n: %32
=: %32
0
;: %32
isdigit
(
s
[
i
]
)
;: %32
i
+
+
): %13
n: %32
=: %32
1
0: %32
*: %32
n: %32
+: %32
(
s
[
i
]: %32
-: %32
'
0
'
)
;: %13
return: %32
sign: %32
*: %32
n
;: %13
/
*: %32
skip: %32
white: %32
space: %32
*
/: %13
/
*: %32
skip: %32
sign: %32
*
/: %13
}: %13
The: %32
standard: %32
library: %32
provides: %32
a: %32
more: %32
elaborate: %32
function: %32
strtol: %32
for: %32
conversion: %32
of: %32
strings: %32
to: %32
long: %13
integers
;: %32
see: %32
Section: %32
5: %32
of: %32
Appendix: %32
B
.: %13
The: %32
advantages: %32
of: %32
keeping: %32
loop: %32
control: %32
centralized: %32
are: %32
even: %32
more: %32
obvious: %32
when: %32
there: %32
are: %32
several: %32
nested: %13
loops
.: %32
The: %32
following: %32
function: %32
is: %32
a: %32
Shell: %32
sort: %32
for: %32
sorting: %32
an: %32
array: %32
of: %32
integers
.: %32
The: %32
basic: %32
idea: %32
of: %32
this: %32
sorting: %13
algorithm
,: %32
which: %32
was: %32
invented: %32
in: %32
1
9
5
9: %32
by: %32
D
.: %32
L
.: %32
Shell
,: %32
is: %32
that: %32
in: %32
early: %32
stages
,: %32
far
-
apart: %32
elements: %32
are: %13
compared
,: %32
rather: %32
than: %32
adjacent: %32
ones: %32
as: %32
in: %32
simpler: %32
interchange: %32
sorts
.: %32
This: %32
tends: %32
to: %32
eliminate: %32
large: %13
Chapter: %32
3: %32
-: %32
Control: %32
Flow: %13
amounts: %32
of: %32
disorder: %32
quickly
,: %32
so: %32
later: %32
stages: %32
have: %32
less: %32
work: %32
to: %32
do
.: %32
The: %32
interval: %32
between: %32
compared: %13
elements: %32
is: %32
gradually: %32
decreased: %32
to: %32
one
,: %32
at: %32
which: %32
point: %32
the: %32
sort: %32
effectively: %32
becomes: %32
an: %32
adjacent: %13
interchange: %32
method
.: %13
/
*: %32
shellsort
:: %32
sort: %32
v
[
0
]
.
.
.
v
[
n
-
1
]: %32
into: %32
increasing: %32
order: %32
*
/: %13
void: %32
shellsort
(
int: %32
v
[
]
,: %32
int: %32
n
): %13
{: %13
int: %32
gap
,: %32
i
,: %32
j
,: %32
temp
;: %13
for: %32
(
gap: %32
=: %32
n
/
2
;: %32
gap: %32
>: %32
0
;: %32
gap: %32
/
=: %32
2
): %13
for: %32
(
i: %32
=: %32
gap
;: %32
i: %32
<: %32
n
;: %32
i
+
+
): %13
for: %32
(
j
=
i
-
gap
;: %32
j
>
=
0: %32
&
&: %32
v
[
j
]
>
v
[
j
+
gap
]
;: %32
j
-
=
gap
): %32
{: %13
temp: %32
=: %32
v
[
j
]
;: %13
v
[
j
]: %32
=: %32
v
[
j
+
gap
]
;: %13
v
[
j
+
gap
]: %32
=: %32
temp
;: %13
}: %13
}: %13
There: %32
are: %32
three: %32
nested: %32
loops
.: %32
The: %32
outermost: %32
controls: %32
the: %32
gap: %32
between: %32
compared: %32
elements
,: %32
shrinking: %32
it: %13
from: %32
n
/
2: %32
by: %32
a: %32
factor: %32
of: %32
two: %32
each: %32
pass: %32
until: %32
it: %32
becomes: %32
zero
.: %32
The: %32
middle: %32
loop: %32
steps: %32
along: %32
the: %32
elements
.: %13
The: %32
innermost: %32
loop: %32
compares: %32
each: %32
pair: %32
of: %32
elements: %32
that: %32
is: %32
separated: %32
by: %32
gap: %32
and: %32
reverses: %32
any: %32
that: %32
are: %13
out: %32
of: %32
order
.: %32
Since: %32
gap: %32
is: %32
eventually: %32
reduced: %32
to: %32
one
,: %32
all: %32
elements: %32
are: %32
eventually: %32
ordered: %32
correctly
.: %13
Notice: %32
how: %32
the: %32
generality: %32
of: %32
the: %32
for: %32
makes: %32
the: %32
outer: %32
loop: %32
fit: %32
in: %32
the: %32
same: %32
form: %32
as: %32
the: %32
others
,: %32
even: %13
though: %32
it: %32
is: %32
not: %32
an: %32
arithmetic: %32
progression
.: %13
One: %32
final: %32
C: %32
operator: %32
is: %32
the: %32
comma: %32
`
`
,
'
'
,: %32
which: %32
most: %32
often: %32
finds: %32
use: %32
in: %32
the: %32
for: %32
statement
.: %32
A: %32
pair: %32
of: %13
expressions: %32
separated: %32
by: %32
a: %32
comma: %32
is: %32
evaluated: %32
left: %32
to: %32
right
,: %32
and: %32
the: %32
type: %32
and: %32
value: %32
of: %32
the: %32
result: %32
are: %32
the: %13
type: %32
and: %32
value: %32
of: %32
the: %32
right: %32
operand
.: %32
Thus: %32
in: %32
a: %32
for: %32
statement
,: %32
it: %32
is: %32
possible: %32
to: %32
place: %32
multiple: %32
expressions: %32
in: %13
the: %32
various: %32
parts
,: %32
for: %32
example: %32
to: %32
process: %32
two: %32
indices: %32
in: %32
parallel
.: %32
This: %32
is: %32
illustrated: %32
in: %32
the: %32
function: %13
reverse
(
s
)
,: %32
which: %32
reverses: %32
the: %32
string: %32
s: %32
in: %32
place
.: %13
#
include: %32
<
string
.
h
>: %13
/
*: %32
reverse
:: %32
reverse: %32
string: %32
s: %32
in: %32
place: %32
*
/: %13
void: %32
reverse
(
char: %32
s
[
]
): %13
{: %13
int: %32
c
,: %32
i
,: %32
j
;: %13
for: %32
(
i: %32
=: %32
0
,: %32
j: %32
=: %32
strlen
(
s
)
-
1
;: %32
i: %32
<: %32
j
;: %32
i
+
+
,: %32
j
-
-
): %32
{: %13
c: %32
=: %32
s
[
i
]
;: %13
s
[
i
]: %32
=: %32
s
[
j
]
;: %13
s
[
j
]: %32
=: %32
c
;: %13
}: %13
Chapter: %32
3: %32
-: %32
Control: %32
Flow: %13
}: %13
The: %32
commas: %32
that: %32
separate: %32
function: %32
arguments
,: %32
variables: %32
in: %32
declarations
,: %32
etc
.
,: %32
are: %32
not: %32
comma: %32
operators
,: %13
and: %32
do: %32
not: %32
guarantee: %32
left: %32
to: %32
right: %32
evaluation
.: %13
Comma: %32
operators: %32
should: %32
be: %32
used: %32
sparingly
.: %32
The: %32
most: %32
suitable: %32
uses: %32
are: %32
for: %32
constructs: %32
strongly: %32
related: %32
to: %13
each: %32
other
,: %32
as: %32
in: %32
the: %32
for: %32
loop: %32
in: %32
reverse
,: %32
and: %32
in: %32
macros: %32
where: %32
a: %32
multistep: %32
computation: %32
has: %32
to: %32
be: %32
a: %13
single: %32
expression
.: %32
A: %32
comma: %32
expression: %32
might: %32
also: %32
be: %32
appropriate: %32
for: %32
the: %32
exchange: %32
of: %32
elements: %32
in: %13
reverse
,: %32
where: %32
the: %32
exchange: %32
can: %32
be: %32
thought: %32
of: %32
a: %32
single: %32
operation
:: %13
for: %32
(
i: %32
=: %32
0
,: %32
j: %32
=: %32
strlen
(
s
)
-
1
;: %32
i: %32
<: %32
j
;: %32
i
+
+
,: %32
j
-
-
): %13
c: %32
=: %32
s
[
i
]
,: %32
s
[
i
]: %32
=: %32
s
[
j
]
,: %32
s
[
j
]: %32
=: %32
c
;: %13
Exercise: %32
3
-
3
.: %32
Write: %32
a: %32
function: %32
expand
(
s
1
,
s
2
): %32
that: %32
expands: %32
shorthand: %32
notations: %32
like: %32
a
-
z: %32
in: %32
the: %13
string: %32
s
1: %32
into: %32
the: %32
equivalent: %32
complete: %32
list: %32
abc
.
.
.
xyz: %32
in: %32
s
2
.: %32
Allow: %32
for: %32
letters: %32
of: %32
either: %32
case: %32
and: %32
digits
,: %13
and: %32
be: %32
prepared: %32
to: %32
handle: %32
cases: %32
like: %32
a
-
b
-
c: %32
and: %32
a
-
z
0
-
9: %32
and: %32
-
a
-
z
.: %32
Arrange: %32
that: %32
a: %32
leading: %32
or: %32
trailing: %32
-: %13
is: %32
taken: %32
literally
.: %13
3
.
6: %32
Loops: %32
-: %32
Do
-
While: %13
As: %32
we: %32
discussed: %32
in: %32
Chapter: %32
1
,: %32
the: %32
while: %32
and: %32
for: %32
loops: %32
test: %32
the: %32
termination: %32
condition: %32
at: %32
the: %32
top
.: %32
By: %13
contrast
,: %32
the: %32
third: %32
loop: %32
in: %32
C
,: %32
the: %32
do
-
while
,: %32
tests: %32
at: %32
the: %32
bottom: %32
after: %32
making: %32
each: %32
pass: %32
through: %32
the: %32
loop: %13
body
;: %32
the: %32
body: %32
is: %32
always: %32
executed: %32
at: %32
least: %32
once
.: %13
The: %32
syntax: %32
of: %32
the: %32
do: %32
is: %13
do: %13
statement: %13
while: %32
(
expression
)
;: %13
The: %32
statement: %32
is: %32
executed
,: %32
then: %32
expression: %32
is: %32
evaluated
.: %32
If: %32
it: %32
is: %32
true
,: %32
statement: %32
is: %32
evaluated: %32
again
,: %32
and: %32
so: %13
on
.: %32
When: %32
the: %32
expression: %32
becomes: %32
false
,: %32
the: %32
loop: %32
terminates
.: %32
Except: %32
for: %32
the: %32
sense: %32
of: %32
the: %32
test
,: %32
do
-
while: %13
is: %32
equivalent: %32
to: %32
the: %32
Pascal: %32
repeat
-
until: %32
statement
.: %13
Experience: %32
shows: %32
that: %32
do
-
while: %32
is: %32
much: %32
less: %32
used: %32
than: %32
while: %32
and: %32
for
.: %32
Nonetheless
,: %32
from: %32
time: %32
to: %13
time: %32
it: %32
is: %32
valuable
,: %32
as: %32
in: %32
the: %32
following: %32
function: %32
itoa
,: %32
which: %32
converts: %32
a: %32
number: %32
to: %32
a: %32
character: %32
string: %32
(
the: %13
inverse: %32
of: %32
atoi
)
.: %32
The: %32
job: %32
is: %32
slightly: %32
more: %32
complicated: %32
than: %32
might: %32
be: %32
thought: %32
at: %32
first
,: %32
because: %32
the: %32
easy: %13
methods: %32
of: %32
generating: %32
the: %32
digits: %32
generate: %32
them: %32
in: %32
the: %32
wrong: %32
order
.: %32
We: %32
have: %32
chosen: %32
to: %32
generate: %32
the: %32
string: %13
backwards
,: %32
then: %32
reverse: %32
it
.: %13
/
*: %32
itoa
:: %13
convert: %32
n: %32
to: %32
characters: %32
in: %32
s: %32
*
/: %13
Chapter: %32
3: %32
-: %32
Control: %32
Flow: %13
void: %32
itoa
(
int: %32
n
,: %32
char: %32
s
[
]
): %13
{: %13
int: %32
i
,: %32
sign
;: %13
if: %32
(
(
sign: %32
=: %32
n
): %32
<: %32
0
): %32
/
*: %32
record: %32
sign: %32
*
/: %13
n: %32
=: %32
-
n
;: %13
/
*: %32
make: %32
n: %32
positive: %32
*
/: %13
i: %32
=: %32
0
;: %13
do: %32
{: %13
/
*: %32
generate: %32
digits: %32
in: %32
reverse: %32
order: %32
*
/: %13
s
[
i
+
+
]: %32
=: %32
n: %32
%: %32
1
0: %32
+: %32
'
0
'
;: %32
/
*: %32
get: %32
next: %32
digit: %32
*
/: %13
}: %32
while: %32
(
(
n: %32
/
=: %32
1
0
): %32
>: %32
0
)
;: %13
/
*: %32
delete: %32
it: %32
*
/: %13
if: %32
(
sign: %32
<: %32
0
): %13
s
[
i
+
+
]: %32
=: %32
'
-
'
;: %13
s
[
i
]: %32
=: %32
'
\
0
'
;: %13
reverse
(
s
)
;: %13
}: %13
The: %32
do
-
while: %32
is: %32
necessary
,: %32
or: %32
at: %32
least: %32
convenient
,: %32
since: %32
at: %32
least: %32
one: %32
character: %32
must: %32
be: %32
installed: %32
in: %32
the: %13
array: %32
s
,: %32
even: %32
if: %32
n: %32
is: %32
zero
.: %32
We: %32
also: %32
used: %32
braces: %32
around: %32
the: %32
single: %32
statement: %32
that: %32
makes: %32
up: %32
the: %32
body: %32
of: %32
the: %13
do
-
while
,: %32
even: %32
though: %32
they: %32
are: %32
unnecessary
,: %32
so: %32
the: %32
hasty: %32
reader: %32
will: %32
not: %32
mistake: %32
the: %32
while: %32
part: %32
for: %13
the: %32
beginning: %32
of: %32
a: %32
while: %32
loop
.: %13
Exercise: %32
3
-
4
.: %32
In: %32
a: %32
two
'
s: %32
complement: %32
number: %32
representation
,: %32
our: %32
version: %32
of: %32
itoa: %32
does: %32
not: %32
handle: %32
the: %13
largest: %32
negative: %32
number
,: %32
that: %32
is
,: %32
the: %32
value: %32
of: %32
n: %32
equal: %32
to: %32
-
(
2
wordsize
-
1
)
.: %32
Explain: %32
why: %32
not
.: %32
Modify: %32
it: %32
to: %32
print: %13
that: %32
value: %32
correctly
,: %32
regardless: %32
of: %32
the: %32
machine: %32
on: %32
which: %32
it: %32
runs
.: %13
Exercise: %32
3
-
5
.: %32
Write: %32
the: %32
function: %32
itob
(
n
,
s
,
b
): %32
that: %32
converts: %32
the: %32
integer: %32
n: %32
into: %32
a: %32
base: %32
b: %32
character: %13
representation: %32
in: %32
the: %32
string: %32
s
.: %32
In: %32
particular
,: %32
itob
(
n
,
s
,
1
6
): %32
formats: %32
s: %32
as: %32
a: %32
hexadecimal: %32
integer: %32
in: %32
s
.: %13
Exercise: %32
3
-
6
.: %32
Write: %32
a: %32
version: %32
of: %32
itoa: %32
that: %32
accepts: %32
three: %32
arguments: %32
instead: %32
of: %32
two
.: %32
The: %32
third: %32
argument: %32
is: %13
a: %32
minimum: %32
field: %32
width
;: %32
the: %32
converted: %32
number: %32
must: %32
be: %32
padded: %32
with: %32
blanks: %32
on: %32
the: %32
left: %32
if: %32
necessary: %32
to: %13
make: %32
it: %32
wide: %32
enough
.: %13
3
.
7: %32
Break: %32
and: %32
Continue: %13
It: %32
is: %32
sometimes: %32
convenient: %32
to: %32
be: %32
able: %32
to: %32
exit: %32
from: %32
a: %32
loop: %32
other: %32
than: %32
by: %32
testing: %32
at: %32
the: %32
top: %32
or: %32
bottom
.: %32
The: %13
break: %32
statement: %32
provides: %32
an: %32
early: %32
exit: %32
from: %32
for
,: %32
while
,: %32
and: %32
do
,: %32
just: %32
as: %32
from: %32
switch
.: %32
A: %32
break: %13
causes: %32
the: %32
innermost: %32
enclosing: %32
loop: %32
or: %32
switch: %32
to: %32
be: %32
exited: %32
immediately
.: %13
The: %32
following: %32
function
,: %32
trim
,: %32
removes: %32
trailing: %32
blanks
,: %32
tabs: %32
and: %32
newlines: %32
from: %32
the: %32
end: %32
of: %32
a: %32
string
,: %32
using: %13
a: %32
break: %32
to: %32
exit: %32
from: %32
a: %32
loop: %32
when: %32
the: %32
rightmost: %32
non
-
blank
,: %32
non
-
tab
,: %32
non
-
newline: %32
is: %32
found
.: %13
Chapter: %32
3: %32
-: %32
Control: %32
Flow: %13
/
*: %32
trim
:: %32
remove: %32
trailing: %32
blanks
,: %32
tabs
,: %32
newlines: %32
*
/: %13
int: %32
trim
(
char: %32
s
[
]
): %13
{: %13
int: %32
n
;: %13
for: %32
(
n: %32
=: %32
strlen
(
s
)
-
1
;: %32
n: %32
>
=: %32
0
;: %32
n
-
-
): %13
if: %32
(
s
[
n
]: %32
!
=: %32
': %32
': %32
&
&: %32
s
[
n
]: %32
!
=: %32
'
\
t
': %32
&
&: %32
s
[
n
]: %32
!
=: %32
'
\
n
'
): %13
break
;: %13
s
[
n
+
1
]: %32
=: %32
'
\
0
'
;: %13
return: %32
n
;: %13
}: %13
strlen: %32
returns: %32
the: %32
length: %32
of: %32
the: %32
string
.: %32
The: %32
for: %32
loop: %32
starts: %32
at: %32
the: %32
end: %32
and: %32
scans: %32
backwards: %32
looking: %32
for: %13
the: %32
first: %32
character: %32
that: %32
is: %32
not: %32
a: %32
blank: %32
or: %32
tab: %32
or: %32
newline
.: %32
The: %32
loop: %32
is: %32
broken: %32
when: %32
one: %32
is: %32
found
,: %32
or: %32
when: %32
n: %13
becomes: %32
negative: %32
(
that: %32
is
,: %32
when: %32
the: %32
entire: %32
string: %32
has: %32
been: %32
scanned
)
.: %32
You: %32
should: %32
verify: %32
that: %32
this: %32
is: %32
correct: %13
behavior: %32
even: %32
when: %32
the: %32
string: %32
is: %32
empty: %32
or: %32
contains: %32
only: %32
white: %32
space: %32
characters
.: %13
The: %32
continue: %32
statement: %32
is: %32
related: %32
to: %32
break
,: %32
but: %32
less: %32
often: %32
used
;: %32
it: %32
causes: %32
the: %32
next: %32
iteration: %32
of: %32
the: %13
enclosing: %32
for
,: %32
while
,: %32
or: %32
do: %32
loop: %32
to: %32
begin
.: %32
In: %32
the: %32
while: %32
and: %32
do
,: %32
this: %32
means: %32
that: %32
the: %32
test: %32
part: %32
is: %13
executed: %32
immediately
;: %32
in: %32
the: %32
for
,: %32
control: %32
passes: %32
to: %32
the: %32
increment: %32
step
.: %32
The: %32
continue: %32
statement: %13
applies: %32
only: %32
to: %32
loops
,: %32
not: %32
to: %32
switch
.: %32
A: %32
continue: %32
inside: %32
a: %32
switch: %32
inside: %32
a: %32
loop: %32
causes: %32
the: %32
next: %32
loop: %13
iteration
.: %13
As: %32
an: %32
example
,: %32
this: %32
fragment: %32
processes: %32
only: %32
the: %32
non
-
negative: %32
elements: %32
in: %32
the: %32
array: %32
a
;: %32
negative: %32
values: %13
are: %32
skipped
.: %13
for: %32
(
i: %32
=: %32
0
;: %32
i: %32
<: %32
n
;: %32
i
+
+
): %13
if: %32
(
a
[
i
]: %32
<: %32
0
): %13
/
*: %32
skip: %32
negative: %32
elements: %32
*
/: %13
continue
;: %13
.
.
.: %32
/
*: %32
do: %32
positive: %32
elements: %32
*
/: %13
The: %32
continue: %32
statement: %32
is: %32
often: %32
used: %32
when: %32
the: %32
part: %32
of: %32
the: %32
loop: %32
that: %32
follows: %32
is: %32
complicated
,: %32
so: %32
that: %13
reversing: %32
a: %32
test: %32
and: %32
indenting: %32
another: %32
level: %32
would: %32
nest: %32
the: %32
program: %32
too: %32
deeply
.: %13
3
.
8: %32
Goto: %32
and: %32
labels: %13
C: %32
provides: %32
the: %32
infinitely
-
abusable: %32
goto: %32
statement
,: %32
and: %32
labels: %32
to: %32
branch: %32
to
.: %32
Formally
,: %32
the: %32
goto: %13
statement: %32
is: %32
never: %32
necessary
,: %32
and: %32
in: %32
practice: %32
it: %32
is: %32
almost: %32
always: %32
easy: %32
to: %32
write: %32
code: %32
without: %32
it
.: %32
We: %32
have: %13
not: %32
used: %32
goto: %32
in: %32
this: %32
book
.: %13
Nevertheless
,: %32
there: %32
are: %32
a: %32
few: %32
situations: %32
where: %32
gotos: %32
may: %32
find: %32
a: %32
place
.: %32
The: %32
most: %32
common: %32
is: %32
to: %32
abandon: %13
Chapter: %32
3: %32
-: %32
Control: %32
Flow: %13
processing: %32
in: %32
some: %32
deeply: %32
nested: %32
structure
,: %32
such: %32
as: %32
breaking: %32
out: %32
of: %32
two: %32
or: %32
more: %32
loops: %32
at: %32
once
.: %32
The: %13
break: %32
statement: %32
cannot: %32
be: %32
used: %32
directly: %32
since: %32
it: %32
only: %32
exits: %32
from: %32
the: %32
innermost: %32
loop
.: %32
Thus
:: %13
for: %32
(: %32
.
.
.: %32
): %13
for: %32
(: %32
.
.
.: %32
): %32
{: %13
.
.
.: %13
if: %32
(
disaster
): %13
goto: %32
error
;: %13
}: %13
.
.
.: %13
error
:: %13
/
*: %32
clean: %32
up: %32
the: %32
mess: %32
*
/: %13
This: %32
organization: %32
is: %32
handy: %32
if: %32
the: %32
error
-
handling: %32
code: %32
is: %32
non
-
trivial
,: %32
and: %32
if: %32
errors: %32
can: %32
occur: %32
in: %32
several: %13
places
.: %13
A: %32
label: %32
has: %32
the: %32
same: %32
form: %32
as: %32
a: %32
variable: %32
name
,: %32
and: %32
is: %32
followed: %32
by: %32
a: %32
colon
.: %32
It: %32
can: %32
be: %32
attached: %32
to: %32
any: %13
statement: %32
in: %32
the: %32
same: %32
function: %32
as: %32
the: %32
goto
.: %32
The: %32
scope: %32
of: %32
a: %32
label: %32
is: %32
the: %32
entire: %32
function
.: %13
As: %32
another: %32
example
,: %32
consider: %32
the: %32
problem: %32
of: %32
determining: %32
whether: %32
two: %32
arrays: %32
a: %32
and: %32
b: %32
have: %32
an: %32
element: %32
in: %13
common
.: %32
One: %32
possibility: %32
is: %13
for: %32
(
i: %32
=: %32
0
;: %32
i: %32
<: %32
n
;: %32
i
+
+
): %13
for: %32
(
j: %32
=: %32
0
;: %32
j: %32
<: %32
m
;: %32
j
+
+
): %13
if: %32
(
a
[
i
]: %32
=
=: %32
b
[
j
]
): %13
goto: %32
found
;: %13
/
*: %32
didn
'
t: %32
find: %32
any: %32
common: %32
element: %32
*
/: %13
.
.
.: %13
found
:: %13
/
*: %32
got: %32
one
:: %32
a
[
i
]: %32
=
=: %32
b
[
j
]: %32
*
/: %13
.
.
.: %13
Code: %32
involving: %32
a: %32
goto: %32
can: %32
always: %32
be: %32
written: %32
without: %32
one
,: %32
though: %32
perhaps: %32
at: %32
the: %32
price: %32
of: %32
some: %32
repeated: %13
tests: %32
or: %32
an: %32
extra: %32
variable
.: %32
For: %32
example
,: %32
the: %32
array: %32
search: %32
becomes: %13
found: %32
=: %32
0
;: %13
for: %32
(
i: %32
=: %32
0
;: %32
i: %32
<: %32
n: %32
&
&: %32
!
found
;: %32
i
+
+
): %13
for: %32
(
j: %32
=: %32
0
;: %32
j: %32
<: %32
m: %32
&
&: %32
!
found
;: %32
j
+
+
): %13
if: %32
(
a
[
i
]: %32
=
=: %32
b
[
j
]
): %13
found: %32
=: %32
1
;: %13
if: %32
(
found
): %13
/
*: %32
got: %32
one
:: %32
a
[
i
-
1
]: %32
=
=: %32
b
[
j
-
1
]: %32
*
/: %13
Chapter: %32
3: %32
-: %32
Control: %32
Flow: %13
.
.
.: %13
else: %13
/
*: %32
didn
'
t: %32
find: %32
any: %32
common: %32
element: %32
*
/: %13
.
.
.: %13
With: %32
a: %32
few: %32
exceptions: %32
like: %32
those: %32
cited: %32
here
,: %32
code: %32
that: %32
relies: %32
on: %32
goto: %32
statements: %32
is: %32
generally: %32
harder: %32
to: %13
understand: %32
and: %32
to: %32
maintain: %32
than: %32
code: %32
without: %32
gotos
.: %32
Although: %32
we: %32
are: %32
not: %32
dogmatic: %32
about: %32
the: %32
matter
,: %32
it: %13
does: %32
seem: %32
that: %32
goto: %32
statements: %32
should: %32
be: %32
used: %32
rarely
,: %32
if: %32
at: %32
all
.: %13
Back: %32
to: %32
Chapter: %32
2: %32
-
-: %32
Index: %32
-
-: %32
Chapter: %32
4: %13
Chapter: %32
4: %32
-: %32
Functions: %32
and: %32
Program: %32
Structure: %13
Back: %32
to: %32
Chapter: %32
3: %32
-
-: %32
Index: %32
-
-: %32
Chapter: %32
5: %13
Chapter: %32
4: %32
-: %32
Functions: %32
and: %32
Program: %32
Structure: %13
Functions: %32
break: %32
large: %32
computing: %32
tasks: %32
into: %32
smaller: %32
ones
,: %32
and: %32
enable: %32
people: %32
to: %32
build: %32
on: %32
what: %32
others: %32
have: %32
done: %32
instead: %32
of: %32
starting: %32
over: %32
from: %13
scratch
.: %32
Appropriate: %32
functions: %32
hide: %32
details: %32
of: %32
operation: %32
from: %32
parts: %32
of: %32
the: %32
program: %32
that: %32
don
'
t: %32
need: %32
to: %32
know: %32
about: %32
them
,: %32
thus: %32
clarifying: %32
the: %32
whole
,: %13
and: %32
easing: %32
the: %32
pain: %32
of: %32
making: %32
changes
.: %13
C: %32
has: %32
been: %32
designed: %32
to: %32
make: %32
functions: %32
efficient: %32
and: %32
easy: %32
to: %32
use
;: %32
C: %32
programs: %32
generally: %32
consist: %32
of: %32
many: %32
small: %32
functions: %32
rather: %32
than: %32
a: %32
few: %32
big: %32
ones
.: %13
A: %32
program: %32
may: %32
reside: %32
in: %32
one: %32
or: %32
more: %32
source: %32
files
.: %32
Source: %32
files: %32
may: %32
be: %32
compiled: %32
separately: %32
and: %32
loaded: %32
together
,: %32
along: %32
with: %32
previously: %32
compiled: %13
functions: %32
from: %32
libraries
.: %32
We: %32
will: %32
not: %32
go: %32
into: %32
that: %32
process: %32
here
,: %32
however
,: %32
since: %32
the: %32
details: %32
vary: %32
from: %32
system: %32
to: %32
system
.: %13
Function: %32
declaration: %32
and: %32
definition: %32
is: %32
the: %32
area: %32
where: %32
the: %32
ANSI: %32
standard: %32
has: %32
made: %32
the: %32
most: %32
changes: %32
to: %32
C
.: %32
As: %32
we: %32
saw: %32
first: %32
in: %32
Chapter: %32
1
,: %32
it: %32
is: %32
now: %13
possible: %32
to: %32
declare: %32
the: %32
type: %32
of: %32
arguments: %32
when: %32
a: %32
function: %32
is: %32
declared
.: %32
The: %32
syntax: %32
of: %32
function: %32
declaration: %32
also: %32
changes
,: %32
so: %32
that: %32
declarations: %32
and: %13
definitions: %32
match
.: %32
This: %32
makes: %32
it: %32
possible: %32
for: %32
a: %32
compiler: %32
to: %32
detect: %32
many: %32
more: %32
errors: %32
than: %32
it: %32
could: %32
before
.: %32
Furthermore
,: %32
when: %32
arguments: %32
are: %13
properly: %32
declared
,: %32
appropriate: %32
type: %32
coercions: %32
are: %32
performed: %32
automatically
.: %13
The: %32
standard: %32
clarifies: %32
the: %32
rules: %32
on: %32
the: %32
scope: %32
of: %32
names
;: %32
in: %32
particular
,: %32
it: %32
requires: %32
that: %32
there: %32
be: %32
only: %32
one: %32
definition: %32
of: %32
each: %32
external: %32
object
.: %13
Initialization: %32
is: %32
more: %32
general
:: %32
automatic: %32
arrays: %32
and: %32
structures: %32
may: %32
now: %32
be: %32
initialized
.: %13
The: %32
C: %32
preprocessor: %32
has: %32
also: %32
been: %32
enhanced
.: %32
New: %32
preprocessor: %32
facilities: %32
include: %32
a: %32
more: %32
complete: %32
set: %32
of: %32
conditional: %32
compilation: %32
directives
,: %32
a: %32
way: %13
to: %32
create: %32
quoted: %32
strings: %32
from: %32
macro: %32
arguments
,: %32
and: %32
better: %32
control: %32
over: %32
the: %32
macro: %32
expansion: %32
process
.: %13
4
.
1: %32
Basics: %32
of: %32
Functions: %13
To: %32
begin: %32
with
,: %32
let: %32
us: %32
design: %32
and: %32
write: %32
a: %32
program: %32
to: %32
print: %32
each: %32
line: %32
of: %32
its: %32
input: %32
that: %32
contains: %32
a: %32
particular: %32
`
`
pattern
'
': %32
or: %32
string: %32
of: %32
characters
.: %32
(
This: %32
is: %32
a: %13
special: %32
case: %32
of: %32
the: %32
UNIX: %32
program: %32
grep
.
): %32
For: %32
example
,: %32
searching: %32
for: %32
the: %32
pattern: %32
of: %32
letters: %32
`
`
ould
'
': %32
in: %32
the: %32
set: %32
of: %32
lines: %13
Ah: %32
Love
!: %32
could: %32
you: %32
and: %32
I: %32
with: %32
Fate: %32
conspire: %13
To: %32
grasp: %32
this: %32
sorry: %32
Scheme: %32
of: %32
Things: %32
entire
,: %13
Would: %32
not: %32
we: %32
shatter: %32
it: %32
to: %32
bits: %32
-
-: %32
and: %32
then: %13
Re
-
mould: %32
it: %32
nearer: %32
to: %32
the: %32
Heart
'
s: %32
Desire
!: %13
will: %32
produce: %32
the: %32
output: %13
Ah: %32
Love
!: %32
could: %32
you: %32
and: %32
I: %32
with: %32
Fate: %32
conspire: %13
Would: %32
not: %32
we: %32
shatter: %32
it: %32
to: %32
bits: %32
-
-: %32
and: %32
then: %13
Re
-
mould: %32
it: %32
nearer: %32
to: %32
the: %32
Heart
'
s: %32
Desire
!: %13
The: %32
job: %32
falls: %32
neatly: %32
into: %32
three: %32
pieces
:: %13
while: %32
(
there
'
s: %32
another: %32
line
): %13
if: %32
(
the: %32
line: %32
contains: %32
the: %32
pattern
): %13
print: %32
it: %13
Although: %32
it
'
s: %32
certainly: %32
possible: %32
to: %32
put: %32
the: %32
code: %32
for: %32
all: %32
of: %32
this: %32
in: %32
main
,: %32
a: %32
better: %32
way: %32
is: %32
to: %32
use: %32
the: %32
structure: %32
to: %32
advantage: %32
by: %32
making: %32
each: %32
part: %32
a: %13
separate: %32
function
.: %32
Three: %32
small: %32
pieces: %32
are: %32
better: %32
to: %32
deal: %32
with: %32
than: %32
one: %32
big: %32
one
,: %32
because: %32
irrelevant: %32
details: %32
can: %32
be: %32
buried: %32
in: %32
the: %32
functions
,: %32
and: %32
the: %13
chance: %32
of: %32
unwanted: %32
interactions: %32
is: %32
minimized
.: %32
And: %32
the: %32
pieces: %32
may: %32
even: %32
be: %32
useful: %32
in: %32
other: %32
programs
.: %13
`
`
While: %32
there
'
s: %32
another: %32
line
'
': %32
is: %32
getline
,: %32
a: %32
function: %32
that: %32
we: %32
wrote: %32
in: %32
Chapter: %32
1
,: %32
and: %32
`
`
print: %32
it
'
': %32
is: %32
printf
,: %32
which: %32
someone: %32
has: %32
already: %32
provided: %13
for: %32
us
.: %32
This: %32
means: %32
we: %32
need: %32
only: %32
write: %32
a: %32
routine: %32
to: %32
decide: %32
whether: %32
the: %32
line: %32
contains: %32
an: %32
occurrence: %32
of: %32
the: %32
pattern
.: %13
Chapter: %32
4: %32
-: %32
Functions: %32
and: %32
Program: %32
Structure: %13
We: %32
can: %32
solve: %32
that: %32
problem: %32
by: %32
writing: %32
a: %32
function: %32
strindex
(
s
,
t
): %32
that: %32
returns: %32
the: %32
position: %32
or: %32
index: %32
in: %32
the: %32
string: %32
s: %32
where: %32
the: %32
string: %32
t: %32
begins
,: %32
or: %13
-
1: %32
if: %32
s: %32
does: %32
not: %32
contain: %32
t
.: %32
Because: %32
C: %32
arrays: %32
begin: %32
at: %32
position: %32
zero
,: %32
indexes: %32
will: %32
be: %32
zero: %32
or: %32
positive
,: %32
and: %32
so: %32
a: %32
negative: %32
value: %32
like: %32
-
1: %32
is: %32
convenient: %13
for: %32
signaling: %32
failure
.: %32
When: %32
we: %32
later: %32
need: %32
more: %32
sophisticated: %32
pattern: %32
matching
,: %32
we: %32
only: %32
have: %32
to: %32
replace: %32
strindex
;: %32
the: %32
rest: %32
of: %32
the: %32
code: %32
can: %13
remain: %32
the: %32
same
.: %32
(
The: %32
standard: %32
library: %32
provides: %32
a: %32
function: %32
strstr: %32
that: %32
is: %32
similar: %32
to: %32
strindex
,: %32
except: %32
that: %32
it: %32
returns: %32
a: %32
pointer: %32
instead: %32
of: %32
an: %13
index
.
): %13
Given: %32
this: %32
much: %32
design
,: %32
filling: %32
in: %32
the: %32
details: %32
of: %32
the: %32
program: %32
is: %32
straightforward
.: %32
Here: %32
is: %32
the: %32
whole: %32
thing
,: %32
so: %32
you: %32
can: %32
see: %32
how: %32
the: %32
pieces: %32
fit: %32
together
.: %13
For: %32
now
,: %32
the: %32
pattern: %32
to: %32
be: %32
searched: %32
for: %32
is: %32
a: %32
literal: %32
string
,: %32
which: %32
is: %32
not: %32
the: %32
most: %32
general: %32
of: %32
mechanisms
.: %32
We: %32
will: %32
return: %32
shortly: %32
to: %32
a: %32
discussion: %32
of: %13
how: %32
to: %32
initialize: %32
character: %32
arrays
,: %32
and: %32
in: %32
Chapter: %32
5: %32
will: %32
show: %32
how: %32
to: %32
make: %32
the: %32
pattern: %32
a: %32
parameter: %32
that: %32
is: %32
set: %32
when: %32
the: %32
program: %32
is: %32
run
.: %32
There: %32
is: %13
also: %32
a: %32
slightly: %32
different: %32
version: %32
of: %32
getline
;: %32
you: %32
might: %32
find: %32
it: %32
instructive: %32
to: %32
compare: %32
it: %32
to: %32
the: %32
one: %32
in: %32
Chapter: %32
1
.: %13
#
include: %32
<
stdio
.
h
>: %13
#
define: %32
MAXLINE: %32
1
0
0
0: %32
/
*: %32
maximum: %32
input: %32
line: %32
length: %32
*
/: %13
int: %32
getline
(
char: %32
line
[
]
,: %32
int: %32
max
): %13
int: %32
strindex
(
char: %32
source
[
]
,: %32
char: %32
searchfor
[
]
)
;: %13
char: %32
pattern
[
]: %32
=: %32
"
ould
"
;: %13
/
*: %32
pattern: %32
to: %32
search: %32
for: %32
*
/: %13
/
*: %32
find: %32
all: %32
lines: %32
matching: %32
pattern: %32
*
/: %13
main
(
): %13
{: %13
char: %32
line
[
MAXLINE
]
;: %13
int: %32
found: %32
=: %32
0
;: %13
while: %32
(
getline
(
line
,: %32
MAXLINE
): %32
>: %32
0
): %13
if: %32
(
strindex
(
line
,: %32
pattern
): %32
>
=: %32
0
): %32
{: %13
printf
(
"
%:
s
"
,: %32
line
)
;: %13
found
+
+
;: %13
}: %13
return: %32
found
;: %13
}: %13
/
*: %32
getline
:: %32
get: %32
line: %32
into: %32
s
,: %32
return: %32
length: %32
*
/: %13
int: %32
getline
(
char: %32
s
[
]
,: %32
int: %32
lim
): %13
{: %13
int: %32
c
,: %32
i
;: %13
i: %32
=: %32
0
;: %13
while: %32
(
-
-
lim: %32
>: %32
0: %32
&
&: %32
(
c
=
getchar
(
)
): %32
!
=: %32
EOF: %32
&
&: %32
c: %32
!
=: %32
'
\
n
'
): %13
s
[
i
+
+
]: %32
=: %32
c
;: %13
if: %32
(
c: %32
=
=: %32
'
\
n
'
): %13
s
[
i
+
+
]: %32
=: %32
c
;: %13
s
[
i
]: %32
=: %32
'
\
0
'
;: %13
return: %32
i
;: %13
}: %13
/
*: %32
strindex
:: %32
return: %32
index: %32
of: %32
t: %32
in: %32
s
,: %32
-
1: %32
if: %32
none: %32
*
/: %13
int: %32
strindex
(
char: %32
s
[
]
,: %32
char: %32
t
[
]
): %13
{: %13
int: %32
i
,: %32
j
,: %32
k
;: %13
for: %32
(
i: %32
=: %32
0
;: %32
s
[
i
]: %32
!
=: %32
'
\
0
'
;: %32
i
+
+
): %32
{: %13
for: %32
(
j
=
i
,: %32
k
=
0
;: %32
t
[
k
]
!
=
'
\
0
': %32
&
&: %32
s
[
j
]
=
=
t
[
k
]
;: %32
j
+
+
,: %32
k
+
+
): %13
;: %13
if: %32
(
k: %32
>: %32
0: %32
&
&: %32
t
[
k
]: %32
=
=: %32
'
\
0
'
): %13
return: %32
i
;: %13
}: %13
return: %32
-
1
;: %13
}: %13
Chapter: %32
4: %32
-: %32
Functions: %32
and: %32
Program: %32
Structure: %13
Each: %32
function: %32
definition: %32
has: %32
the: %32
form: %13
return
-
type: %32
function
-
name
(
argument: %32
declarations
): %13
{: %13
declarations: %32
and: %32
statements: %13
}: %13
Various: %32
parts: %32
may: %32
be: %32
absent
;: %32
a: %32
minimal: %32
function: %32
is: %13
dummy
(
): %32
{
}: %13
which: %32
does: %32
nothing: %32
and: %32
returns: %32
nothing
.: %32
A: %32
do
-
nothing: %32
function: %32
like: %32
this: %32
is: %32
sometimes: %32
useful: %32
as: %32
a: %32
place: %32
holder: %32
during: %32
program: %32
development
.: %32
If: %32
the: %13
return: %32
type: %32
is: %32
omitted
,: %32
int: %32
is: %32
assumed
.: %13
A: %32
program: %32
is: %32
just: %32
a: %32
set: %32
of: %32
definitions: %32
of: %32
variables: %32
and: %32
functions
.: %32
Communication: %32
between: %32
the: %32
functions: %32
is: %32
by: %32
arguments: %32
and: %32
values: %32
returned: %32
by: %13
the: %32
functions
,: %32
and: %32
through: %32
external: %32
variables
.: %32
The: %32
functions: %32
can: %32
occur: %32
in: %32
any: %32
order: %32
in: %32
the: %32
source: %32
file
,: %32
and: %32
the: %32
source: %32
program: %32
can: %32
be: %32
split: %32
into: %13
multiple: %32
files
,: %32
so: %32
long: %32
as: %32
no: %32
function: %32
is: %32
split
.: %13
The: %32
return: %32
statement: %32
is: %32
the: %32
mechanism: %32
for: %32
returning: %32
a: %32
value: %32
from: %32
the: %32
called: %32
function: %32
to: %32
its: %32
caller
.: %32
Any: %32
expression: %32
can: %32
follow: %32
return
:: %13
return: %32
expression
;: %13
The: %32
expression: %32
will: %32
be: %32
converted: %32
to: %32
the: %32
return: %32
type: %32
of: %32
the: %32
function: %32
if: %32
necessary
.: %32
Parentheses: %32
are: %32
often: %32
used: %32
around: %32
the: %32
expression
,: %32
but: %32
they: %32
are: %13
optional
.: %13
The: %32
calling: %32
function: %32
is: %32
free: %32
to: %32
ignore: %32
the: %32
returned: %32
value
.: %32
Furthermore
,: %32
there: %32
need: %32
to: %32
be: %32
no: %32
expression: %32
after: %32
return
;: %32
in: %32
that: %32
case
,: %32
no: %32
value: %32
is: %13
returned: %32
to: %32
the: %32
caller
.: %32
Control: %32
also: %32
returns: %32
to: %32
the: %32
caller: %32
with: %32
no: %32
value: %32
when: %32
execution: %32
`
`
falls: %32
off: %32
the: %32
end
'
': %32
of: %32
the: %32
function: %32
by: %32
reaching: %32
the: %32
closing: %13
right: %32
brace
.: %32
It: %32
is: %32
not: %32
illegal
,: %32
but: %32
probably: %32
a: %32
sign: %32
of: %32
trouble
,: %32
if: %32
a: %32
function: %32
returns: %32
a: %32
value: %32
from: %32
one: %32
place: %32
and: %32
no: %32
value: %32
from: %32
another
.: %32
In: %32
any: %32
case
,: %32
if: %32
a: %13
function: %32
fails: %32
to: %32
return: %32
a: %32
value
,: %32
its: %32
`
`
value
'
': %32
is: %32
certain: %32
to: %32
be: %32
garbage
.: %13
The: %32
pattern
-
searching: %32
program: %32
returns: %32
a: %32
status: %32
from: %32
main
,: %32
the: %32
number: %32
of: %32
matches: %32
found
.: %32
This: %32
value: %32
is: %32
available: %32
for: %32
use: %32
by: %32
the: %32
environment: %32
that: %13
called: %32
the: %32
program: %13
The: %32
mechanics: %32
of: %32
how: %32
to: %32
compile: %32
and: %32
load: %32
a: %32
C: %32
program: %32
that: %32
resides: %32
on: %32
multiple: %32
source: %32
files: %32
vary: %32
from: %32
one: %32
system: %32
to: %32
the: %32
next
.: %32
On: %32
the: %32
UNIX: %13
system
,: %32
for: %32
example
,: %32
the: %32
cc: %32
command: %32
mentioned: %32
in: %32
Chapter: %32
1: %32
does: %32
the: %32
job
.: %32
Suppose: %32
that: %32
the: %32
three: %32
functions: %32
are: %32
stored: %32
in: %32
three: %32
files: %32
called: %13
main
.
c
,: %32
getline
.
c
,: %32
and: %32
strindex
.
c
.: %32
Then: %32
the: %32
command: %13
cc: %32
main
.
c: %32
getline
.
c: %32
strindex
.
c: %13
compiles: %32
the: %32
three: %32
files
,: %32
placing: %32
the: %32
resulting: %32
object: %32
code: %32
in: %32
files: %32
main
.
o
,: %32
getline
.
o
,: %32
and: %32
strindex
.
o
,: %32
then: %32
loads: %32
them: %32
all: %32
into: %32
an: %13
executable: %32
file: %32
called: %32
a
.
out
.: %32
If: %32
there: %32
is: %32
an: %32
error
,: %32
say: %32
in: %32
main
.
c
,: %32
the: %32
file: %32
can: %32
be: %32
recompiled: %32
by: %32
itself: %32
and: %32
the: %32
result: %32
loaded: %32
with: %32
the: %32
previous: %13
object: %32
files
,: %32
with: %32
the: %32
command: %13
cc: %32
main
.
c: %32
getline
.
o: %32
strindex
.
o: %13
The: %32
cc: %32
command: %32
uses: %32
the: %32
`
`
.
c
'
': %32
versus: %32
`
`
.
o
'
': %32
naming: %32
convention: %32
to: %32
distinguish: %32
source: %32
files: %32
from: %32
object: %32
files
.: %13
Exercise: %32
4
-
1
.: %32
Write: %32
the: %32
function: %32
strindex
(
s
,
t
): %32
which: %32
returns: %32
the: %32
position: %32
of: %32
the: %32
rightmost: %32
occurrence: %32
of: %32
t: %32
in: %32
s
,: %32
or: %32
-
1: %32
if: %32
there: %32
is: %32
none
.: %13
4
.
2: %32
Functions: %32
Returning: %32
Non
-
integers: %13
So: %32
far: %32
our: %32
examples: %32
of: %32
functions: %32
have: %32
returned: %32
either: %32
no: %32
value: %32
(
void
): %32
or: %32
an: %32
int
.: %32
What: %32
if: %32
a: %32
function: %32
must: %32
return: %32
some: %32
other: %32
type
?: %32
many: %13
numerical: %32
functions: %32
like: %32
sqrt
,: %32
sin
,: %32
and: %32
cos: %32
return: %32
double
;: %32
other: %32
specialized: %32
functions: %32
return: %32
other: %32
types
.: %32
To: %32
illustrate: %32
how: %32
to: %32
deal: %32
with: %32
this
,: %13
let: %32
us: %32
write: %32
and: %32
use: %32
the: %32
function: %32
atof
(
s
)
,: %32
which: %32
converts: %32
the: %32
string: %32
s: %32
to: %32
its: %32
double
-
precision: %32
floating
-
point: %32
equivalent
.: %32
atof: %32
if: %32
an: %32
extension: %32
of: %13
atoi
,: %32
which: %32
we: %32
showed: %32
versions: %32
of: %32
in: %32
Chapters: %32
2: %32
and: %32
3
.: %32
It: %32
handles: %32
an: %32
optional: %32
sign: %32
and: %32
decimal: %32
point
,: %32
and: %32
the: %32
presence: %32
or: %32
absence: %32
of: %32
either: %32
part: %13
or: %32
fractional: %32
part
.: %32
Our: %32
version: %32
is: %32
not: %32
a: %32
high
-
quality: %32
input: %32
conversion: %32
routine
;: %32
that: %32
would: %32
take: %32
more: %32
space: %32
than: %32
we: %32
care: %32
to: %32
use
.: %32
The: %32
standard: %32
library: %13
Chapter: %32
4: %32
-: %32
Functions: %32
and: %32
Program: %32
Structure: %13
includes: %32
an: %32
atof
;: %32
the: %32
header: %32
<
stdlib
.
h
>: %32
declares: %32
it
.: %13
First
,: %32
atof: %32
itself: %32
must: %32
declare: %32
the: %32
type: %32
of: %32
value: %32
it: %32
returns
,: %32
since: %32
it: %32
is: %32
not: %32
int
.: %32
The: %32
type: %32
name: %32
precedes: %32
the: %32
function: %32
name
:: %13
#
include: %32
<
ctype
.
h
>: %13
/
*: %32
atof
:: %32
convert: %32
string: %32
s: %32
to: %32
double: %32
*
/: %13
double: %32
atof
(
char: %32
s
[
]
): %13
{: %13
double: %32
val
,: %32
power
;: %13
int: %32
i
,: %32
sign
;: %13
for: %32
(
i: %32
=: %32
0
;: %32
isspace
(
s
[
i
]
)
;: %32
i
+
+
): %32
/
*: %32
skip: %32
white: %32
space: %32
*
/: %13
;: %13
sign: %32
=: %32
(
s
[
i
]: %32
=
=: %32
'
-
'
): %32
?: %32
-
1: %32
:: %32
1
;: %13
if: %32
(
s
[
i
]: %32
=
=: %32
'
+
': %32
|
|: %32
s
[
i
]: %32
=
=: %32
'
-
'
): %13
i
+
+
;: %13
for: %32
(
val: %32
=: %32
0
.
0
;: %32
isdigit
(
s
[
i
]
)
;: %32
i
+
+
): %13
val: %32
=: %32
1
0
.
0: %32
*: %32
val: %32
+: %32
(
s
[
i
]: %32
-: %32
'
0
'
)
;: %13
if: %32
(
s
[
i
]: %32
=
=: %32
'
.
'
): %13
i
+
+
;: %13
for: %32
(
power: %32
=: %32
1
.
0
;: %32
isdigit
(
s
[
i
]
)
;: %32
i
+
+
): %32
{: %13
val: %32
=: %32
1
0
.
0: %32
*: %32
val: %32
+: %32
(
s
[
i
]: %32
-: %32
'
0
'
)
;: %13
power: %32
*
=: %32
1
0
;: %13
}: %13
return: %32
sign: %32
*: %32
val: %32
/: %32
power
;: %13
}: %13
Second
,: %32
and: %32
just: %32
as: %32
important
,: %32
the: %32
calling: %32
routine: %32
must: %32
know: %32
that: %32
atof: %32
returns: %32
a: %32
non
-
int: %32
value
.: %32
One: %32
way: %32
to: %32
ensure: %32
this: %32
is: %32
to: %32
declare: %32
atof: %13
explicitly: %32
in: %32
the: %32
calling: %32
routine
.: %32
The: %32
declaration: %32
is: %32
shown: %32
in: %32
this: %32
primitive: %32
calculator: %32
(
barely: %32
adequate: %32
for: %32
check
-
book: %32
balancing
)
,: %32
which: %32
reads: %32
one: %13
number: %32
per: %32
line
,: %32
optionally: %32
preceded: %32
with: %32
a: %32
sign
,: %32
and: %32
adds: %32
them: %32
up
,: %32
printing: %32
the: %32
running: %32
sum: %32
after: %32
each: %32
input
:: %13
#
include: %32
<
stdio
.
h
>: %13
#
define: %32
MAXLINE: %32
1
0
0: %13
/
*: %32
rudimentary: %32
calculator: %32
*
/: %13
main
(
): %13
{: %13
double: %32
sum
,: %32
atof
(
char: %32
[
]
)
;: %13
char: %32
line
[
MAXLINE
]
;: %13
int: %32
getline
(
char: %32
line
[
]
,: %32
int: %32
max
)
;: %13
sum: %32
=: %32
0
;: %13
while: %32
(
getline
(
line
,: %32
MAXLINE
): %32
>: %32
0
): %13
printf
(
"
\
t
%:
g
\
n
"
,: %32
sum: %32
+
=: %32
atof
(
line
)
)
;: %13
return: %32
0
;: %13
}: %13
The: %32
declaration: %13
double: %32
sum
,: %32
atof
(
char: %32
[
]
)
;: %13
says: %32
that: %32
sum: %32
is: %32
a: %32
double: %32
variable
,: %32
and: %32
that: %32
atof: %32
is: %32
a: %32
function: %32
that: %32
takes: %32
one: %32
char
[
]: %32
argument: %32
and: %32
returns: %32
a: %32
double
.: %13
The: %32
function: %32
atof: %32
must: %32
be: %32
declared: %32
and: %32
defined: %32
consistently
.: %32
If: %32
atof: %32
itself: %32
and: %32
the: %32
call: %32
to: %32
it: %32
in: %32
main: %32
have: %32
inconsistent: %32
types: %32
in: %32
the: %32
same: %32
source: %13
file
,: %32
the: %32
error: %32
will: %32
be: %32
detected: %32
by: %32
the: %32
compiler
.: %32
But: %32
if: %32
(
as: %32
is: %32
more: %32
likely
): %32
atof: %32
were: %32
compiled: %32
separately
,: %32
the: %32
mismatch: %32
would: %32
not: %32
be: %32
detected
,: %13
atof: %32
would: %32
return: %32
a: %32
double: %32
that: %32
main: %32
would: %32
treat: %32
as: %32
an: %32
int
,: %32
and: %32
meaningless: %32
answers: %32
would: %32
result
.: %13
In: %32
the: %32
light: %32
of: %32
what: %32
we: %32
have: %32
said: %32
about: %32
how: %32
declarations: %32
must: %32
match: %32
definitions
,: %32
this: %32
might: %32
seem: %32
surprising
.: %32
The: %32
reason: %32
a: %32
mismatch: %32
can: %32
happen: %32
is: %13
Chapter: %32
4: %32
-: %32
Functions: %32
and: %32
Program: %32
Structure: %13
that: %32
if: %32
there: %32
is: %32
no: %32
function: %32
prototype
,: %32
a: %32
function: %32
is: %32
implicitly: %32
declared: %32
by: %32
its: %32
first: %32
appearance: %32
in: %32
an: %32
expression
,: %32
such: %32
as: %13
sum: %32
+
=: %32
atof
(
line
): %13
If: %32
a: %32
name: %32
that: %32
has: %32
not: %32
been: %32
previously: %32
declared: %32
occurs: %32
in: %32
an: %32
expression: %32
and: %32
is: %32
followed: %32
by: %32
a: %32
left: %32
parentheses
,: %32
it: %32
is: %32
declared: %32
by: %32
context: %32
to: %32
be: %32
a: %13
function: %32
name
,: %32
the: %32
function: %32
is: %32
assumed: %32
to: %32
return: %32
an: %32
int
,: %32
and: %32
nothing: %32
is: %32
assumed: %32
about: %32
its: %32
arguments
.: %32
Furthermore
,: %32
if: %32
a: %32
function: %32
declaration: %32
does: %13
not: %32
include: %32
arguments
,: %32
as: %32
in: %13
double: %32
atof
(
)
;: %13
that: %32
too: %32
is: %32
taken: %32
to: %32
mean: %32
that: %32
nothing: %32
is: %32
to: %32
be: %32
assumed: %32
about: %32
the: %32
arguments: %32
of: %32
atof
;: %32
all: %32
parameter: %32
checking: %32
is: %32
turned: %32
off
.: %32
This: %32
special: %32
meaning: %13
of: %32
the: %32
empty: %32
argument: %32
list: %32
is: %32
intended: %32
to: %32
permit: %32
older: %32
C: %32
programs: %32
to: %32
compile: %32
with: %32
new: %32
compilers
.: %32
But: %32
it
'
s: %32
a: %32
bad: %32
idea: %32
to: %32
use: %32
it: %32
with: %32
new: %32
C: %13
programs
.: %32
If: %32
the: %32
function: %32
takes: %32
arguments
,: %32
declare: %32
them
;: %32
if: %32
it: %32
takes: %32
no: %32
arguments
,: %32
use: %32
void
.: %13
Given: %32
atof
,: %32
properly: %32
declared
,: %32
we: %32
could: %32
write: %32
atoi: %32
(
convert: %32
a: %32
string: %32
to: %32
int
): %32
in: %32
terms: %32
of: %32
it
:: %13
/
*: %32
atoi
:: %32
convert: %32
string: %32
s: %32
to: %32
integer: %32
using: %32
atof: %32
*
/: %13
int: %32
atoi
(
char: %32
s
[
]
): %13
{: %13
double: %32
atof
(
char: %32
s
[
]
)
;: %13
return: %32
(
int
): %32
atof
(
s
)
;: %13
}: %13
Notice: %32
the: %32
structure: %32
of: %32
the: %32
declarations: %32
and: %32
the: %32
return: %32
statement
.: %32
The: %32
value: %32
of: %32
the: %32
expression: %32
in: %13
return: %32
expression
;: %13
is: %32
converted: %32
to: %32
the: %32
type: %32
of: %32
the: %32
function: %32
before: %32
the: %32
return: %32
is: %32
taken
.: %32
Therefore
,: %32
the: %32
value: %32
of: %32
atof
,: %32
a: %32
double
,: %32
is: %32
converted: %32
automatically: %32
to: %32
int: %13
when: %32
it: %32
appears: %32
in: %32
this: %32
return
,: %32
since: %32
the: %32
function: %32
atoi: %32
returns: %32
an: %32
int
.: %32
This: %32
operation: %32
does: %32
potentionally: %32
discard: %32
information
,: %32
however
,: %32
so: %13
some: %32
compilers: %32
warn: %32
of: %32
it
.: %32
The: %32
cast: %32
states: %32
explicitly: %32
that: %32
the: %32
operation: %32
is: %32
intended
,: %32
and: %32
suppresses: %32
any: %32
warning
.: %13
Exercise: %32
4
-
2
.: %32
Extend: %32
atof: %32
to: %32
handle: %32
scientific: %32
notation: %32
of: %32
the: %32
form: %13
1
2
3
.
4
5
e
-
6: %13
where: %32
a: %32
floating
-
point: %32
number: %32
may: %32
be: %32
followed: %32
by: %32
e: %32
or: %32
E: %32
and: %32
an: %32
optionally: %32
signed: %32
exponent
.: %13
4
.
3: %32
External: %32
Variables: %13
A: %32
C: %32
program: %32
consists: %32
of: %32
a: %32
set: %32
of: %32
external: %32
objects
,: %32
which: %32
are: %32
either: %32
variables: %32
or: %32
functions
.: %32
The: %32
adjective: %32
`
`
external
'
': %32
is: %32
used: %32
in: %32
contrast: %32
to: %13
`
`
internal
'
'
,: %32
which: %32
describes: %32
the: %32
arguments: %32
and: %32
variables: %32
defined: %32
inside: %32
functions
.: %32
External: %32
variables: %32
are: %32
defined: %32
outside: %32
of: %32
any: %32
function
,: %32
and: %32
are: %13
thus: %32
potentionally: %32
available: %32
to: %32
many: %32
functions
.: %32
Functions: %32
themselves: %32
are: %32
always: %32
external
,: %32
because: %32
C: %32
does: %32
not: %32
allow: %32
functions: %32
to: %32
be: %32
defined: %32
inside: %13
other: %32
functions
.: %32
By: %32
default
,: %32
external: %32
variables: %32
and: %32
functions: %32
have: %32
the: %32
property: %32
that: %32
all: %32
references: %32
to: %32
them: %32
by: %32
the: %32
same: %32
name
,: %32
even: %32
from: %32
functions: %13
compiled: %32
separately
,: %32
are: %32
references: %32
to: %32
the: %32
same: %32
thing
.: %32
(
The: %32
standard: %32
calls: %32
this: %32
property: %32
external: %32
linkage
.
): %32
In: %32
this: %32
sense
,: %32
external: %32
variables: %32
are: %13
analogous: %32
to: %32
Fortran: %32
COMMON: %32
blocks: %32
or: %32
variables: %32
in: %32
the: %32
outermost: %32
block: %32
in: %32
Pascal
.: %32
We: %32
will: %32
see: %32
later: %32
how: %32
to: %32
define: %32
external: %32
variables: %32
and: %13
functions: %32
that: %32
are: %32
visible: %32
only: %32
within: %32
a: %32
single: %32
source: %32
file
.: %32
Because: %32
external: %32
variables: %32
are: %32
globally: %32
accessible
,: %32
they: %32
provide: %32
an: %32
alternative: %32
to: %13
function: %32
arguments: %32
and: %32
return: %32
values: %32
for: %32
communicating: %32
data: %32
between: %32
functions
.: %32
Any: %32
function: %32
may: %32
access: %32
an: %32
external: %32
variable: %32
by: %32
referring: %32
to: %32
it: %13
by: %32
name
,: %32
if: %32
the: %32
name: %32
has: %32
been: %32
declared: %32
somehow
.: %13
If: %32
a: %32
large: %32
number: %32
of: %32
variables: %32
must: %32
be: %32
shared: %32
among: %32
functions
,: %32
external: %32
variables: %32
are: %32
more: %32
convenient: %32
and: %32
efficient: %32
than: %32
long: %32
argument: %32
lists
.: %32
As: %13
pointed: %32
out: %32
in: %32
Chapter: %32
1
,: %32
however
,: %32
this: %32
reasoning: %32
should: %32
be: %32
applied: %32
with: %32
some: %32
caution
,: %32
for: %32
it: %32
can: %32
have: %32
a: %32
bad: %32
effect: %32
on: %32
program: %32
structure
,: %32
and: %32
lead: %13
to: %32
programs: %32
with: %32
too: %32
many: %32
data: %32
connections: %32
between: %32
functions
.: %13
External: %32
variables: %32
are: %32
also: %32
useful: %32
because: %32
of: %32
their: %32
greater: %32
scope: %32
and: %32
lifetime
.: %32
Automatic: %32
variables: %32
are: %32
internal: %32
to: %32
a: %32
function
;: %32
they: %32
come: %32
into: %13
existence: %32
when: %32
the: %32
function: %32
is: %32
entered
,: %32
and: %32
disappear: %32
when: %32
it: %32
is: %32
left
.: %32
External: %32
variables
,: %32
on: %32
the: %32
other: %32
hand
,: %32
are: %32
permanent
,: %32
so: %32
they: %32
can: %32
retain: %13
values: %32
from: %32
one: %32
function: %32
invocation: %32
to: %32
the: %32
next
.: %32
Thus: %32
if: %32
two: %32
functions: %32
must: %32
share: %32
some: %32
data
,: %32
yet: %32
neither: %32
calls: %32
the: %32
other
,: %32
it: %32
is: %32
often: %32
most: %13
Chapter: %32
4: %32
-: %32
Functions: %32
and: %32
Program: %32
Structure: %13
convenient: %32
if: %32
the: %32
shared: %32
data: %32
is: %32
kept: %32
in: %32
external: %32
variables: %32
rather: %32
than: %32
being: %32
passed: %32
in: %32
and: %32
out: %32
via: %32
arguments
.: %13
Let: %32
us: %32
examine: %32
this: %32
issue: %32
with: %32
a: %32
larger: %32
example
.: %32
The: %32
problem: %32
is: %32
to: %32
write: %32
a: %32
calculator: %32
program: %32
that: %32
provides: %32
the: %32
operators: %32
+
,: %32
-
,: %32
*: %32
and: %32
/
.: %32
Because: %32
it: %13
is: %32
easier: %32
to: %32
implement
,: %32
the: %32
calculator: %32
will: %32
use: %32
reverse: %32
Polish: %32
notation: %32
instead: %32
of: %32
infix
.: %32
(
Reverse: %32
Polish: %32
notation: %32
is: %32
used: %32
by: %32
some: %32
pocket: %32
calculators
,: %13
and: %32
in: %32
languages: %32
like: %32
Forth: %32
and: %32
Postscript
.
): %13
In: %32
reverse: %32
Polish: %32
notation
,: %32
each: %32
operator: %32
follows: %32
its: %32
operands
;: %32
an: %32
infix: %32
expression: %32
like: %13
(
1: %32
-: %32
2
): %32
*: %32
(
4: %32
+: %32
5
): %13
is: %32
entered: %32
as: %13
1: %32
2: %32
-: %32
4: %32
5: %32
+: %32
*: %13
Parentheses: %32
are: %32
not: %32
needed
;: %32
the: %32
notation: %32
is: %32
unambiguous: %32
as: %32
long: %32
as: %32
we: %32
know: %32
how: %32
many: %32
operands: %32
each: %32
operator: %32
expects
.: %13
The: %32
implementation: %32
is: %32
simple
.: %32
Each: %32
operand: %32
is: %32
pushed: %32
onto: %32
a: %32
stack
;: %32
when: %32
an: %32
operator: %32
arrives
,: %32
the: %32
proper: %32
number: %32
of: %32
operands: %32
(
two: %32
for: %32
binary: %13
operators
): %32
is: %32
popped
,: %32
the: %32
operator: %32
is: %32
applied: %32
to: %32
them
,: %32
and: %32
the: %32
result: %32
is: %32
pushed: %32
back: %32
onto: %32
the: %32
stack
.: %32
In: %32
the: %32
example: %32
above
,: %32
for: %32
instance
,: %32
1: %32
and: %32
2: %32
are: %13
pushed
,: %32
then: %32
replaced: %32
by: %32
their: %32
difference
,: %32
-
1
.: %32
Next
,: %32
4: %32
and: %32
5: %32
are: %32
pushed: %32
and: %32
then: %32
replaced: %32
by: %32
their: %32
sum
,: %32
9
.: %32
The: %32
product: %32
of: %32
-
1: %32
and: %32
9
,: %32
which: %32
is: %32
-
9
,: %13
replaces: %32
them: %32
on: %32
the: %32
stack
.: %32
The: %32
value: %32
on: %32
the: %32
top: %32
of: %32
the: %32
stack: %32
is: %32
popped: %32
and: %32
printed: %32
when: %32
the: %32
end: %32
of: %32
the: %32
input: %32
line: %32
is: %32
encountered
.: %13
The: %32
structure: %32
of: %32
the: %32
program: %32
is: %32
thus: %32
a: %32
loop: %32
that: %32
performs: %32
the: %32
proper: %32
operation: %32
on: %32
each: %32
operator: %32
and: %32
operand: %32
as: %32
it: %32
appears
:: %13
while: %32
(
next: %32
operator: %32
or: %32
operand: %32
is: %32
not: %32
end
-
of
-
file: %32
indicator
): %13
if: %32
(
number
): %13
push: %32
it: %13
else: %32
if: %32
(
operator
): %13
pop: %32
operands: %13
do: %32
operation: %13
push: %32
result: %13
else: %32
if: %32
(
newline
): %13
pop: %32
and: %32
print: %32
top: %32
of: %32
stack: %13
else: %13
error: %13
The: %32
operation: %32
of: %32
pushing: %32
and: %32
popping: %32
a: %32
stack: %32
are: %32
trivial
,: %32
but: %32
by: %32
the: %32
time: %32
error: %32
detection: %32
and: %32
recovery: %32
are: %32
added
,: %32
they: %32
are: %32
long: %32
enough: %32
that: %32
it: %32
is: %13
better: %32
to: %32
put: %32
each: %32
in: %32
a: %32
separate: %32
function: %32
than: %32
to: %32
repeat: %32
the: %32
code: %32
throughout: %32
the: %32
whole: %32
program
.: %32
And: %32
there: %32
should: %32
be: %32
a: %32
separate: %32
function: %32
for: %13
fetching: %32
the: %32
next: %32
input: %32
operator: %32
or: %32
operand
.: %13
The: %32
main: %32
design: %32
decision: %32
that: %32
has: %32
not: %32
yet: %32
been: %32
discussed: %32
is: %32
where: %32
the: %32
stack: %32
is
,: %32
that: %32
is
,: %32
which: %32
routines: %32
access: %32
it: %32
directly
.: %32
On: %32
possibility: %32
is: %32
to: %32
keep: %32
it: %13
in: %32
main
,: %32
and: %32
pass: %32
the: %32
stack: %32
and: %32
the: %32
current: %32
stack: %32
position: %32
to: %32
the: %32
routines: %32
that: %32
push: %32
and: %32
pop: %32
it
.: %32
But: %32
main: %32
doesn
'
t: %32
need: %32
to: %32
know: %32
about: %32
the: %32
variables: %13
that: %32
control: %32
the: %32
stack
;: %32
it: %32
only: %32
does: %32
push: %32
and: %32
pop: %32
operations
.: %32
So: %32
we: %32
have: %32
decided: %32
to: %32
store: %32
the: %32
stack: %32
and: %32
its: %32
associated: %32
information: %32
in: %32
external: %13
variables: %32
accessible: %32
to: %32
the: %32
push: %32
and: %32
pop: %32
functions: %32
but: %32
not: %32
to: %32
main
.: %13
Translating: %32
this: %32
outline: %32
into: %32
code: %32
is: %32
easy: %32
enough
.: %32
If: %32
for: %32
now: %32
we: %32
think: %32
of: %32
the: %32
program: %32
as: %32
existing: %32
in: %32
one: %32
source: %32
file
,: %32
it: %32
will: %32
look: %32
like: %32
this
:: %13
#
includes: %13
#
defines: %13
function: %32
declarations: %32
for: %32
main: %13
main
(
): %32
{: %32
.
.
.: %32
}: %13
external: %32
variables: %32
for: %32
push: %32
and: %32
pop: %13
void: %32
push
(: %32
double: %32
f
): %32
{: %32
.
.
.: %32
}: %13
double: %32
pop
(
void
): %32
{: %32
.
.
.: %32
}: %13
Chapter: %32
4: %32
-: %32
Functions: %32
and: %32
Program: %32
Structure: %13
int: %32
getop
(
char: %32
s
[
]
): %32
{: %32
.
.
.: %32
}: %13
routines: %32
called: %32
by: %32
getop: %13
Later: %32
we: %32
will: %32
discuss: %32
how: %32
this: %32
might: %32
be: %32
split: %32
into: %32
two: %32
or: %32
more: %32
source: %32
files
.: %13
The: %32
function: %32
main: %32
is: %32
a: %32
loop: %32
containing: %32
a: %32
big: %32
switch: %32
on: %32
the: %32
type: %32
of: %32
operator: %32
or: %32
operand
;: %32
this: %32
is: %32
a: %32
more: %32
typical: %32
use: %32
of: %32
switch: %32
than: %32
the: %32
one: %13
shown: %32
in: %32
Section: %32
3
.
4
.: %13
#
include: %32
<
stdio
.
h
>: %32
/
*: %32
for: %13
#
include: %32
<
stdlib
.
h
>: %32%13
#
define: %32
MAXOP: %32
/
*: %32
max: %32
size: %32
of: %32
operand: %32
or: %32
operator: %32
*
/: %13
#
define: %32
NUMBER: %32
/
*: %32
signal: %32
that: %32
a: %32
number: %32
was: %32
found: %32
*
/: %13
1
0
0: %13
'
0
': %13
atof
(
): %32
*
/: %13
int: %32
getop
(
char: %32
[
]
)
;: %13
void: %32
push
(
double
)
;: %13
double: %32
pop
(
void
)
;: %13
/
*: %32
reverse: %32
Polish: %32
calculator: %32
*
/: %13
main
(
): %13
{: %13
int: %32
type
;: %13
double: %32
op
2
;: %13
char: %32
s
[
MAXOP
]
;: %13
while: %32
(
(
type: %32
=: %32
getop
(
s
)
): %32
!
=: %32
EOF
): %32
{: %13
switch: %32
(
type
): %32
{: %13
case: %32
NUMBER
:: %13
push
(
atof
(
s
)
)
;: %13
break
;: %13
case: %32
'
+
'
:: %13
push
(
pop
(
): %32
+: %32
pop
(
)
)
;: %13
break
;: %13
case: %32
'
*
'
:: %13
push
(
pop
(
): %32
*: %32
pop
(
)
)
;: %13
break
;: %13
case: %32
'
-
'
:: %13
op
2: %32
=: %32
pop
(
)
;: %13
push
(
pop
(
): %32
-: %32
op
2
)
;: %13
break
;: %13
case: %32
'
/
'
:: %13
op
2: %32
=: %32
pop
(
)
;: %13
if: %32
(
op
2: %32
!
=: %32
0
.
0
): %13
push
(
pop
(
): %32
/: %32
op
2
)
;: %13
else: %13
printf
(
"
error
:: %32
zero: %32
divisor
\
n
"
)
;: %13
break
;: %13
case: %32
'
\
n
'
:: %13
printf
(
"
\
t
%:
.
8
g
\
n
"
,: %32
pop
(
)
)
;: %13
break
;: %13
default
:: %13
printf
(
"
error
:: %32
unknown: %32
command: %32
%:
s
\
n
"
,: %32
s
)
;: %13
break
;: %13
}: %13
}: %13
return: %32
0
;: %13
}: %13
Because: %32
+: %32
and: %32
*: %32
are: %32
commutative: %32
operators
,: %32
the: %32
order: %32
in: %32
which: %32
the: %32
popped: %32
operands: %32
are: %32
combined: %32
is: %32
irrelevant
,: %32
but: %32
for: %32
-: %32
and: %32
/: %32
the: %32
left: %32
and: %32
right: %13
Chapter: %32
4: %32
-: %32
Functions: %32
and: %32
Program: %32
Structure: %13
operand: %32
must: %32
be: %32
distinguished
.: %32
In: %13
push
(
pop
(
): %32
-: %32
pop
(
)
)
;: %13
/
*: %32
WRONG: %32
*
/: %13
the: %32
order: %32
in: %32
which: %32
the: %32
two: %32
calls: %32
of: %32
pop: %32
are: %32
evaluated: %32
is: %32
not: %32
defined
.: %32
To: %32
guarantee: %32
the: %32
right: %32
order
,: %32
it: %32
is: %32
necessary: %32
to: %32
pop: %32
the: %32
first: %32
value: %32
into: %32
a: %13
temporary: %32
variable: %32
as: %32
we: %32
did: %32
in: %32
main
.: %13
#
define: %32
MAXVAL: %13
1
0
0: %13
int: %32
sp: %32
=: %32
0
;: %13
double: %32
val
[
MAXVAL
]
;: %13
/
*: %32
maximum: %32
depth: %32
of: %32
val: %32
stack: %32
*
/: %13
/
*: %32
next: %32
free: %32
stack: %32
position: %32
*
/: %13
/
*: %32
value: %32
stack: %32
*
/: %13
/
*: %32
push
:: %32
push: %32
f: %32
onto: %32
value: %32
stack: %32
*
/: %13
void: %32
push
(
double: %32
f
): %13
{: %13
if: %32
(
sp: %32
<: %32
MAXVAL
): %13
val
[
sp
+
+
]: %32
=: %32
f
;: %13
else: %13
printf
(
"
error
:: %32
stack: %32
full
,: %32
can
'
t: %32
push: %32
%:
g
\
n
"
,: %32
f
)
;: %13
}: %13
/
*: %32
pop
:: %32
pop: %32
and: %32
return: %32
top: %32
value: %32
from: %32
stack: %32
*
/: %13
double: %32
pop
(
void
): %13
{: %13
if: %32
(
sp: %32
>: %32
0
): %13
return: %32
val
[
-
-
sp
]
;: %13
else: %32
{: %13
printf
(
"
error
:: %32
stack: %32
empty
\
n
"
)
;: %13
return: %32
0
.
0
;: %13
}: %13
}: %13
A: %32
variable: %32
is: %32
external: %32
if: %32
it: %32
is: %32
defined: %32
outside: %32
of: %32
any: %32
function
.: %32
Thus: %32
the: %32
stack: %32
and: %32
stack: %32
index: %32
that: %32
must: %32
be: %32
shared: %32
by: %32
push: %32
and: %32
pop: %32
are: %32
defined: %13
outside: %32
these: %32
functions
.: %32
But: %32
main: %32
itself: %32
does: %32
not: %32
refer: %32
to: %32
the: %32
stack: %32
or: %32
stack: %32
position: %32
-: %32
the: %32
representation: %32
can: %32
be: %32
hidden
.: %13
Let: %32
us: %32
now: %32
turn: %32
to: %32
the: %32
implementation: %32
of: %32
getop
,: %32
the: %32
function: %32
that: %32
fetches: %32
the: %32
next: %32
operator: %32
or: %32
operand
.: %32
The: %32
task: %32
is: %32
easy
.: %32
Skip: %32
blanks: %32
and: %32
tabs
.: %32
If: %13
the: %32
next: %32
character: %32
is: %32
not: %32
a: %32
digit: %32
or: %32
a: %32
hexadecimal: %32
point
,: %32
return: %32
it
.: %32
Otherwise
,: %32
collect: %32
a: %32
string: %32
of: %32
digits: %32
(
which: %32
might: %32
include: %32
a: %32
decimal: %32
point
)
,: %32
and: %13
return: %32
NUMBER
,: %32
the: %32
signal: %32
that: %32
a: %32
number: %32
has: %32
been: %32
collected
.: %13
#
include: %32
<
ctype
.
h
>: %13
int: %32
getch
(
void
)
;: %13
void: %32
ungetch
(
int
)
;: %13
/
*: %32
getop
:: %32
get: %32
next: %32
character: %32
or: %32
numeric: %32
operand: %32
*
/: %13
int: %32
getop
(
char: %32
s
[
]
): %13
{: %13
int: %32
i
,: %32
c
;: %13
while: %32
(
(
s
[
0
]: %32
=: %32
c: %32
=: %32
getch
(
)
): %32
=
=: %32
': %32
': %32
|
|: %32
c: %32
=
=: %32
'
\
t
'
): %13
;: %13
s
[
1
]: %32
=: %32
'
\
0
'
;: %13
if: %32
(
!
isdigit
(
c
): %32
&
&: %32
c: %32
!
=: %32
'
.
'
): %13
return: %32
c
;: %13
/
*: %32
not: %32
a: %32
number: %32
*
/: %13
i: %32
=: %32
0
;: %13
if: %32
(
isdigit
(
c
)
): %13
/
*: %32
collect: %32
integer: %32
part: %32
*
/: %13
while: %32
(
isdigit
(
s
[
+
+
i
]: %32
=: %32
c: %32
=: %32
getch
(
)
)
): %13
;: %13
if: %32
(
c: %32
=
=: %32
'
.
'
): %13
/
*: %32
collect: %32
fraction: %32
part: %32
*
/: %13
while: %32
(
isdigit
(
s
[
+
+
i
]: %32
=: %32
c: %32
=: %32
getch
(
)
)
): %13
Chapter: %32
4: %32
-: %32
Functions: %32
and: %32
Program: %32
Structure: %13
;: %13
s
[
i
]: %32
=: %32
'
\
0
'
;: %13
if: %32
(
c: %32
!
=: %32
EOF
): %13
ungetch
(
c
)
;: %13
return: %32
NUMBER
;: %13
}: %13
What: %32
are: %32
getch: %32
and: %32
ungetch
?: %32
It: %32
is: %32
often: %32
the: %32
case: %32
that: %32
a: %32
program: %32
cannot: %32
determine: %32
that: %32
it: %32
has: %32
read: %32
enough: %32
input: %32
until: %32
it: %32
has: %32
read: %32
too: %32
much
.: %32
One: %13
instance: %32
is: %32
collecting: %32
characters: %32
that: %32
make: %32
up: %32
a: %32
number
:: %32
until: %32
the: %32
first: %32
non
-
digit: %32
is: %32
seen
,: %32
the: %32
number: %32
is: %32
not: %32
complete
.: %32
But: %32
then: %32
the: %32
program: %32
has: %13
read: %32
one: %32
character: %32
too: %32
far
,: %32
a: %32
character: %32
that: %32
it: %32
is: %32
not: %32
prepared: %32
for
.: %13
The: %32
problem: %32
would: %32
be: %32
solved: %32
if: %32
it: %32
were: %32
possible: %32
to: %32
`
`
un
-
read
'
': %32
the: %32
unwanted: %32
character
.: %32
Then
,: %32
every: %32
time: %32
the: %32
program: %32
reads: %32
one: %32
character: %32
too: %13
many
,: %32
it: %32
could: %32
push: %32
it: %32
back: %32
on: %32
the: %32
input
,: %32
so: %32
the: %32
rest: %32
of: %32
the: %32
code: %32
could: %32
behave: %32
as: %32
if: %32
it: %32
had: %32
never: %32
been: %32
read
.: %32
Fortunately
,: %32
it
'
s: %32
easy: %32
to: %32
simulate: %32
un
-: %13
getting: %32
a: %32
character
,: %32
by: %32
writing: %32
a: %32
pair: %32
of: %32
cooperating: %32
functions
.: %32
getch: %32
delivers: %32
the: %32
next: %32
input: %32
character: %32
to: %32
be: %32
considered
;: %32
ungetch: %32
will: %32
return: %13
them: %32
before: %32
reading: %32
new: %32
input
.: %13
How: %32
they: %32
work: %32
together: %32
is: %32
simple
.: %32
ungetch: %32
puts: %32
the: %32
pushed
-
back: %32
characters: %32
into: %32
a: %32
shared: %32
buffer: %32
-
-: %32
a: %32
character: %32
array
.: %32
getch: %32
reads: %32
from: %32
the: %13
buffer: %32
if: %32
there: %32
is: %32
anything: %32
else
,: %32
and: %32
calls: %32
getchar: %32
if: %32
the: %32
buffer: %32
is: %32
empty
.: %32
There: %32
must: %32
also: %32
be: %32
an: %32
index: %32
variable: %32
that: %32
records: %32
the: %32
position: %32
of: %32
the: %13
current: %32
character: %32
in: %32
the: %32
buffer
.: %13
Since: %32
the: %32
buffer: %32
and: %32
the: %32
index: %32
are: %32
shared: %32
by: %32
getch: %32
and: %32
ungetch: %32
and: %32
must: %32
retain: %32
their: %32
values: %32
between: %32
calls
,: %32
they: %32
must: %32
be: %32
external: %32
to: %32
both: %13
routines
.: %32
Thus: %32
we: %32
can: %32
write: %32
getch
,: %32
ungetch
,: %32
and: %32
their: %32
shared: %32
variables: %32
as
:: %13
#
define: %32
BUFSIZE: %32
1
0
0: %13
char: %32
buf
[
BUFSIZE
]
;: %13
int: %32
bufp: %32
=: %32
0
;: %13
/
*: %32
buffer: %32
for: %32
ungetch: %32
*
/: %13
/
*: %32
next: %32
free: %32
position: %32
in: %32
buf: %32
*
/: %13
int: %32
getch
(
void
): %32
/
*: %32
get: %32
a: %32
(
possibly: %32
pushed
-
back
): %32
character: %32
*
/: %13
{: %13
return: %32
(
bufp: %32
>: %32
0
): %32
?: %32
buf
[
-
-
bufp
]: %32
:: %32
getchar
(
)
;: %13
}: %13
void: %32
ungetch
(
int: %32
c
): %13
/
*: %32
push: %32
character: %32
back: %32
on: %32
input: %32
*
/: %13
{: %13
if: %32
(
bufp: %32
>
=: %32
BUFSIZE
): %13
printf
(
"
ungetch
:: %32
too: %32
many: %32
characters
\
n
"
)
;: %13
else: %13
buf
[
bufp
+
+
]: %32
=: %32
c
;: %13
}: %13
The: %32
standard: %32
library: %32
includes: %32
a: %32
function: %32
ungetch: %32
that: %32
provides: %32
one: %32
character: %32
of: %32
pushback
;: %32
we: %32
will: %32
discuss: %32
it: %32
in: %32
Chapter: %32
7
.: %32
We: %32
have: %32
used: %32
an: %13
array: %32
for: %32
the: %32
pushback
,: %32
rather: %32
than: %32
a: %32
single: %32
character
,: %32
to: %32
illustrate: %32
a: %32
more: %32
general: %32
approach
.: %13
Exercise: %32
4
-
3
.: %32
Given: %32
the: %32
basic: %32
framework
,: %32
it
'
s: %32
straightforward: %32
to: %32
extend: %32
the: %32
calculator
.: %32
Add: %32
the: %32
modulus: %32
(
%:
): %32
operator: %32
and: %32
provisions: %32
for: %32
negative: %13
numbers
.: %13
Exercise: %32
4
-
4
.: %32
Add: %32
the: %32
commands: %32
to: %32
print: %32
the: %32
top: %32
elements: %32
of: %32
the: %32
stack: %32
without: %32
popping
,: %32
to: %32
duplicate: %32
it
,: %32
and: %32
to: %32
swap: %32
the: %32
top: %32
two: %32
elements
.: %32
Add: %32
a: %13
command: %32
to: %32
clear: %32
the: %32
stack
.: %13
Exercise: %32
4
-
5
.: %32
Add: %32
access: %32
to: %32
library: %32
functions: %32
like: %32
sin
,: %32
exp
,: %32
and: %32
pow
.: %32
See: %32
<
math
.
h
>: %32
in: %32
Appendix: %32
B
,: %32
Section: %32
4
.: %13
Exercise: %32
4
-
6
.: %32
Add: %32
commands: %32
for: %32
handling: %32
variables
.: %32
(
It
'
s: %32
easy: %32
to: %32
provide: %32
twenty
-
six: %32
variables: %32
with: %32
single
-
letter: %32
names
.
): %32
Add: %32
a: %32
variable: %32
for: %32
the: %13
most: %32
recently: %32
printed: %32
value
.: %13
Exercise: %32
4
-
7
.: %32
Write: %32
a: %32
routine: %32
ungets
(
s
): %32
that: %32
will: %32
push: %32
back: %32
an: %32
entire: %32
string: %32
onto: %32
the: %32
input
.: %32
Should: %32
ungets: %32
know: %32
about: %32
buf: %32
and: %32
bufp
,: %32
or: %13
should: %32
it: %32
just: %32
use: %32
ungetch
?: %13
Exercise: %32
4
-
8
.: %32
Suppose: %32
that: %32
there: %32
will: %32
never: %32
be: %32
more: %32
than: %32
one: %32
character: %32
of: %32
pushback
.: %32
Modify: %32
getch: %32
and: %32
ungetch: %32
accordingly
.: %13
Chapter: %32
4: %32
-: %32
Functions: %32
and: %32
Program: %32
Structure: %13
Exercise: %32
4
-
9
.: %32
Our: %32
getch: %32
and: %32
ungetch: %32
do: %32
not: %32
handle: %32
a: %32
pushed
-
back: %32
EOF: %32
correctly
.: %32
Decide: %32
what: %32
their: %32
properties: %32
ought: %32
to: %32
be: %32
if: %32
an: %32
EOF: %32
is: %13
pushed: %32
back
,: %32
then: %32
implement: %32
your: %32
design
.: %13
Exercise: %32
4
-
1
0
.: %32
An: %32
alternate: %32
organization: %32
uses: %32
getline: %32
to: %32
read: %32
an: %32
entire: %32
input: %32
line
;: %32
this: %32
makes: %32
getch: %32
and: %32
ungetch: %32
unnecessary
.: %32
Revise: %32
the: %13
calculator: %32
to: %32
use: %32
this: %32
approach
.: %13
4
.
4: %32
Scope: %32
Rules: %13
The: %32
functions: %32
and: %32
external: %32
variables: %32
that: %32
make: %32
up: %32
a: %32
C: %32
program: %32
need: %32
not: %32
all: %32
be: %32
compiled: %32
at: %32
the: %32
same: %32
time
;: %32
the: %32
source: %32
text: %32
of: %32
the: %32
program: %32
may: %32
be: %13
kept: %32
in: %32
several: %32
files
,: %32
and: %32
previously: %32
compiled: %32
routines: %32
may: %32
be: %32
loaded: %32
from: %32
libraries
.: %32
Among: %32
the: %32
questions: %32
of: %32
interest: %32
are: %13
q: %13
q: %13
q: %13
q: %13
How: %32
are: %32
declarations: %32
written: %32
so: %32
that: %32
variables: %32
are: %32
properly: %32
declared: %32
during: %32
compilation
?: %13
How: %32
are: %32
declarations: %32
arranged: %32
so: %32
that: %32
all: %32
the: %32
pieces: %32
will: %32
be: %32
properly: %32
connected: %32
when: %32
the: %32
program: %32
is: %32
loaded
?: %13
How: %32
are: %32
declarations: %32
organized: %32
so: %32
there: %32
is: %32
only: %32
one: %32
copy
?: %13
How: %32
are: %32
external: %32
variables: %32
initialized
?: %13
Let: %32
us: %32
discuss: %32
these: %32
topics: %32
by: %32
reorganizing: %32
the: %32
calculator: %32
program: %32
into: %32
several: %32
files
.: %32
As: %32
a: %32
practical: %32
matter
,: %32
the: %32
calculator: %32
is: %32
too: %32
small: %32
to: %32
be: %32
worth: %13
splitting
,: %32
but: %32
it: %32
is: %32
a: %32
fine: %32
illustration: %32
of: %32
the: %32
issues: %32
that: %32
arise: %32
in: %32
larger: %32
programs
.: %13
The: %32
scope: %32
of: %32
a: %32
name: %32
is: %32
the: %32
part: %32
of: %32
the: %32
program: %32
within: %32
which: %32
the: %32
name: %32
can: %32
be: %32
used
.: %32
For: %32
an: %32
automatic: %32
variable: %32
declared: %32
at: %32
the: %32
beginning: %32
of: %32
a: %13
function
,: %32
the: %32
scope: %32
is: %32
the: %32
function: %32
in: %32
which: %32
the: %32
name: %32
is: %32
declared
.: %32
Local: %32
variables: %32
of: %32
the: %32
same: %32
name: %32
in: %32
different: %32
functions: %32
are: %32
unrelated
.: %32
The: %32
same: %13
is: %32
true: %32
of: %32
the: %32
parameters: %32
of: %32
the: %32
function
,: %32
which: %32
are: %32
in: %32
effect: %32
local: %32
variables
.: %13
The: %32
scope: %32
of: %32
an: %32
external: %32
variable: %32
or: %32
a: %32
function: %32
lasts: %32
from: %32
the: %32
point: %32
at: %32
which: %32
it: %32
is: %32
declared: %32
to: %32
the: %32
end: %32
of: %32
the: %32
file: %32
being: %32
compiled
.: %32
For: %32
example
,: %32
if: %13
main
,: %32
sp
,: %32
val
,: %32
push
,: %32
and: %32
pop: %32
are: %32
defined: %32
in: %32
one: %32
file
,: %32
in: %32
the: %32
order: %32
shown: %32
above
,: %32
that: %32
is
,: %13
main
(
): %32
{: %32
.
.
.: %32
}: %13
int: %32
sp: %32
=: %32
0
;: %13
double: %32
val
[
MAXVAL
]
;: %13
void: %32
push
(
double: %32
f
): %32
{: %32
.
.
.: %32
}: %13
double: %32
pop
(
void
): %32
{: %32
.
.
.: %32
}: %13
then: %32
the: %32
variables: %32
sp: %32
and: %32
val: %32
may: %32
be: %32
used: %32
in: %32
push: %32
and: %32
pop: %32
simply: %32
by: %32
naming: %32
them
;: %32
no: %32
further: %32
declarations: %32
are: %32
needed
.: %32
But: %32
these: %32
names: %32
are: %13
not: %32
visible: %32
in: %32
main
,: %32
nor: %32
are: %32
push: %32
and: %32
pop: %32
themselves
.: %13
On: %32
the: %32
other: %32
hand
,: %32
if: %32
an: %32
external: %32
variable: %32
is: %32
to: %32
be: %32
referred: %32
to: %32
before: %32
it: %32
is: %32
defined
,: %32
or: %32
if: %32
it: %32
is: %32
defined: %32
in: %32
a: %32
different: %32
source: %32
file: %32
from: %32
the: %32
one: %32
where: %32
it: %13
is: %32
being: %32
used
,: %32
then: %32
an: %32
extern: %32
declaration: %32
is: %32
mandatory
.: %13
It: %32
is: %32
important: %32
to: %32
distinguish: %32
between: %32
the: %32
declaration: %32
of: %32
an: %32
external: %32
variable: %32
and: %32
its: %32
definition
.: %32
A: %32
declaration: %32
announces: %32
the: %32
properties: %32
of: %32
a: %13
variable: %32
(
primarily: %32
its: %32
type
)
;: %32
a: %32
definition: %32
also: %32
causes: %32
storage: %32
to: %32
be: %32
set: %32
aside
.: %32
If: %32
the: %32
lines: %13
int: %32
sp
;: %13
double: %32
val
[
MAXVAL
]
;: %13
appear: %32
outside: %32
of: %32
any: %32
function
,: %32
they: %32
define: %32
the: %32
external: %32
variables: %32
sp: %32
and: %32
val
,: %32
cause: %32
storage: %32
to: %32
be: %32
set: %32
aside
,: %32
and: %32
also: %32
serve: %32
as: %32
the: %32
declarations: %32
for: %13
the: %32
rest: %32
of: %32
that: %32
source: %32
file
.: %32
On: %32
the: %32
other: %32
hand
,: %32
the: %32
lines: %13
extern: %32
int: %32
sp
;: %13
extern: %32
double: %32
val
[
]
;: %13
declare: %32
for: %32
the: %32
rest: %32
of: %32
the: %32
source: %32
file: %32
that: %32
sp: %32
is: %32
an: %32
int: %32
and: %32
that: %32
val: %32
is: %32
a: %32
double: %32
array: %32
(
whose: %32
size: %32
is: %32
determined: %32
elsewhere
)
,: %32
but: %32
they: %32
do: %32
not: %13
create: %32
the: %32
variables: %32
or: %32
reserve: %32
storage: %32
for: %32
them
.: %13
Chapter: %32
4: %32
-: %32
Functions: %32
and: %32
Program: %32
Structure: %13
There: %32
must: %32
be: %32
only: %32
one: %32
definition: %32
of: %32
an: %32
external: %32
variable: %32
among: %32
all: %32
the: %32
files: %32
that: %32
make: %32
up: %32
the: %32
source: %32
program
;: %32
other: %32
files: %32
may: %32
contain: %32
extern: %13
declarations: %32
to: %32
access: %32
it
.: %32
(
There: %32
may: %32
also: %32
be: %32
extern: %32
declarations: %32
in: %32
the: %32
file: %32
containing: %32
the: %32
definition
.
): %32
Array: %32
sizes: %32
must: %32
be: %32
specified: %32
with: %32
the: %13
definition
,: %32
but: %32
are: %32
optional: %32
with: %32
an: %32
extern: %32
declaration
.: %13
Initialization: %32
of: %32
an: %32
external: %32
variable: %32
goes: %32
only: %32
with: %32
the: %32
definition
.: %13
Although: %32
it: %32
is: %32
not: %32
a: %32
likely: %32
organization: %32
for: %32
this: %32
program
,: %32
the: %32
functions: %32
push: %32
and: %32
pop: %32
could: %32
be: %32
defined: %32
in: %32
one: %32
file
,: %32
and: %32
the: %32
variables: %32
val: %32
and: %32
sp: %13
defined: %32
and: %32
initialized: %32
in: %32
another
.: %32
Then: %32
these: %32
definitions: %32
and: %32
declarations: %32
would: %32
be: %32
necessary: %32
to: %32
tie: %32
them: %32
together
:: %13
in: %32
file
1
:: %13
extern: %32
int: %32
sp
;: %13
extern: %32
double: %32
val
[
]
;: %13
void: %32
push
(
double: %32
f
): %32
{: %32
.
.
.: %32
}: %13
double: %32
pop
(
void
): %32
{: %32
.
.
.: %32
}: %13
in: %32
file
2
:: %13
int: %32
sp: %32
=: %32
0
;: %13
double: %32
val
[
MAXVAL
]
;: %13
Because: %32
the: %32
extern: %32
declarations: %32
in: %32
file
1: %32
lie: %32
ahead: %32
of: %32
and: %32
outside: %32
the: %32
function: %32
definitions
,: %32
they: %32
apply: %32
to: %32
all: %32
functions
;: %32
one: %32
set: %32
of: %32
declarations: %13
suffices: %32
for: %32
all: %32
of: %32
file
1
.: %32
This: %32
same: %32
organization: %32
would: %32
also: %32
bee: %32
needed: %32
if: %32
the: %32
definition: %32
of: %32
sp: %32
and: %32
val: %32
followed: %32
their: %32
use: %32
in: %32
one: %32
file
.: %13
4
.
5: %32
Header: %32
Files: %13
Let: %32
is: %32
now: %32
consider: %32
dividing: %32
the: %32
calculator: %32
program: %32
into: %32
several: %32
source: %32
files
,: %32
as: %32
it: %32
might: %32
be: %32
is: %32
each: %32
of: %32
the: %32
components: %32
were: %32
substantially: %32
bigger
.: %13
The: %32
main: %32
function: %32
would: %32
go: %32
in: %32
one: %32
file
,: %32
which: %32
we: %32
will: %32
call: %32
main
.
c
;: %32
push
,: %32
pop
,: %32
and: %32
their: %32
variables: %32
go: %32
into: %32
a: %32
second: %32
file
,: %32
stack
.
c
;: %32
getop: %13
goes: %32
into: %32
a: %32
third
,: %32
getop
.
c
.: %32
Finally
,: %32
getch: %32
and: %32
ungetch: %32
go: %32
into: %32
a: %32
fourth: %32
file
,: %32
getch
.
c
;: %32
we: %32
separate: %32
them: %32
from: %32
the: %32
others: %32
because: %32
they: %13
would: %32
come: %32
from: %32
a: %32
separately
-
compiled: %32
library: %32
in: %32
a: %32
realistic: %32
program
.: %13
There: %32
is: %32
one: %32
more: %32
thing: %32
to: %32
worry: %32
about: %32
-: %32
the: %32
definitions: %32
and: %32
declarations: %32
shared: %32
among: %32
files
.: %32
As: %32
much: %32
as: %32
possible
,: %32
we: %32
want: %32
to: %32
centralize: %32
this
,: %32
so: %13
that: %32
there: %32
is: %32
only: %32
one: %32
copy: %32
to: %32
get: %32
and: %32
keep: %32
right: %32
as: %32
the: %32
program: %32
evolves
.: %32
Accordingly
,: %32
we: %32
will: %32
place: %32
this: %32
common: %32
material: %32
in: %32
a: %32
header: %32
file
,: %13
calc
.
h
,: %32
which: %32
will: %32
be: %32
included: %32
as: %32
necessary
.: %32
(
The: %32
#
include: %32
line: %32
is: %32
described: %32
in: %32
Section: %32
4
.
1
1
.
): %32
The: %32
resulting: %32
program: %32
then: %32
looks: %32
like: %32
this
:: %13
Chapter: %32
4: %32
-: %32
Functions: %32
and: %32
Program: %32
Structure: %13
There: %32
is: %32
a: %32
tradeoff: %32
between: %32
the: %32
desire: %32
that: %32
each: %32
file: %32
have: %32
access: %32
only: %32
to: %32
the: %32
information: %32
it: %32
needs: %32
for: %32
its: %32
job: %32
and: %32
the: %32
practical: %32
reality: %32
that: %32
it: %32
is: %32
harder: %13
to: %32
maintain: %32
more: %32
header: %32
files
.: %32
Up: %32
to: %32
some: %32
moderate: %32
program: %32
size
,: %32
it: %32
is: %32
probably: %32
best: %32
to: %32
have: %32
one: %32
header: %32
file: %32
that: %32
contains: %32
everything: %32
that: %32
is: %32
to: %32
be: %13
shared: %32
between: %32
any: %32
two: %32
parts: %32
of: %32
the: %32
program
;: %32
that: %32
is: %32
the: %32
decision: %32
we: %32
made: %32
here
.: %32
For: %32
a: %32
much: %32
larger: %32
program
,: %32
more: %32
organization: %32
and: %32
more: %32
headers: %13
would: %32
be: %32
needed
.: %13
4
.
6: %32
Static: %32
Variables: %13
Chapter: %32
4: %32
-: %32
Functions: %32
and: %32
Program: %32
Structure: %13
The: %32
variables: %32
sp: %32
and: %32
val: %32
in: %32
stack
.
c
,: %32
and: %32
buf: %32
and: %32
bufp: %32
in: %32
getch
.
c
,: %32
are: %32
for: %32
the: %32
private: %32
use: %32
of: %32
the: %32
functions: %32
in: %32
their: %32
respective: %32
source: %32
files
,: %13
and: %32
are: %32
not: %32
meant: %32
to: %32
be: %32
accessed: %32
by: %32
anything: %32
else
.: %32
The: %32
static: %32
declaration
,: %32
applied: %32
to: %32
an: %32
external: %32
variable: %32
or: %32
function
,: %32
limits: %32
the: %32
scope: %32
of: %32
that: %13
object: %32
to: %32
the: %32
rest: %32
of: %32
the: %32
source: %32
file: %32
being: %32
compiled
.: %32
External: %32
static: %32
thus: %32
provides: %32
a: %32
way: %32
to: %32
hide: %32
names: %32
like: %32
buf: %32
and: %32
bufp: %32
in: %32
the: %32
getch
-: %13
ungetch: %32
combination
,: %32
which: %32
must: %32
be: %32
external: %32
so: %32
they: %32
can: %32
be: %32
shared
,: %32
yet: %32
which: %32
should: %32
not: %32
be: %32
visible: %32
to: %32
users: %32
of: %32
getch: %32
and: %32
ungetch
.: %13
Static: %32
storage: %32
is: %32
specified: %32
by: %32
prefixing: %32
the: %32
normal: %32
declaration: %32
with: %32
the: %32
word: %32
static
.: %32
If: %32
the: %32
two: %32
routines: %32
and: %32
the: %32
two: %32
variables: %32
are: %32
compiled: %32
in: %13
one: %32
file
,: %32
as: %32
in: %13
static: %32
char: %32
buf
[
BUFSIZE
]
;: %13
static: %32
int: %32
bufp: %32
=: %32
0
;: %13
/
*: %32
buffer: %32
for: %32
ungetch: %32
*
/: %13
/
*: %32
next: %32
free: %32
position: %32
in: %32
buf: %32
*
/: %13
int: %32
getch
(
void
): %32
{: %32
.
.
.: %32
}: %13
void: %32
ungetch
(
int: %32
c
): %32
{: %32
.
.
.: %32
}: %13
then: %32
no: %32
other: %32
routine: %32
will: %32
be: %32
able: %32
to: %32
access: %32
buf: %32
and: %32
bufp
,: %32
and: %32
those: %32
names: %32
will: %32
not: %32
conflict: %32
with: %32
the: %32
same: %32
names: %32
in: %32
other: %32
files: %32
of: %32
the: %32
same: %13
program
.: %32
In: %32
the: %32
same: %32
way
,: %32
the: %32
variables: %32
that: %32
push: %32
and: %32
pop: %32
use: %32
for: %32
stack: %32
manipulation: %32
can: %32
be: %32
hidden
,: %32
by: %32
declaring: %32
sp: %32
and: %32
val: %32
to: %32
be: %32
static
.: %13
The: %32
external: %32
static: %32
declaration: %32
is: %32
most: %32
often: %32
used: %32
for: %32
variables
,: %32
but: %32
it: %32
can: %32
be: %32
applied: %32
to: %32
functions: %32
as: %32
well
.: %32
Normally
,: %32
function: %32
names: %32
are: %32
global
,: %13
visible: %32
to: %32
any: %32
part: %32
of: %32
the: %32
entire: %32
program
.: %32
If: %32
a: %32
function: %32
is: %32
declared: %32
static
,: %32
however
,: %32
its: %32
name: %32
is: %32
invisible: %32
outside: %32
of: %32
the: %32
file: %32
in: %32
which: %32
it: %32
is: %13
declared
.: %13
The: %32
static: %32
declaration: %32
can: %32
also: %32
be: %32
applied: %32
to: %32
internal: %32
variables
.: %32
Internal: %32
static: %32
variables: %32
are: %32
local: %32
to: %32
a: %32
particular: %32
function: %32
just: %32
as: %32
automatic: %13
variables: %32
are
,: %32
but: %32
unlike: %32
automatics
,: %32
they: %32
remain: %32
in: %32
existence: %32
rather: %32
than: %32
coming: %32
and: %32
going: %32
each: %32
time: %32
the: %32
function: %32
is: %32
activated
.: %32
This: %32
means: %32
that: %13
internal: %32
static: %32
variables: %32
provide: %32
private
,: %32
permanent: %32
storage: %32
within: %32
a: %32
single: %32
function
.: %13
Exercise: %32
4
-
1
1
.: %32
Modify: %32
getop: %32
so: %32
that: %32
it: %32
doesn
'
t: %32
need: %32
to: %32
use: %32
ungetch
.: %32
Hint
:: %32
use: %32
an: %32
internal: %32
static: %32
variable
.: %13
4
.
7: %32
Register: %32
Variables: %13
A: %32
register: %32
declaration: %32
advises: %32
the: %32
compiler: %32
that: %32
the: %32
variable: %32
in: %32
question: %32
will: %32
be: %32
heavily: %32
used
.: %32
The: %32
idea: %32
is: %32
that: %32
register: %32
variables: %32
are: %32
to: %32
be: %13
placed: %32
in: %32
machine: %32
registers
,: %32
which: %32
may: %32
result: %32
in: %32
smaller: %32
and: %32
faster: %32
programs
.: %32
But: %32
compilers: %32
are: %32
free: %32
to: %32
ignore: %32
the: %32
advice
.: %13
The: %32
register: %32
declaration: %32
looks: %32
like: %13
register: %32
int: %32
x
;: %13
register: %32
char: %32
c
;: %13
and: %32
so: %32
on
.: %32
The: %32
register: %32
declaration: %32
can: %32
only: %32
be: %32
applied: %32
to: %32
automatic: %32
variables: %32
and: %32
to: %32
the: %32
formal: %32
parameters: %32
of: %32
a: %32
function
.: %32
In: %32
this: %32
later: %32
case
,: %32
it: %13
looks: %32
like: %13
f
(
register: %32
unsigned: %32
m
,: %32
register: %32
long: %32
n
): %13
{: %13
register: %32
int: %32
i
;: %13
.
.
.: %13
}: %13
In: %32
practice
,: %32
there: %32
are: %32
restrictions: %32
on: %32
register: %32
variables
,: %32
reflecting: %32
the: %32
realities: %32
of: %32
underlying: %32
hardware
.: %32
Only: %32
a: %32
few: %32
variables: %32
in: %32
each: %32
function: %32
may: %13
be: %32
kept: %32
in: %32
registers
,: %32
and: %32
only: %32
certain: %32
types: %32
are: %32
allowed
.: %32
Excess: %32
register: %32
declarations: %32
are: %32
harmless
,: %32
however
,: %32
since: %32
the: %32
word: %32
register: %32
is: %32
ignored: %13
for: %32
excess: %32
or: %32
disallowed: %32
declarations
.: %32
And: %32
it: %32
is: %32
not: %32
possible: %32
to: %32
take: %32
the: %32
address: %32
of: %32
a: %32
register: %32
variable: %32
(
a: %32
topic: %32
covered: %32
in: %32
Chapter: %32
5
)
,: %32
regardless: %32
of: %13
whether: %32
the: %32
variable: %32
is: %32
actually: %32
placed: %32
in: %32
a: %32
register
.: %32
The: %32
specific: %32
restrictions: %32
on: %32
number: %32
and: %32
types: %32
of: %32
register: %32
variables: %32
vary: %32
from: %32
machine: %32
to: %13
machine
.: %13
4
.
8: %32
Block: %32
Structure: %13
C: %32
is: %32
not: %32
a: %32
block
-
structured: %32
language: %32
in: %32
the: %32
sense: %32
of: %32
Pascal: %32
or: %32
similar: %32
languages
,: %32
because: %32
functions: %32
may: %32
not: %32
be: %32
defined: %32
within: %32
other: %32
functions
.: %32
On: %13
Chapter: %32
4: %32
-: %32
Functions: %32
and: %32
Program: %32
Structure: %13
the: %32
other: %32
hand
,: %32
variables: %32
can: %32
be: %32
defined: %32
in: %32
a: %32
block
-
structured: %32
fashion: %32
within: %32
a: %32
function
.: %32
Declarations: %32
of: %32
variables: %32
(
including: %32
initializations
): %32
may: %13
follow: %32
the: %32
left: %32
brace: %32
that: %32
introduces: %32
any: %32
compound: %32
statement
,: %32
not: %32
just: %32
the: %32
one: %32
that: %32
begins: %32
a: %32
function
.: %32
Variables: %32
declared: %32
in: %32
this: %32
way: %32
hide: %32
any: %13
identically: %32
named: %32
variables: %32
in: %32
outer: %32
blocks
,: %32
and: %32
remain: %32
in: %32
existence: %32
until: %32
the: %32
matching: %32
right: %32
brace
.: %32
For: %32
example
,: %32
in: %13
if: %32
(
n: %32
>: %32
0
): %32
{: %13
int: %32
i
;: %32
/
*: %32
declare: %32
a: %32
new: %32
i: %32
*
/: %13
for: %32
(
i: %32
=: %32
0
;: %32
i: %32
<: %32
n
;: %32
i
+
+
): %13
.
.
.: %13
}: %13
the: %32
scope: %32
of: %32
the: %32
variable: %32
i: %32
is: %32
the: %32
`
`
true
'
': %32
branch: %32
of: %32
the: %32
if
;: %32
this: %32
i: %32
is: %32
unrelated: %32
to: %32
any: %32
i: %32
outside: %32
the: %32
block
.: %32
An: %32
automatic: %32
variable: %32
declared: %32
and: %13
initialized: %32
in: %32
a: %32
block: %32
is: %32
initialized: %32
each: %32
time: %32
the: %32
block: %32
is: %32
entered
.: %13
Automatic: %32
variables
,: %32
including: %32
formal: %32
parameters
,: %32
also: %32
hide: %32
external: %32
variables: %32
and: %32
functions: %32
of: %32
the: %32
same: %32
name
.: %32
Given: %32
the: %32
declarations: %13
int: %32
x
;: %13
int: %32
y
;: %13
f
(
double: %32
x
): %13
{: %13
double: %32
y
;: %13
}: %13
then: %32
within: %32
the: %32
function: %32
f
,: %32
occurrences: %32
of: %32
x: %32
refer: %32
to: %32
the: %32
parameter
,: %32
which: %32
is: %32
a: %32
double
;: %32
outside: %32
f
,: %32
they: %32
refer: %32
to: %32
the: %32
external: %32
int
.: %32
The: %32
same: %32
is: %13
true: %32
of: %32
the: %32
variable: %32
y
.: %13
As: %32
a: %32
matter: %32
of: %32
style
,: %32
it
'
s: %32
best: %32
to: %32
avoid: %32
variable: %32
names: %32
that: %32
conceal: %32
names: %32
in: %32
an: %32
outer: %32
scope
;: %32
the: %32
potential: %32
for: %32
confusion: %32
and: %32
error: %32
is: %32
too: %32
great
.: %13
4
.
9: %32
Initialization: %13
Initialization: %32
has: %32
been: %32
mentioned: %32
in: %32
passing: %32
many: %32
times: %32
so: %32
far
,: %32
but: %32
always: %32
peripherally: %32
to: %32
some: %32
other: %32
topic
.: %32
This: %32
section: %32
summarizes: %32
some: %32
of: %32
the: %13
rules
,: %32
now: %32
that: %32
we: %32
have: %32
discussed: %32
the: %32
various: %32
storage: %32
classes
.: %13
In: %32
the: %32
absence: %32
of: %32
explicit: %32
initialization
,: %32
external: %32
and: %32
static: %32
variables: %32
are: %32
guaranteed: %32
to: %32
be: %32
initialized: %32
to: %32
zero
;: %32
automatic: %32
and: %32
register: %32
variables: %32
have: %13
undefined: %32
(
i
.
e
.
,: %32
garbage
): %32
initial: %32
values
.: %13
Scalar: %32
variables: %32
may: %32
be: %32
initialized: %32
when: %32
they: %32
are: %32
defined
,: %32
by: %32
following: %32
the: %32
name: %32
with: %32
an: %32
equals: %32
sign: %32
and: %32
an: %32
expression
:: %13
int: %32
x: %32
=: %32
1
;: %13
char: %32
squota: %32
=: %32
'
\
'
'
;: %13
long: %32
day: %32
=: %32
1
0
0
0
L: %32
*: %32
6
0
L: %32
*: %32
6
0
L: %32
*: %32
2
4
L
;: %32
/
*: %32
milliseconds
/
day: %32
*
/: %13
For: %32
external: %32
and: %32
static: %32
variables
,: %32
the: %32
initializer: %32
must: %32
be: %32
a: %32
constant: %32
expression
;: %32
the: %32
initialization: %32
is: %32
done: %32
once
,: %32
conceptionally: %32
before: %32
the: %32
program: %13
begins: %32
execution
.: %32
For: %32
automatic: %32
and: %32
register: %32
variables
,: %32
the: %32
initializer: %32
is: %32
not: %32
restricted: %32
to: %32
being: %32
a: %32
constant
:: %32
it: %32
may: %32
be: %32
any: %32
expression: %32
involving: %13
previously: %32
defined: %32
values
,: %32
even: %32
function: %32
calls
.: %32
For: %32
example
,: %32
the: %32
initialization: %32
of: %32
the: %32
binary: %32
search: %32
program: %32
in: %32
Section: %32
3
.
3: %32
could: %32
be: %32
written: %32
as: %13
int: %32
binsearch
(
int: %32
x
,: %32
int: %32
v
[
]
,: %32
int: %32
n
): %13
{: %13
int: %32
low: %32
=: %32
0
;: %13
int: %32
high: %32
=: %32
n: %32
-: %32
1
;: %13
int: %32
mid
;: %13
.
.
.: %13
}: %13
instead: %32
of: %13
Chapter: %32
4: %32
-: %32
Functions: %32
and: %32
Program: %32
Structure: %13
int: %32
low
,: %32
high
,: %32
mid
;: %13
low: %32
=: %32
0
;: %13
high: %32
=: %32
n: %32
-: %32
1
;: %13
In: %32
effect
,: %32
initialization: %32
of: %32
automatic: %32
variables: %32
are: %32
just: %32
shorthand: %32
for: %32
assignment: %32
statements
.: %32
Which: %32
form: %32
to: %32
prefer: %32
is: %32
largely: %32
a: %32
matter: %32
of: %32
taste
.: %32
We: %13
have: %32
generally: %32
used: %32
explicit: %32
assignments
,: %32
because: %32
initializers: %32
in: %32
declarations: %32
are: %32
harder: %32
to: %32
see: %32
and: %32
further: %32
away: %32
from: %32
the: %32
point: %32
of: %32
use
.: %13
An: %32
array: %32
may: %32
be: %32
initialized: %32
by: %32
following: %32
its: %32
declaration: %32
with: %32
a: %32
list: %32
of: %32
initializers: %32
enclosed: %32
in: %32
braces: %32
and: %32
separated: %32
by: %32
commas
.: %32
For: %32
example
,: %32
to: %13
initialize: %32
an: %32
array: %32
days: %32
with: %32
the: %32
number: %32
of: %32
days: %32
in: %32
each: %32
month
:: %13
int: %32
days
[
]: %32
=: %32
{: %32
3
1
,: %32
2
8
,: %32
3
1
,: %32
3
0
,: %32
3
1
,: %32
3
0
,: %32
3
1
,: %32
3
1
,: %32
3
0
,: %32
3
1
,: %32
3
0
,: %32
3
1: %32
}: %13
When: %32
the: %32
size: %32
of: %32
the: %32
array: %32
is: %32
omitted
,: %32
the: %32
compiler: %32
will: %32
compute: %32
the: %32
length: %32
by: %32
counting: %32
the: %32
initializers
,: %32
of: %32
which: %32
there: %32
are: %32
1
2: %32
in: %32
this: %32
case
.: %13
If: %32
there: %32
are: %32
fewer: %32
initializers: %32
for: %32
an: %32
array: %32
than: %32
the: %32
specified: %32
size
,: %32
the: %32
others: %32
will: %32
be: %32
zero: %32
for: %32
external
,: %32
static: %32
and: %32
automatic: %32
variables
.: %32
It: %32
is: %32
an: %32
error: %32
to: %13
have: %32
too: %32
many: %32
initializers
.: %32
There: %32
is: %32
no: %32
way: %32
to: %32
specify: %32
repetition: %32
of: %32
an: %32
initializer
,: %32
nor: %32
to: %32
initialize: %32
an: %32
element: %32
in: %32
the: %32
middle: %32
of: %32
an: %32
array: %32
without: %13
supplying: %32
all: %32
the: %32
preceding: %32
values: %32
as: %32
well
.: %13
Character: %32
arrays: %32
are: %32
a: %32
special: %32
case: %32
of: %32
initialization
;: %32
a: %32
string: %32
may: %32
be: %32
used: %32
instead: %32
of: %32
the: %32
braces: %32
and: %32
commas: %32
notation
:: %13
char: %32
pattern: %32
=: %32
"
ould
"
;: %13
is: %32
a: %32
shorthand: %32
for: %32
the: %32
longer: %32
but: %32
equivalent: %13
char: %32
pattern
[
]: %32
=: %32
{: %32
'
o
'
,: %32
'
u
'
,: %32
'
l
'
,: %32
'
d
'
,: %32
'
\
0
': %32
}
;: %13
In: %32
this: %32
case
,: %32
the: %32
array: %32
size: %32
is: %32
five: %32
(
four: %32
characters: %32
plus: %32
the: %32
terminating: %32
'
\
0
'
)
.: %13
4
.
1
0: %32
Recursion: %13
C: %32
functions: %32
may: %32
be: %32
used: %32
recursively
;: %32
that: %32
is
,: %32
a: %32
function: %32
may: %32
call: %32
itself: %32
either: %32
directly: %32
or: %32
indirectly
.: %32
Consider: %32
printing: %32
a: %32
number: %32
as: %32
a: %32
character: %13
string
.: %32
As: %32
we: %32
mentioned: %32
before
,: %32
the: %32
digits: %32
are: %32
generated: %32
in: %32
the: %32
wrong: %32
order
:: %32
low
-
order: %32
digits: %32
are: %32
available: %32
before: %32
high
-
order: %32
digits
,: %32
but: %32
they: %32
have: %13
to: %32
be: %32
printed: %32
the: %32
other: %32
way: %32
around
.: %13
There: %32
are: %32
two: %32
solutions: %32
to: %32
this: %32
problem
.: %32
On: %32
is: %32
to: %32
store: %32
the: %32
digits: %32
in: %32
an: %32
array: %32
as: %32
they: %32
are: %32
generated
,: %32
then: %32
print: %32
them: %32
in: %32
the: %32
reverse: %32
order
,: %32
as: %32
we: %32
did: %13
with: %32
itoa: %32
in: %32
section: %32
3
.
6
.: %32
The: %32
alternative: %32
is: %32
a: %32
recursive: %32
solution
,: %32
in: %32
which: %32
printd: %32
first: %32
calls: %32
itself: %32
to: %32
cope: %32
with: %32
any: %32
leading: %32
digits
,: %32
then: %32
prints: %32
the: %13
trailing: %32
digit
.: %32
Again
,: %32
this: %32
version: %32
can: %32
fail: %32
on: %32
the: %32
largest: %32
negative: %32
number
.: %13
#
include: %32
<
stdio
.
h
>: %13
/
*: %32
printd
:: %32
print: %32
n: %32
in: %32
decimal: %32
*
/: %13
void: %32
printd
(
int: %32
n
): %13
{: %13
if: %32
(
n: %32
<: %32
0
): %32
{: %13
putchar
(
'
-
'
)
;: %13
n: %32
=: %32
-
n
;: %13
}: %13
if: %32
(
n: %32
/: %32
1
0
): %13
printd
(
n: %32
/: %32
1
0
)
;: %13
putchar
(
n: %32
%: %32
1
0: %32
+: %32
'
0
'
)
;: %13
}: %13
When: %32
a: %32
function: %32
calls: %32
itself: %32
recursively
,: %32
each: %32
invocation: %32
gets: %32
a: %32
fresh: %32
set: %32
of: %32
all: %32
the: %32
automatic: %32
variables
,: %32
independent: %32
of: %32
the: %32
previous: %32
set
.: %32
This: %32
in: %13
printd
(
1
2
3
): %32
the: %32
first: %32
printd: %32
receives: %32
the: %32
argument: %32
n: %32
=: %32
1
2
3
.: %32
It: %32
passes: %32
1
2: %32
to: %32
a: %32
second: %32
printd
,: %32
which: %32
in: %32
turn: %32
passes: %32
1: %32
to: %32
a: %32
third
.: %32
The: %13
third
-
level: %32
printd: %32
prints: %32
1
,: %32
then: %32
returns: %32
to: %32
the: %32
second: %32
level
.: %32
That: %32
printd: %32
prints: %32
2
,: %32
then: %32
returns: %32
to: %32
the: %32
first: %32
level
.: %32
That: %32
one: %32
prints: %32
3: %32
and: %13
terminates
.: %13
Chapter: %32
4: %32
-: %32
Functions: %32
and: %32
Program: %32
Structure: %13
Another: %32
good: %32
example: %32
of: %32
recursion: %32
is: %32
quicksort
,: %32
a: %32
sorting: %32
algorithm: %32
developed: %32
by: %32
C
.
A
.
R
.: %32
Hoare: %32
in: %32
1
9
6
2
.: %32
Given: %32
an: %32
array
,: %32
one: %32
element: %32
is: %32
chosen: %13
and: %32
the: %32
others: %32
partitioned: %32
in: %32
two: %32
subsets: %32
-: %32
those: %32
less: %32
than: %32
the: %32
partition: %32
element: %32
and: %32
those: %32
greater: %32
than: %32
or: %32
equal: %32
to: %32
it
.: %32
The: %32
same: %32
process: %32
is: %32
then: %13
applied: %32
recursively: %32
to: %32
the: %32
two: %32
subsets
.: %32
When: %32
a: %32
subset: %32
has: %32
fewer: %32
than: %32
two: %32
elements
,: %32
it: %32
doesn
'
t: %32
need: %32
any: %32
sorting
;: %32
this: %32
stops: %32
the: %32
recursion
.: %13
Our: %32
version: %32
of: %32
quicksort: %32
is: %32
not: %32
the: %32
fastest: %32
possible
,: %32
but: %32
it
'
s: %32
one: %32
of: %32
the: %32
simplest
.: %32
We: %32
use: %32
the: %32
middle: %32
element: %32
of: %32
each: %32
subarray: %32
for: %32
partitioning
.: %13
/
*: %32
qsort
:: %32
sort: %32
v
[
left
]
.
.
.
v
[
right
]: %32
into: %32
increasing: %32
order: %32
*
/: %13
void: %32
qsort
(
int: %32
v
[
]
,: %32
int: %32
left
,: %32
int: %32
right
): %13
{: %13
int: %32
i
,: %32
last
;: %13
void: %32
swap
(
int: %32
v
[
]
,: %32
int: %32
i
,: %32
int: %32
j
)
;: %13
if: %32
(
left: %32
>
=: %32
right
): %32
/
*: %32
do: %32
nothing: %32
if: %32
array: %32
contains: %32
*
/: %13
return
;: %13
/
*: %32
fewer: %32
than: %32
two: %32
elements: %32
*
/: %13
swap
(
v
,: %32
left
,: %32
(
left: %32
+: %32
right
)
/
2
)
;: %32
/
*: %32
move: %32
partition: %32
elem: %32
*
/: %13
last: %32
=: %32
left
;: %13
/
*: %32
to: %32
v
[
0
]: %32
*
/: %13
for: %32
(
i: %32
=: %32
left: %32
+: %32
1
;: %32
i: %32
<
=: %32
right
;: %32
i
+
+
): %32
/
*: %32
partition: %32
*
/: %13
if: %32
(
v
[
i
]: %32
<: %32
v
[
left
]
): %13
swap
(
v
,: %32
+
+
last
,: %32
i
)
;: %13
swap
(
v
,: %32
left
,: %32
last
)
;: %13
/
*: %32
restore: %32
partition: %32
elem: %32
*
/: %13
qsort
(
v
,: %32
left
,: %32
last
-
1
)
;: %13
qsort
(
v
,: %32
last
+
1
,: %32
right
)
;: %13
}: %13
We: %32
moved: %32
the: %32
swapping: %32
operation: %32
into: %32
a: %32
separate: %32
function: %32
swap: %32
because: %32
it: %32
occurs: %32
three: %32
times: %32
in: %32
qsort
.: %13
/
*: %32
swap
:: %32
interchange: %32
v
[
i
]: %32
and: %32
v
[
j
]: %32
*
/: %13
void: %32
swap
(
int: %32
v
[
]
,: %32
int: %32
i
,: %32
int: %32
j
): %13
{: %13
int: %32
temp
;: %13
temp: %32
=: %32
v
[
i
]
;: %13
v
[
i
]: %32
=: %32
v
[
j
]
;: %13
v
[
j
]: %32
=: %32
temp
;: %13
}: %13
The: %32
standard: %32
library: %32
includes: %32
a: %32
version: %32
of: %32
qsort: %32
that: %32
can: %32
sort: %32
objects: %32
of: %32
any: %32
type
.: %13
Recursion: %32
may: %32
provide: %32
no: %32
saving: %32
in: %32
storage
,: %32
since: %32
somewhere: %32
a: %32
stack: %32
of: %32
the: %32
values: %32
being: %32
processed: %32
must: %32
be: %32
maintained
.: %32
Nor: %32
will: %32
it: %32
be: %32
faster
.: %32
But: %13
recursive: %32
code: %32
is: %32
more: %32
compact
,: %32
and: %32
often: %32
much: %32
easier: %32
to: %32
write: %32
and: %32
understand: %32
than: %32
the: %32
non
-
recursive: %32
equivalent
.: %32
Recursion: %32
is: %32
especially: %13
convenient: %32
for: %32
recursively: %32
defined: %32
data: %32
structures: %32
like: %32
trees
,: %32
we: %32
will: %32
see: %32
a: %32
nice: %32
example: %32
in: %32
Section: %32
6
.
6
.: %13
Exercise: %32
4
-
1
2
.: %32
Adapt: %32
the: %32
ideas: %32
of: %32
printd: %32
to: %32
write: %32
a: %32
recursive: %32
version: %32
of: %32
itoa
;: %32
that: %32
is
,: %32
convert: %32
an: %32
integer: %32
into: %32
a: %32
string: %32
by: %32
calling: %32
a: %32
recursive: %13
routine
.: %13
Exercise: %32
4
-
1
3
.: %32
Write: %32
a: %32
recursive: %32
version: %32
of: %32
the: %32
function: %32
reverse
(
s
)
,: %32
which: %32
reverses: %32
the: %32
string: %32
s: %32
in: %32
place
.: %13
4
.
1
1: %32
The: %32
C: %32
Preprocessor: %13
C: %32
provides: %32
certain: %32
language: %32
facilities: %32
by: %32
means: %32
of: %32
a: %32
preprocessor
,: %32
which: %32
is: %32
conceptionally: %32
a: %32
separate: %32
first: %32
step: %32
in: %32
compilation
.: %32
The: %32
two: %32
most: %13
frequently: %32
used: %32
features: %32
are: %32
#
include
,: %32
to: %32
include: %32
the: %32
contents: %32
of: %32
a: %32
file: %32
during: %32
compilation
,: %32
and: %32
#
define
,: %32
to: %32
replace: %32
a: %32
token: %32
by: %32
an: %32
arbitrary: %13
sequence: %32
of: %32
characters
.: %32
Other: %32
features: %32
described: %32
in: %32
this: %32
section: %32
include: %32
conditional: %32
compilation: %32
and: %32
macros: %32
with: %32
arguments
.: %13
4
.
1
1
.
1: %32
File: %32
Inclusion: %13
File: %32
inclusion: %32
makes: %32
it: %32
easy: %32
to: %32
handle: %32
collections: %32
of: %32
#
defines: %32
and: %32
declarations: %32
(
among: %32
other: %32
things
)
.: %32
Any: %32
source: %32
line: %32
of: %32
the: %32
form: %13
Chapter: %32
4: %32
-: %32
Functions: %32
and: %32
Program: %32
Structure: %13
#
include: %32
"
filename
": %13
or: %13
#
include: %32
<
filename
>: %13
is: %32
replaced: %32
by: %32
the: %32
contents: %32
of: %32
the: %32
file: %32
filename
.: %32
If: %32
the: %32
filename: %32
is: %32
quoted
,: %32
searching: %32
for: %32
the: %32
file: %32
typically: %32
begins: %32
where: %32
the: %32
source: %32
program: %32
was: %13
found
;: %32
if: %32
it: %32
is: %32
not: %32
found: %32
there
,: %32
or: %32
if: %32
the: %32
name: %32
is: %32
enclosed: %32
in: %32
<: %32
and: %32
>
,: %32
searching: %32
follows: %32
an: %32
implementation
-
defined: %32
rule: %32
to: %32
find: %32
the: %32
file
.: %32
An: %32
included: %13
file: %32
may: %32
itself: %32
contain: %32
#
include: %32
lines
.: %13
There: %32
are: %32
often: %32
several: %32
#
include: %32
lines: %32
at: %32
the: %32
beginning: %32
of: %32
a: %32
source: %32
file
,: %32
to: %32
include: %32
common: %32
#
define: %32
statements: %32
and: %32
extern: %32
declarations
,: %32
or: %13
to: %32
access: %32
the: %32
function: %32
prototype: %32
declarations: %32
for: %32
library: %32
functions: %32
from: %32
headers: %32
like: %32
<
stdio
.
h
>
.: %32
(
Strictly: %32
speaking
,: %32
these: %32
need: %32
not: %32
be: %32
files
;: %32
the: %13
details: %32
of: %32
how: %32
headers: %32
are: %32
accessed: %32
are: %32
implementation
-
dependent
.
): %13
#
include: %32
is: %32
the: %32
preferred: %32
way: %32
to: %32
tie: %32
the: %32
declarations: %32
together: %32
for: %32
a: %32
large: %32
program
.: %32
It: %32
guarantees: %32
that: %32
all: %32
the: %32
source: %32
files: %32
will: %32
be: %32
supplied: %32
with: %32
the: %13
same: %32
definitions: %32
and: %32
variable: %32
declarations
,: %32
and: %32
thus: %32
eliminates: %32
a: %32
particularly: %32
nasty: %32
kind: %32
of: %32
bug
.: %32
Naturally
,: %32
when: %32
an: %32
included: %32
file: %32
is: %32
changed
,: %32
all: %13
files: %32
that: %32
depend: %32
on: %32
it: %32
must: %32
be: %32
recompiled
.: %13
4
.
1
1
.
2: %32
Macro: %32
Substitution: %13
A: %32
definition: %32
has: %32
the: %32
form: %13
#
define: %32
name: %32
replacement: %32
text: %13
It: %32
calls: %32
for: %32
a: %32
macro: %32
substitution: %32
of: %32
the: %32
simplest: %32
kind: %32
-: %32
subsequent: %32
occurrences: %32
of: %32
the: %32
token: %32
name: %32
will: %32
be: %32
replaced: %32
by: %32
the: %32
replacement: %32
text
.: %32
The: %13
name: %32
in: %32
a: %32
#
define: %32
has: %32
the: %32
same: %32
form: %32
as: %32
a: %32
variable: %32
name
;: %32
the: %32
replacement: %32
text: %32
is: %32
arbitrary
.: %32
Normally: %32
the: %32
replacement: %32
text: %32
is: %32
the: %32
rest: %32
of: %32
the: %32
line
,: %13
but: %32
a: %32
long: %32
definition: %32
may: %32
be: %32
continued: %32
onto: %32
several: %32
lines: %32
by: %32
placing: %32
a: %32
\: %32
at: %32
the: %32
end: %32
of: %32
each: %32
line: %32
to: %32
be: %32
continued
.: %32
The: %32
scope: %32
of: %32
a: %32
name: %32
defined: %32
with: %13
#
define: %32
is: %32
from: %32
its: %32
point: %32
of: %32
definition: %32
to: %32
the: %32
end: %32
of: %32
the: %32
source: %32
file: %32
being: %32
compiled
.: %32
A: %32
definition: %32
may: %32
use: %32
previous: %32
definitions
.: %32
Substitutions: %32
are: %13
made: %32
only: %32
for: %32
tokens
,: %32
and: %32
do: %32
not: %32
take: %32
place: %32
within: %32
quoted: %32
strings
.: %32
For: %32
example
,: %32
if: %32
YES: %32
is: %32
a: %32
defined: %32
name
,: %32
there: %32
would: %32
be: %32
no: %32
substitution: %32
in: %13
printf
(
"
YES
"
): %32
or: %32
in: %32
YESMAN
.: %13
Any: %32
name: %32
may: %32
be: %32
defined: %32
with: %32
any: %32
replacement: %32
text
.: %32
For: %32
example: %13
#
define: %13
forever: %13
for: %32
(
;
;
): %13
/
*: %32
infinite: %32
loop: %32
*
/: %13
defines: %32
a: %32
new: %32
word
,: %32
forever
,: %32
for: %32
an: %32
infinite: %32
loop
.: %13
It: %32
is: %32
also: %32
possible: %32
to: %32
define: %32
macros: %32
with: %32
arguments
,: %32
so: %32
the: %32
replacement: %32
text: %32
can: %32
be: %32
different: %32
for: %32
different: %32
calls: %32
of: %32
the: %32
macro
.: %32
As: %32
an: %32
example
,: %32
define: %13
a: %32
macro: %32
called: %32
max
:: %13
#
define: %13
max
(
A
,: %32
B
): %13
(
(
A
): %32
>: %32
(
B
): %32
?: %32
(
A
): %32
:: %32
(
B
)
): %13
Although: %32
it: %32
looks: %32
like: %32
a: %32
function: %32
call
,: %32
a: %32
use: %32
of: %32
max: %32
expands: %32
into: %32
in
-
line: %32
code
.: %32
Each: %32
occurrence: %32
of: %32
a: %32
formal: %32
parameter: %32
(
here: %32
A: %32
or: %32
B
): %32
will: %32
be: %13
replaced: %32
by: %32
the: %32
corresponding: %32
actual: %32
argument
.: %32
Thus: %32
the: %32
line: %13
x: %32
=: %32
max
(
p
+
q
,: %32
r
+
s
)
;: %13
will: %32
be: %32
replaced: %32
by: %32
the: %32
line: %13
x: %32
=: %32
(
(
p
+
q
): %32
>: %32
(
r
+
s
): %32
?: %32
(
p
+
q
): %32
:: %32
(
r
+
s
)
)
;: %13
So: %32
long: %32
as: %32
the: %32
arguments: %32
are: %32
treated: %32
consistently
,: %32
this: %32
macro: %32
will: %32
serve: %32
for: %32
any: %32
data: %32
type
;: %32
there: %32
is: %32
no: %32
need: %32
for: %32
different: %32
kinds: %32
of: %32
max: %32
for: %32
different: %13
data: %32
types
,: %32
as: %32
there: %32
would: %32
be: %32
with: %32
functions
.: %13
If: %32
you: %32
examine: %32
the: %32
expansion: %32
of: %32
max
,: %32
you: %32
will: %32
notice: %32
some: %32
pitfalls
.: %32
The: %32
expressions: %32
are: %32
evaluated: %32
twice
;: %32
this: %32
is: %32
bad: %32
if: %32
they: %32
involve: %32
side: %32
effects: %13
like: %32
increment: %32
operators: %32
or: %32
input: %32
and: %32
output
.: %32
For: %32
instance: %13
Chapter: %32
4: %32
-: %32
Functions: %32
and: %32
Program: %32
Structure: %13
max
(
i
+
+
,: %32
j
+
+
): %13
/
*: %32
WRONG: %32
*
/: %13
will: %32
increment: %32
the: %32
larger: %32
twice
.: %32
Some: %32
care: %32
also: %32
has: %32
to: %32
be: %32
taken: %32
with: %32
parentheses: %32
to: %32
make: %32
sure: %32
the: %32
order: %32
of: %32
evaluation: %32
is: %32
preserved
;: %32
consider: %32
what: %13
happens: %32
when: %32
the: %32
macro: %13
#
define: %32
square
(
x
): %13
x: %32
*: %32
x: %13
/
*: %32
WRONG: %32
*
/: %13
is: %32
invoked: %32
as: %32
square
(
z
+
1
)
.: %13
Nonetheless
,: %32
macros: %32
are: %32
valuable
.: %32
One: %32
practical: %32
example: %32
comes: %32
from: %32
<
stdio
.
h
>
,: %32
in: %32
which: %32
getchar: %32
and: %32
putchar: %32
are: %32
often: %32
defined: %32
as: %13
macros: %32
to: %32
avoid: %32
the: %32
run
-
time: %32
overhead: %32
of: %32
a: %32
function: %32
call: %32
per: %32
character: %32
processed
.: %32
The: %32
functions: %32
in: %32
<
ctype
.
h
>: %32
are: %32
also: %32
usually: %32
implemented: %32
as: %13
macros
.: %13
Names: %32
may: %32
be: %32
undefined: %32
with: %32
#
undef
,: %32
usually: %32
to: %32
ensure: %32
that: %32
a: %32
routine: %32
is: %32
really: %32
a: %32
function
,: %32
not: %32
a: %32
macro
:: %13
#
undef: %32
getchar: %13
int: %32
getchar
(
void
): %32
{: %32
.
.
.: %32
}: %13
Formal: %32
parameters: %32
are: %32
not: %32
replaced: %32
within: %32
quoted: %32
strings
.: %32
If
,: %32
however
,: %32
a: %32
parameter: %32
name: %32
is: %32
preceded: %32
by: %32
a: %32
#: %32
in: %32
the: %32
replacement: %32
text
,: %32
the: %13
combination: %32
will: %32
be: %32
expanded: %32
into: %32
a: %32
quoted: %32
string: %32
with: %32
the: %32
parameter: %32
replaced: %32
by: %32
the: %32
actual: %32
argument
.: %32
This: %32
can: %32
be: %32
combined: %32
with: %32
string: %13
concatenation: %32
to: %32
make
,: %32
for: %32
example
,: %32
a: %32
debugging: %32
print: %32
macro
:: %13
#
define: %13
dprint
(
expr
): %13
printf
(
#
expr: %32
": %32
=: %32
%:
g
\
n
"
,: %32
expr
): %13
When: %32
this: %32
is: %32
invoked
,: %32
as: %32
in: %13
dprint
(
x
/
y
): %13
the: %32
macro: %32
is: %32
expanded: %32
into: %13
printf
(
"
x
/
y
": %32
": %32
=: %32
&
g
\
n
"
,: %32
x
/
y
)
;: %13
and: %32
the: %32
strings: %32
are: %32
concatenated
,: %32
so: %32
the: %32
effect: %32
is: %13
printf
(
"
x
/
y: %32
=: %32
&
g
\
n
"
,: %32
x
/
y
)
;: %13
Within: %32
the: %32
actual: %32
argument
,: %32
each: %32
": %32
is: %32
replaced: %32
by: %32
\
": %32
and: %32
each: %32
\: %32
by: %32
\
\
,: %32
so: %32
the: %32
result: %32
is: %32
a: %32
legal: %32
string: %32
constant
.: %13
The: %32
preprocessor: %32
operator: %32
#
#: %32
provides: %32
a: %32
way: %32
to: %32
concatenate: %32
actual: %32
arguments: %32
during: %32
macro: %32
expansion
.: %32
If: %32
a: %32
parameter: %32
in: %32
the: %32
replacement: %32
text: %32
is: %13
adjacent: %32
to: %32
a: %32
#
#
,: %32
the: %32
parameter: %32
is: %32
replaced: %32
by: %32
the: %32
actual: %32
argument
,: %32
the: %32
#
#: %32
and: %32
surrounding: %32
white: %32
space: %32
are: %32
removed
,: %32
and: %32
the: %32
result: %32
is: %32
re
-
scanned
.: %13
For: %32
example
,: %32
the: %32
macro: %32
paste: %32
concatenates: %32
its: %32
two: %32
arguments
:: %13
#
define: %13
paste
(
front
,: %32
back
): %13
front: %32
#
#: %32
back: %13
so: %32
paste
(
name
,: %32
1
): %32
creates: %32
the: %32
token: %32
name
1
.: %13
The: %32
rules: %32
for: %32
nested: %32
uses: %32
of: %32
#
#: %32
are: %32
arcane
;: %32
further: %32
details: %32
may: %32
be: %32
found: %32
in: %32
Appendix: %32
A
.: %13
Exercise: %32
4
-
1
4
.: %32
Define: %32
a: %32
macro: %32
swap
(
t
,
x
,
y
): %32
that: %32
interchanges: %32
two: %32
arguments: %32
of: %32
type: %32
t
.: %32
(
Block: %32
structure: %32
will: %32
help
.
): %13
4
.
1
1
.
3: %32
Conditional: %32
Inclusion: %13
It: %32
is: %32
possible: %32
to: %32
control: %32
preprocessing: %32
itself: %32
with: %32
conditional: %32
statements: %32
that: %32
are: %32
evaluated: %32
during: %32
preprocessing
.: %32
This: %32
provides: %32
a: %32
way: %32
to: %32
include: %13
code: %32
selectively
,: %32
depending: %32
on: %32
the: %32
value: %32
of: %32
conditions: %32
evaluated: %32
during: %32
compilation
.: %13
The: %32
#
if: %32
line: %32
evaluates: %32
a: %32
constant: %32
integer: %32
expression: %32
(
which: %32
may: %32
not: %32
include: %32
sizeof
,: %32
casts
,: %32
or: %32
enum: %32
constants
)
.: %32
If: %32
the: %32
expression: %32
is: %32
non
-
zero
,: %13
Chapter: %32
4: %32
-: %32
Functions: %32
and: %32
Program: %32
Structure: %13
subsequent: %32
lines: %32
until: %32
an: %32
#
endif: %32
or: %32
#
elif: %32
or: %32
#
else: %32
are: %32
included
.: %32
(
The: %32
preprocessor: %32
statement: %32
#
elif: %32
is: %32
like: %32
else
-
if
.
): %32
The: %32
expression: %13
defined
(
name
): %32
in: %32
a: %32
#
if: %32
is: %32
1: %32
if: %32
the: %32
name: %32
has: %32
been: %32
defined
,: %32
and: %32
0: %32
otherwise
.: %13
For: %32
example
,: %32
to: %32
make: %32
sure: %32
that: %32
the: %32
contents: %32
of: %32
a: %32
file: %32
hdr
.
h: %32
are: %32
included: %32
only: %32
once
,: %32
the: %32
contents: %32
of: %32
the: %32
file: %32
are: %32
surrounded: %32
with: %32
a: %32
conditional: %32
like: %13
this
:: %13
#
if: %32
!
defined
(
HDR
): %13
#
define: %32
HDR: %13
/
*: %32
contents: %32
of: %32
hdr
.
h: %32
go: %32
here: %32
*
/: %13
#
endif: %13
The: %32
first: %32
inclusion: %32
of: %32
hdr
.
h: %32
defines: %32
the: %32
name: %32
HDR
;: %32
subsequent: %32
inclusions: %32
will: %32
find: %32
the: %32
name: %32
defined: %32
and: %32
skip: %32
down: %32
to: %32
the: %32
#
endif
.: %32
A: %32
similar: %13
style: %32
can: %32
be: %32
used: %32
to: %32
avoid: %32
including: %32
files: %32
multiple: %32
times
.: %32
If: %32
this: %32
style: %32
is: %32
used: %32
consistently
,: %32
then: %32
each: %32
header: %32
can: %32
itself: %32
include: %32
any: %32
other: %32
headers: %32
on: %13
which: %32
it: %32
depends
,: %32
without: %32
the: %32
user: %32
of: %32
the: %32
header: %32
having: %32
to: %32
deal: %32
with: %32
the: %32
interdependence
.: %13
This: %32
sequence: %32
tests: %32
the: %32
name: %32
SYSTEM: %32
to: %32
decide: %32
which: %32
version: %32
of: %32
a: %32
header: %32
to: %32
include
:: %13
#
if: %32
SYSTEM: %32
=
=: %32
SYSV: %13
#
define: %32
HDR: %32
"
sysv
.
h
": %13
#
elif: %32
SYSTEM: %32
=
=: %32
BSD: %13
#
define: %32
HDR: %32
"
bsd
.
h
": %13
#
elif: %32
SYSTEM: %32
=
=: %32
MSDOS: %13
#
define: %32
HDR: %32
"
msdos
.
h
": %13
#
else: %13
#
define: %32
HDR: %32
"
default
.
h
": %13
#
endif: %13
#
include: %32
HDR: %13
The: %32
#
ifdef: %32
and: %32
#
ifndef: %32
lines: %32
are: %32
specialized: %32
forms: %32
that: %32
test: %32
whether: %32
a: %32
name: %32
is: %32
defined
.: %32
The: %32
first: %32
example: %32
of: %32
#
if: %32
above: %32
could: %32
have: %32
been: %13
written: %13
#
ifndef: %32
HDR: %13
#
define: %32
HDR: %13
/
*: %32
contents: %32
of: %32
hdr
.
h: %32
go: %32
here: %32
*
/: %13
#
endif: %13
Back: %32
to: %32
Chapter: %32
3: %32
-
-: %32
Index: %32
-
-: %32
Chapter: %32
5: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
Back: %32
to: %32
Chapter: %32
4: %32
-
-: %32
Index: %32
-
-: %32
Chapter: %32
6: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
A: %32
pointer: %32
is: %32
a: %32
variable: %32
that: %32
contains: %32
the: %32
address: %32
of: %32
a: %32
variable
.: %32
Pointers: %32
are: %32
much: %32
used: %32
in: %32
C
,: %32
partly: %32
because: %32
they: %32
are: %32
sometimes: %32
the: %32
only: %32
way: %32
to: %32
express: %32
a: %32
computation
,: %32
and: %13
partly: %32
because: %32
they: %32
usually: %32
lead: %32
to: %32
more: %32
compact: %32
and: %32
efficient: %32
code: %32
than: %32
can: %32
be: %32
obtained: %32
in: %32
other: %32
ways
.: %32
Pointers: %32
and: %32
arrays: %32
are: %32
closely: %32
related
;: %32
this: %32
chapter: %32
also: %32
explores: %13
this: %32
relationship: %32
and: %32
shows: %32
how: %32
to: %32
exploit: %32
it
.: %13
Pointers: %32
have: %32
been: %32
lumped: %32
with: %32
the: %32
goto: %32
statement: %32
as: %32
a: %32
marvelous: %32
way: %32
to: %32
create: %32
impossible
-
to
-
understand: %32
programs
.: %32
This: %32
is: %32
certainly: %32
true: %32
when: %32
they: %32
are: %32
used: %32
carelessly
,: %13
and: %32
it: %32
is: %32
easy: %32
to: %32
create: %32
pointers: %32
that: %32
point: %32
somewhere: %32
unexpected
.: %32
With: %32
discipline
,: %32
however
,: %32
pointers: %32
can: %32
also: %32
be: %32
used: %32
to: %32
achieve: %32
clarity: %32
and: %32
simplicity
.: %32
This: %32
is: %32
the: %32
aspect: %13
that: %32
we: %32
will: %32
try: %32
to: %32
illustrate
.: %13
The: %32
main: %32
change: %32
in: %32
ANSI: %32
C: %32
is: %32
to: %32
make: %32
explicit: %32
the: %32
rules: %32
about: %32
how: %32
pointers: %32
can: %32
be: %32
manipulated
,: %32
in: %32
effect: %32
mandating: %32
what: %32
good: %32
programmers: %32
already: %32
practice: %32
and: %32
good: %13
compilers: %32
already: %32
enforce
.: %32
In: %32
addition
,: %32
the: %32
type: %32
void: %32
*: %32
(
pointer: %32
to: %32
void
): %32
replaces: %32
char: %32
*: %32
as: %32
the: %32
proper: %32
type: %32
for: %32
a: %32
generic: %32
pointer
.: %13
5
.
1: %32
Pointers: %32
and: %32
Addresses: %13
Let: %32
us: %32
begin: %32
with: %32
a: %32
simplified: %32
picture: %32
of: %32
how: %32
memory: %32
is: %32
organized
.: %32
A: %32
typical: %32
machine: %32
has: %32
an: %32
array: %32
of: %32
consecutively: %32
numbered: %32
or: %32
addressed: %32
memory: %32
cells: %32
that: %32
may: %32
be: %13
manipulated: %32
individually: %32
or: %32
in: %32
contiguous: %32
groups
.: %32
One: %32
common: %32
situation: %32
is: %32
that: %32
any: %32
byte: %32
can: %32
be: %32
a: %32
char
,: %32
a: %32
pair: %32
of: %32
one
-
byte: %32
cells: %32
can: %32
be: %32
treated: %32
as: %32
a: %32
short: %32
integer
,: %32
and: %13
four: %32
adjacent: %32
bytes: %32
form: %32
a: %32
long
.: %32
A: %32
pointer: %32
is: %32
a: %32
group: %32
of: %32
cells: %32
(
often: %32
two: %32
or: %32
four
): %32
that: %32
can: %32
hold: %32
an: %32
address
.: %32
So: %32
if: %32
c: %32
is: %32
a: %32
char: %32
and: %32
p: %32
is: %32
a: %32
pointer: %32
that: %32
points: %32
to: %32
it
,: %32
we: %32
could: %13
represent: %32
the: %32
situation: %32
this: %32
way
:: %13
The: %32
unary: %32
operator: %32
&: %32
gives: %32
the: %32
address: %32
of: %32
an: %32
object
,: %32
so: %32
the: %32
statement: %13
p: %32
=: %32
&
c
;: %13
assigns: %32
the: %32
address: %32
of: %32
c: %32
to: %32
the: %32
variable: %32
p
,: %32
and: %32
p: %32
is: %32
said: %32
to: %32
`
`
point: %32
to
'
': %32
c
.: %32
The: %32
&: %32
operator: %32
only: %32
applies: %32
to: %32
objects: %32
in: %32
memory
:: %32
variables: %32
and: %32
array: %32
elements
.: %32
It: %32
cannot: %32
be: %13
applied: %32
to: %32
expressions
,: %32
constants
,: %32
or: %32
register: %32
variables
.: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
The: %32
unary: %32
operator: %32
*: %32
is: %32
the: %32
indirection: %32
or: %32
dereferencing: %32
operator
;: %32
when: %32
applied: %32
to: %32
a: %32
pointer
,: %32
it: %32
accesses: %32
the: %32
object: %32
the: %32
pointer: %32
points: %32
to
.: %32
Suppose: %32
that: %32
x: %32
and: %32
y: %32
are: %32
integers: %13
and: %32
ip: %32
is: %32
a: %32
pointer: %32
to: %32
int
.: %32
This: %32
artificial: %32
sequence: %32
shows: %32
how: %32
to: %32
declare: %32
a: %32
pointer: %32
and: %32
how: %32
to: %32
use: %32
&: %32
and: %32
*
:: %13
int: %32
x: %32
=: %32
1
,: %32
y: %32
=: %32
2
,: %32
z
[
1
0
]
;: %13
int: %32
*
ip
;: %13
/
*: %32
ip: %32
is: %32
a: %32
pointer: %32
to: %32
int: %32
*
/: %13
ip: %32
=: %32
&
x
;: %13
y: %32
=: %32
*
ip
;: %13
*
ip: %32
=: %32
0
;: %13
ip: %32
=: %32
&
z
[
0
]
;: %13
/
*: %13
/
*: %13
/
*: %13
/
*: %13
ip: %32
now: %32
points: %32
to: %32
x: %32
*
/: %13
y: %32
is: %32
now: %32
1: %32
*
/: %13
x: %32
is: %32
now: %32
0: %32
*
/: %13
ip: %32
now: %32
points: %32
to: %32
z
[
0
]: %32
*
/: %13
The: %32
declaration: %32
of: %32
x
,: %32
y
,: %32
and: %32
z: %32
are: %32
what: %32
we
'
ve: %32
seen: %32
all: %32
along
.: %32
The: %32
declaration: %32
of: %32
the: %32
pointer: %32
ip
,: %13
int: %32
*
ip
;: %13
is: %32
intended: %32
as: %32
a: %32
mnemonic
;: %32
it: %32
says: %32
that: %32
the: %32
expression: %32
*
ip: %32
is: %32
an: %32
int
.: %32
The: %32
syntax: %32
of: %32
the: %32
declaration: %32
for: %32
a: %32
variable: %32
mimics: %32
the: %32
syntax: %32
of: %32
expressions: %32
in: %32
which: %32
the: %32
variable: %13
might: %32
appear
.: %32
This: %32
reasoning: %32
applies: %32
to: %32
function: %32
declarations: %32
as: %32
well
.: %32
For: %32
example
,: %13
double: %32
*
dp
,: %32
atof
(
char: %32
*
)
;: %13
says: %32
that: %32
in: %32
an: %32
expression: %32
*
dp: %32
and: %32
atof
(
s
): %32
have: %32
values: %32
of: %32
double
,: %32
and: %32
that: %32
the: %32
argument: %32
of: %32
atof: %32
is: %32
a: %32
pointer: %32
to: %32
char
.: %13
You: %32
should: %32
also: %32
note: %32
the: %32
implication: %32
that: %32
a: %32
pointer: %32
is: %32
constrained: %32
to: %32
point: %32
to: %32
a: %32
particular: %32
kind: %32
of: %32
object
:: %32
every: %32
pointer: %32
points: %32
to: %32
a: %32
specific: %32
data: %32
type
.: %32
(
There: %32
is: %32
one: %13
exception
:: %32
a: %32
`
`
pointer: %32
to: %32
void
'
': %32
is: %32
used: %32
to: %32
hold: %32
any: %32
type: %32
of: %32
pointer: %32
but: %32
cannot: %32
be: %32
dereferenced: %32
itself
.: %32
We
'
ll: %32
come: %32
back: %32
to: %32
it: %32
in: %32
Section: %32
5
.
1
1
.
): %13
If: %32
ip: %32
points: %32
to: %32
the: %32
integer: %32
x
,: %32
then: %32
*
ip: %32
can: %32
occur: %32
in: %32
any: %32
context: %32
where: %32
x: %32
could
,: %32
so: %13
*
ip: %32
=: %32
*
ip: %32
+: %32
1
0
;: %13
increments: %32
*
ip: %32
by: %32
1
0
.: %13
The: %32
unary: %32
operators: %32
*: %32
and: %32
&: %32
bind: %32
more: %32
tightly: %32
than: %32
arithmetic: %32
operators
,: %32
so: %32
the: %32
assignment: %13
y: %32
=: %32
*
ip: %32
+: %32
1: %13
takes: %32
whatever: %32
ip: %32
points: %32
at
,: %32
adds: %32
1
,: %32
and: %32
assigns: %32
the: %32
result: %32
to: %32
y
,: %32
while: %13
*
ip: %32
+
=: %32
1: %13
increments: %32
what: %32
ip: %32
points: %32
to
,: %32
as: %32
do: %13
+
+
*
ip: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
and: %13
(
*
ip
)
+
+: %13
The: %32
parentheses: %32
are: %32
necessary: %32
in: %32
this: %32
last: %32
example
;: %32
without: %32
them
,: %32
the: %32
expression: %32
would: %32
increment: %32
ip: %32
instead: %32
of: %32
what: %32
it: %32
points: %32
to
,: %32
because: %32
unary: %32
operators: %32
like: %32
*: %32
and: %32
+
+: %13
associate: %32
right: %32
to: %32
left
.: %13
Finally
,: %32
since: %32
pointers: %32
are: %32
variables
,: %32
they: %32
can: %32
be: %32
used: %32
without: %32
dereferencing
.: %32
For: %32
example
,: %32
if: %32
iq: %32
is: %32
another: %32
pointer: %32
to: %32
int
,: %13
iq: %32
=: %32
ip: %13
copies: %32
the: %32
contents: %32
of: %32
ip: %32
into: %32
iq
,: %32
thus: %32
making: %32
iq: %32
point: %32
to: %32
whatever: %32
ip: %32
pointed: %32
to
.: %13
5
.
2: %32
Pointers: %32
and: %32
Function: %32
Arguments: %13
Since: %32
C: %32
passes: %32
arguments: %32
to: %32
functions: %32
by: %32
value
,: %32
there: %32
is: %32
no: %32
direct: %32
way: %32
for: %32
the: %32
called: %32
function: %32
to: %32
alter: %32
a: %32
variable: %32
in: %32
the: %32
calling: %32
function
.: %32
For: %32
instance
,: %32
a: %32
sorting: %32
routine: %13
might: %32
exchange: %32
two: %32
out
-
of
-
order: %32
arguments: %32
with: %32
a: %32
function: %32
called: %32
swap
.: %32
It: %32
is: %32
not: %32
enough: %32
to: %32
write: %13
swap
(
a
,: %32
b
)
;: %13
where: %32
the: %32
swap: %32
function: %32
is: %32
defined: %32
as: %13
void: %32
swap
(
int: %32
x
,: %32
int: %32
y
): %13
{: %13
int: %32
temp
;: %13
/
*: %32
WRONG: %32
*
/: %13
temp: %32
=: %32
x
;: %13
x: %32
=: %32
y
;: %13
y: %32
=: %32
temp
;: %13
}: %13
Because: %32
of: %32
call: %32
by: %32
value
,: %32
swap: %32
can
'
t: %32
affect: %32
the: %32
arguments: %32
a: %32
and: %32
b: %32
in: %32
the: %32
routine: %32
that: %32
called: %32
it
.: %32
The: %32
function: %32
above: %32
swaps: %32
copies: %32
of: %32
a: %32
and: %32
b
.: %13
The: %32
way: %32
to: %32
obtain: %32
the: %32
desired: %32
effect: %32
is: %32
for: %32
the: %32
calling: %32
program: %32
to: %32
pass: %32
pointers: %32
to: %32
the: %32
values: %32
to: %32
be: %32
changed
:: %13
swap
(
&
a
,: %32
&
b
)
;: %13
Since: %32
the: %32
operator: %32
&: %32
produces: %32
the: %32
address: %32
of: %32
a: %32
variable
,: %32
&
a: %32
is: %32
a: %32
pointer: %32
to: %32
a
.: %32
In: %32
swap: %32
itself
,: %32
the: %32
parameters: %32
are: %32
declared: %32
as: %32
pointers
,: %32
and: %32
the: %32
operands: %32
are: %32
accessed: %13
indirectly: %32
through: %32
them
.: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
void: %32
swap
(
int: %32
*
px
,: %32
int: %32
*
py
): %13
{: %13
int: %32
temp
;: %13
/
*: %32
interchange: %32
*
px: %32
and: %32
*
py: %32
*
/: %13
temp: %32
=: %32
*
px
;: %13
*
px: %32
=: %32
*
py
;: %13
*
py: %32
=: %32
temp
;: %13
}: %13
Pictorially
:: %13
Pointer: %32
arguments: %32
enable: %32
a: %32
function: %32
to: %32
access: %32
and: %32
change: %32
objects: %32
in: %32
the: %32
function: %32
that: %32
called: %32
it
.: %32
As: %32
an: %32
example
,: %32
consider: %32
a: %32
function: %32
getint: %32
that: %32
performs: %32
free
-
format: %13
input: %32
conversion: %32
by: %32
breaking: %32
a: %32
stream: %32
of: %32
characters: %32
into: %32
integer: %32
values
,: %32
one: %32
integer: %32
per: %32
call
.: %32
getint: %32
has: %32
to: %32
return: %32
the: %32
value: %32
it: %32
found: %32
and: %32
also: %32
signal: %32
end: %32
of: %32
file: %32
when: %32
there: %13
is: %32
no: %32
more: %32
input
.: %32
These: %32
values: %32
have: %32
to: %32
be: %32
passed: %32
back: %32
by: %32
separate: %32
paths
,: %32
for: %32
no: %32
matter: %32
what: %32
value: %32
is: %32
used: %32
for: %32
EOF
,: %32
that: %32
could: %32
also: %32
be: %32
the: %32
value: %32
of: %32
an: %32
input: %32
integer
.: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
One: %32
solution: %32
is: %32
to: %32
have: %32
getint: %32
return: %32
the: %32
end: %32
of: %32
file: %32
status: %32
as: %32
its: %32
function: %32
value
,: %32
while: %32
using: %32
a: %32
pointer: %32
argument: %32
to: %32
store: %32
the: %32
converted: %32
integer: %32
back: %32
in: %32
the: %32
calling: %13
function
.: %32
This: %32
is: %32
the: %32
scheme: %32
used: %32
by: %32
scanf: %32
as: %32
well
;: %32
see: %32
Section: %32
7
.
4
.: %13
The: %32
following: %32
loop: %32
fills: %32
an: %32
array: %32
with: %32
integers: %32
by: %32
calls: %32
to: %32
getint
:: %13
int: %32
n
,: %32
array
[
SIZE
]
,: %32
getint
(
int: %32
*
)
;: %13
for: %32
(
n: %32
=: %32
0
;: %32
n: %32
<: %32
SIZE: %32
&
&: %32
getint
(
&
array
[
n
]
): %32
!
=: %32
EOF
;: %32
n
+
+
): %13
;: %13
Each: %32
call: %32
sets: %32
array
[
n
]: %32
to: %32
the: %32
next: %32
integer: %32
found: %32
in: %32
the: %32
input: %32
and: %32
increments: %32
n
.: %32
Notice: %32
that: %32
it: %32
is: %32
essential: %32
to: %32
pass: %32
the: %32
address: %32
of: %32
array
[
n
]: %32
to: %32
getint
.: %32
Otherwise: %32
there: %13
is: %32
no: %32
way: %32
for: %32
getint: %32
to: %32
communicate: %32
the: %32
converted: %32
integer: %32
back: %32
to: %32
the: %32
caller
.: %13
Our: %32
version: %32
of: %32
getint: %32
returns: %32
EOF: %32
for: %32
end: %32
of: %32
file
,: %32
zero: %32
if: %32
the: %32
next: %32
input: %32
is: %32
not: %32
a: %32
number
,: %32
and: %32
a: %32
positive: %32
value: %32
if: %32
the: %32
input: %32
contains: %32
a: %32
valid: %32
number
.: %13
#
include: %32
<
ctype
.
h
>: %13
int: %32
getch
(
void
)
;: %13
void: %32
ungetch
(
int
)
;: %13
/
*: %32
getint
:: %32
get: %32
next: %32
integer: %32
from: %32
input: %32
into: %32
*
pn: %32
*
/: %13
int: %32
getint
(
int: %32
*
pn
): %13
{: %13
int: %32
c
,: %32
sign
;: %13
while: %32
(
isspace
(
c: %32
=: %32
getch
(
)
)
): %13
/
*: %32
skip: %32
white: %32
space: %32
*
/: %13
;: %13
if: %32
(
!
isdigit
(
c
): %32
&
&: %32
c: %32
!
=: %32
EOF: %32
&
&: %32
c: %32
!
=: %32
'
+
': %32
&
&: %32
c: %32
!
=: %32
'
-
'
): %32
{: %13
ungetch
(
c
)
;: %32
/
*: %32
it: %32
is: %32
not: %32
a: %32
number: %32
*
/: %13
return: %32
0
;: %13
}: %13
sign: %32
=: %32
(
c: %32
=
=: %32
'
-
'
): %32
?: %32
-
1: %32
:: %32
1
;: %13
if: %32
(
c: %32
=
=: %32
'
+
': %32
|
|: %32
c: %32
=
=: %32
'
-
'
): %13
c: %32
=: %32
getch
(
)
;: %13
for: %32
(
*
pn: %32
=: %32
0
;: %32
isdigit
(
c
)
,: %32
c: %32
=: %32
getch
(
)
): %13
*
pn: %32
=: %32
1
0: %32
*: %32
*
pn: %32
+: %32
(
c: %32
-: %32
'
0
'
)
;: %13
*
pn: %32
*
=: %32
sign
;: %13
if: %32
(
c: %32
!
=: %32
EOF
): %13
ungetch
(
c
)
;: %13
return: %32
c
;: %13
}: %13
Throughout: %32
getint
,: %32
*
pn: %32
is: %32
used: %32
as: %32
an: %32
ordinary: %32
int: %32
variable
.: %32
We: %32
have: %32
also: %32
used: %32
getch: %32
and: %32
ungetch: %32
(
described: %32
in: %32
Section: %32
4
.
3
): %32
so: %32
the: %32
one: %32
extra: %32
character: %32
that: %32
must: %13
be: %32
read: %32
can: %32
be: %32
pushed: %32
back: %32
onto: %32
the: %32
input
.: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
Exercise: %32
5
-
1
.: %32
As: %32
written
,: %32
getint: %32
treats: %32
a: %32
+: %32
or: %32
-: %32
not: %32
followed: %32
by: %32
a: %32
digit: %32
as: %32
a: %32
valid: %32
representation: %32
of: %32
zero
.: %32
Fix: %32
it: %32
to: %32
push: %32
such: %32
a: %32
character: %32
back: %32
on: %32
the: %32
input
.: %13
Exercise: %32
5
-
2
.: %32
Write: %32
getfloat
,: %32
the: %32
floating
-
point: %32
analog: %32
of: %32
getint
.: %32
What: %32
type: %32
does: %32
getfloat: %32
return: %32
as: %32
its: %32
function: %32
value
?: %13
5
.
3: %32
Pointers: %32
and: %32
Arrays: %13
In: %32
C
,: %32
there: %32
is: %32
a: %32
strong: %32
relationship: %32
between: %32
pointers: %32
and: %32
arrays
,: %32
strong: %32
enough: %32
that: %32
pointers: %32
and: %32
arrays: %32
should: %32
be: %32
discussed: %32
simultaneously
.: %32
Any: %32
operation: %32
that: %32
can: %32
be: %13
achieved: %32
by: %32
array: %32
subscripting: %32
can: %32
also: %32
be: %32
done: %32
with: %32
pointers
.: %32
The: %32
pointer: %32
version: %32
will: %32
in: %32
general: %32
be: %32
faster: %32
but
,: %32
at: %32
least: %32
to: %32
the: %32
uninitiated
,: %32
somewhat: %32
harder: %32
to: %32
understand
.: %13
The: %32
declaration: %13
int: %32
a
[
1
0
]
;: %13
defines: %32
an: %32
array: %32
of: %32
size: %32
1
0
,: %32
that: %32
is
,: %32
a: %32
block: %32
of: %32
1
0: %32
consecutive: %32
objects: %32
named: %32
a
[
0
]
,: %32
a
[
1
]
,: %32
.
.
.
,
a
[
9
]
.: %13
The: %32
notation: %32
a
[
i
]: %32
refers: %32
to: %32
the: %32
i
-
th: %32
element: %32
of: %32
the: %32
array
.: %32
If: %32
pa: %32
is: %32
a: %32
pointer: %32
to: %32
an: %32
integer
,: %32
declared: %32
as: %13
int: %32
*
pa
;: %13
then: %32
the: %32
assignment: %13
pa: %32
=: %32
&
a
[
0
]
;: %13
sets: %32
pa: %32
to: %32
point: %32
to: %32
element: %32
zero: %32
of: %32
a
;: %32
that: %32
is
,: %32
pa: %32
contains: %32
the: %32
address: %32
of: %32
a
[
0
]
.: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
Now: %32
the: %32
assignment: %13
x: %32
=: %32
*
pa
;: %13
will: %32
copy: %32
the: %32
contents: %32
of: %32
a
[
0
]: %32
into: %32
x
.: %13
If: %32
pa: %32
points: %32
to: %32
a: %32
particular: %32
element: %32
of: %32
an: %32
array
,: %32
then: %32
by: %32
definition: %32
pa
+
1: %32
points: %32
to: %32
the: %32
next: %32
element
,: %32
pa
+
i: %32
points: %32
i: %32
elements: %32
after: %32
pa
,: %32
and: %32
pa
-
i: %32
points: %32
i: %32
elements: %32
before
.: %13
Thus
,: %32
if: %32
pa: %32
points: %32
to: %32
a
[
0
]
,: %13
*
(
pa
+
1
): %13
refers: %32
to: %32
the: %32
contents: %32
of: %32
a
[
1
]
,: %32
pa
+
i: %32
is: %32
the: %32
address: %32
of: %32
a
[
i
]
,: %32
and: %32
*
(
pa
+
i
): %32
is: %32
the: %32
contents: %32
of: %32
a
[
i
]
.: %13
These: %32
remarks: %32
are: %32
true: %32
regardless: %32
of: %32
the: %32
type: %32
or: %32
size: %32
of: %32
the: %32
variables: %32
in: %32
the: %32
array: %32
a
.: %32
The: %32
meaning: %32
of: %32
`
`
adding: %32
1: %32
to: %32
a: %32
pointer
,
'
': %32
and: %32
by: %32
extension
,: %32
all: %32
pointer: %32
arithmetic
,: %32
is: %32
that: %13
pa
+
1: %32
points: %32
to: %32
the: %32
next: %32
object
,: %32
and: %32
pa
+
i: %32
points: %32
to: %32
the: %32
i
-
th: %32
object: %32
beyond: %32
pa
.: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
The: %32
correspondence: %32
between: %32
indexing: %32
and: %32
pointer: %32
arithmetic: %32
is: %32
very: %32
close
.: %32
By: %32
definition
,: %32
the: %32
value: %32
of: %32
a: %32
variable: %32
or: %32
expression: %32
of: %32
type: %32
array: %32
is: %32
the: %32
address: %32
of: %32
element: %32
zero: %13
of: %32
the: %32
array
.: %32
Thus: %32
after: %32
the: %32
assignment: %13
pa: %32
=: %32
&
a
[
0
]
;: %13
pa: %32
and: %32
a: %32
have: %32
identical: %32
values
.: %32
Since: %32
the: %32
name: %32
of: %32
an: %32
array: %32
is: %32
a: %32
synonym: %32
for: %32
the: %32
location: %32
of: %32
the: %32
initial: %32
element
,: %32
the: %32
assignment: %32
pa
=
&
a
[
0
]: %32
can: %32
also: %32
be: %32
written: %32
as: %13
pa: %32
=: %32
a
;: %13
Rather: %32
more: %32
surprising
,: %32
at: %32
first: %32
sight
,: %32
is: %32
the: %32
fact: %32
that: %32
a: %32
reference: %32
to: %32
a
[
i
]: %32
can: %32
also: %32
be: %32
written: %32
as: %32
*
(
a
+
i
)
.: %32
In: %32
evaluating: %32
a
[
i
]
,: %32
C: %32
converts: %32
it: %32
to: %32
*
(
a
+
i
): %32
immediately
;: %32
the: %13
two: %32
forms: %32
are: %32
equivalent
.: %32
Applying: %32
the: %32
operator: %32
&: %32
to: %32
both: %32
parts: %32
of: %32
this: %32
equivalence
,: %32
it: %32
follows: %32
that: %32
&
a
[
i
]: %32
and: %32
a
+
i: %32
are: %32
also: %32
identical
:: %32
a
+
i: %32
is: %32
the: %32
address: %32
of: %32
the: %32
i
-
th: %13
element: %32
beyond: %32
a
.: %32
As: %32
the: %32
other: %32
side: %32
of: %32
this: %32
coin
,: %32
if: %32
pa: %32
is: %32
a: %32
pointer
,: %32
expressions: %32
might: %32
use: %32
it: %32
with: %32
a: %32
subscript
;: %32
pa
[
i
]: %32
is: %32
identical: %32
to: %32
*
(
pa
+
i
)
.: %32
In: %32
short
,: %32
an: %32
array
-
and
-
index: %13
expression: %32
is: %32
equivalent: %32
to: %32
one: %32
written: %32
as: %32
a: %32
pointer: %32
and: %32
offset
.: %13
There: %32
is: %32
one: %32
difference: %32
between: %32
an: %32
array: %32
name: %32
and: %32
a: %32
pointer: %32
that: %32
must: %32
be: %32
kept: %32
in: %32
mind
.: %32
A: %32
pointer: %32
is: %32
a: %32
variable
,: %32
so: %32
pa
=
a: %32
and: %32
pa
+
+: %32
are: %32
legal
.: %32
But: %32
an: %32
array: %32
name: %32
is: %32
not: %32
a: %13
variable
;: %32
constructions: %32
like: %32
a
=
pa: %32
and: %32
a
+
+: %32
are: %32
illegal
.: %13
When: %32
an: %32
array: %32
name: %32
is: %32
passed: %32
to: %32
a: %32
function
,: %32
what: %32
is: %32
passed: %32
is: %32
the: %32
location: %32
of: %32
the: %32
initial: %32
element
.: %32
Within: %32
the: %32
called: %32
function
,: %32
this: %32
argument: %32
is: %32
a: %32
local: %32
variable
,: %32
and: %32
so: %32
an: %13
array: %32
name: %32
parameter: %32
is: %32
a: %32
pointer
,: %32
that: %32
is
,: %32
a: %32
variable: %32
containing: %32
an: %32
address
.: %32
We: %32
can: %32
use: %32
this: %32
fact: %32
to: %32
write: %32
another: %32
version: %32
of: %32
strlen
,: %32
which: %32
computes: %32
the: %32
length: %32
of: %32
a: %13
string
.: %13
/
*: %32
strlen
:: %32
return: %32
length: %32
of: %32
string: %32
s: %32
*
/: %13
int: %32
strlen
(
char: %32
*
s
): %13
{: %13
int: %32
n
;: %13
for: %32
(
n: %32
=: %32
0
;: %32
*
s: %32
!
=: %32
'
\
0
'
,: %32
s
+
+
): %13
n
+
+
;: %13
return: %32
n
;: %13
}: %13
Since: %32
s: %32
is: %32
a: %32
pointer
,: %32
incrementing: %32
it: %32
is: %32
perfectly: %32
legal
;: %32
s
+
+: %32
has: %32
no: %32
effect: %32
on: %32
the: %32
character: %32
string: %32
in: %32
the: %32
function: %32
that: %32
called: %32
strlen
,: %32
but: %32
merely: %32
increments: %32
strlen
'
s: %13
private: %32
copy: %32
of: %32
the: %32
pointer
.: %32
That: %32
means: %32
that: %32
calls: %32
like: %13
strlen
(
"
hello
,: %32
world
"
)
;: %13
strlen
(
array
)
;: %13
strlen
(
ptr
)
;: %13
/
*: %32
string: %32
constant: %32
*
/: %13
/
*: %32
char: %32
array
[
1
0
0
]
;: %32
*
/: %13
/
*: %32
char: %32
*
ptr
;: %32
*
/: %13
all: %32
work
.: %13
As: %32
formal: %32
parameters: %32
in: %32
a: %32
function: %32
definition
,: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
char: %32
s
[
]
;: %13
and: %13
char: %32
*
s
;: %13
are: %32
equivalent
;: %32
we: %32
prefer: %32
the: %32
latter: %32
because: %32
it: %32
says: %32
more: %32
explicitly: %32
that: %32
the: %32
variable: %32
is: %32
a: %32
pointer
.: %32
When: %32
an: %32
array: %32
name: %32
is: %32
passed: %32
to: %32
a: %32
function
,: %32
the: %32
function: %32
can: %32
at: %32
its: %13
convenience: %32
believe: %32
that: %32
it: %32
has: %32
been: %32
handed: %32
either: %32
an: %32
array: %32
or: %32
a: %32
pointer
,: %32
and: %32
manipulate: %32
it: %32
accordingly
.: %32
It: %32
can: %32
even: %32
use: %32
both: %32
notations: %32
if: %32
it: %32
seems: %32
appropriate: %32
and: %32
clear
.: %13
It: %32
is: %32
possible: %32
to: %32
pass: %32
part: %32
of: %32
an: %32
array: %32
to: %32
a: %32
function
,: %32
by: %32
passing: %32
a: %32
pointer: %32
to: %32
the: %32
beginning: %32
of: %32
the: %32
subarray
.: %32
For: %32
example
,: %32
if: %32
a: %32
is: %32
an: %32
array
,: %13
f
(
&
a
[
2
]
): %13
and: %13
f
(
a
+
2
): %13
both: %32
pass: %32
to: %32
the: %32
function: %32
f: %32
the: %32
address: %32
of: %32
the: %32
subarray: %32
that: %32
starts: %32
at: %32
a
[
2
]
.: %32
Within: %32
f
,: %32
the: %32
parameter: %32
declaration: %32
can: %32
read: %13
f
(
int: %32
arr
[
]
): %32
{: %32
.
.
.: %32
}: %13
or: %13
f
(
int: %32
*
arr
): %32
{: %32
.
.
.: %32
}: %13
So: %32
as: %32
far: %32
as: %32
f: %32
is: %32
concerned
,: %32
the: %32
fact: %32
that: %32
the: %32
parameter: %32
refers: %32
to: %32
part: %32
of: %32
a: %32
larger: %32
array: %32
is: %32
of: %32
no: %32
consequence
.: %13
If: %32
one: %32
is: %32
sure: %32
that: %32
the: %32
elements: %32
exist
,: %32
it: %32
is: %32
also: %32
possible: %32
to: %32
index: %32
backwards: %32
in: %32
an: %32
array
;: %32
p
[
-
1
]
,: %32
p
[
-
2
]
,: %32
and: %32
so: %32
on: %32
are: %32
syntactically: %32
legal
,: %32
and: %32
refer: %32
to: %32
the: %32
elements: %32
that: %13
immediately: %32
precede: %32
p
[
0
]
.: %32
Of: %32
course
,: %32
it: %32
is: %32
illegal: %32
to: %32
refer: %32
to: %32
objects: %32
that: %32
are: %32
not: %32
within: %32
the: %32
array: %32
bounds
.: %13
5
.
4: %32
Address: %32
Arithmetic: %13
If: %32
p: %32
is: %32
a: %32
pointer: %32
to: %32
some: %32
element: %32
of: %32
an: %32
array
,: %32
then: %32
p
+
+: %32
increments: %32
p: %32
to: %32
point: %32
to: %32
the: %32
next: %32
element
,: %32
and: %32
p
+
=
i: %32
increments: %32
it: %32
to: %32
point: %32
i: %32
elements: %32
beyond: %32
where: %32
it: %32
currently: %13
does
.: %32
These: %32
and: %32
similar: %32
constructions: %32
are: %32
the: %32
simples: %32
forms: %32
of: %32
pointer: %32
or: %32
address: %32
arithmetic
.: %13
C: %32
is: %32
consistent: %32
and: %32
regular: %32
in: %32
its: %32
approach: %32
to: %32
address: %32
arithmetic
;: %32
its: %32
integration: %32
of: %32
pointers
,: %32
arrays
,: %32
and: %32
address: %32
arithmetic: %32
is: %32
one: %32
of: %32
the: %32
strengths: %32
of: %32
the: %32
language
.: %32
Let: %32
us: %13
illustrate: %32
by: %32
writing: %32
a: %32
rudimentary: %32
storage: %32
allocator
.: %32
There: %32
are: %32
two: %32
routines
.: %32
The: %32
first
,: %32
alloc
(
n
)
,: %32
returns: %32
a: %32
pointer: %32
to: %32
n: %32
consecutive: %32
character: %32
positions
,: %32
which: %32
can: %32
be: %13
used: %32
by: %32
the: %32
caller: %32
of: %32
alloc: %32
for: %32
storing: %32
characters
.: %32
The: %32
second
,: %32
afree
(
p
)
,: %32
releases: %32
the: %32
storage: %32
thus: %32
acquired: %32
so: %32
it: %32
can: %32
be: %32
re
-
used: %32
later
.: %32
The: %32
routines: %32
are: %32
`
`
rudimentary
'
': %13
because: %32
the: %32
calls: %32
to: %32
afree: %32
must: %32
be: %32
made: %32
in: %32
the: %32
opposite: %32
order: %32
to: %32
the: %32
calls: %32
made: %32
on: %32
alloc
.: %32
That: %32
is
,: %32
the: %32
storage: %32
managed: %32
by: %32
alloc: %32
and: %32
afree: %32
is: %32
a: %32
stack
,: %32
or: %32
last
-
in
,: %32
first
-: %13
out
.: %32
The: %32
standard: %32
library: %32
provides: %32
analogous: %32
functions: %32
called: %32
malloc: %32
and: %32
free: %32
that: %32
have: %32
no: %32
such: %32
restrictions
;: %32
in: %32
Section: %32
8
.
7: %32
we: %32
will: %32
show: %32
how: %32
they: %32
can: %32
be: %13
implemented
.: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
The: %32
easiest: %32
implementation: %32
is: %32
to: %32
have: %32
alloc: %32
hand: %32
out: %32
pieces: %32
of: %32
a: %32
large: %32
character: %32
array: %32
that: %32
we: %32
will: %32
call: %32
allocbuf
.: %32
This: %32
array: %32
is: %32
private: %32
to: %32
alloc: %32
and: %32
afree
.: %32
Since: %13
they: %32
deal: %32
in: %32
pointers
,: %32
not: %32
array: %32
indices
,: %32
no: %32
other: %32
routine: %32
need: %32
know: %32
the: %32
name: %32
of: %32
the: %32
array
,: %32
which: %32
can: %32
be: %32
declared: %32
static: %32
in: %32
the: %32
source: %32
file: %32
containing: %32
alloc: %32
and: %13
afree
,: %32
and: %32
thus: %32
be: %32
invisible: %32
outside: %32
it
.: %32
In: %32
practical: %32
implementations
,: %32
the: %32
array: %32
may: %32
well: %32
not: %32
even: %32
have: %32
a: %32
name
;: %32
it: %32
might: %32
instead: %32
be: %32
obtained: %32
by: %32
calling: %32
malloc: %32
or: %32
by: %13
asking: %32
the: %32
operating: %32
system: %32
for: %32
a: %32
pointer: %32
to: %32
some: %32
unnamed: %32
block: %32
of: %32
storage
.: %13
The: %32
other: %32
information: %32
needed: %32
is: %32
how: %32
much: %32
of: %32
allocbuf: %32
has: %32
been: %32
used
.: %32
We: %32
use: %32
a: %32
pointer
,: %32
called: %32
allocp
,: %32
that: %32
points: %32
to: %32
the: %32
next: %32
free: %32
element
.: %32
When: %32
alloc: %32
is: %32
asked: %13
for: %32
n: %32
characters
,: %32
it: %32
checks: %32
to: %32
see: %32
if: %32
there: %32
is: %32
enough: %32
room: %32
left: %32
in: %32
allocbuf
.: %32
If: %32
so
,: %32
alloc: %32
returns: %32
the: %32
current: %32
value: %32
of: %32
allocp: %32
(
i
.
e
.
,: %32
the: %32
beginning: %32
of: %32
the: %32
free: %32
block
)
,: %32
then: %13
increments: %32
it: %32
by: %32
n: %32
to: %32
point: %32
to: %32
the: %32
next: %32
free: %32
area
.: %32
If: %32
there: %32
is: %32
no: %32
room
,: %32
alloc: %32
returns: %32
zero
.: %32
afree
(
p
): %32
merely: %32
sets: %32
allocp: %32
to: %32
p: %32
if: %32
p: %32
is: %32
inside: %32
allocbuf
.: %13
#
define: %32
ALLOCSIZE: %32
1
0
0
0
0: %32
/
*: %32
size: %32
of: %32
available: %32
space: %32
*
/: %13
static: %32
char: %32
allocbuf
[
ALLOCSIZE
]
;: %32
/
*: %32
storage: %32
for: %32
alloc: %32
*
/: %13
static: %32
char: %32
*
allocp: %32
=: %32
allocbuf
;: %32
/
*: %32
next: %32
free: %32
position: %32
*
/: %13
char: %32
*
alloc
(
int: %32
n
): %13
/
*: %32
return: %32
pointer: %32
to: %32
n: %32
characters: %32
*
/: %13
{: %13
if: %32
(
allocbuf: %32
+: %32
ALLOCSIZE: %32
-: %32
allocp: %32
>
=: %32
n
): %32
{: %32
/
*: %32
it: %32
fits: %32
*
/: %13
allocp: %32
+
=: %32
n
;: %13
return: %32
allocp: %32
-: %32
n
;: %32
/
*: %32
old: %32
p: %32
*
/: %13
}: %32
else: %13
/
*: %32
not: %32
enough: %32
room: %32
*
/: %13
return: %32
0
;: %13
}: %13
void: %32
afree
(
char: %32
*
p
): %13
{: %13
/
*: %32
free: %32
storage: %32
pointed: %32
to: %32
by: %32
p: %32
*
/: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
if: %32
(
p: %32
>
=: %32
allocbuf: %32
&
&: %32
p: %32
<: %32
allocbuf: %32
+: %32
ALLOCSIZE
): %13
allocp: %32
=: %32
p
;: %13
}: %13
In: %32
general: %32
a: %32
pointer: %32
can: %32
be: %32
initialized: %32
just: %32
as: %32
any: %32
other: %32
variable: %32
can
,: %32
though: %32
normally: %32
the: %32
only: %32
meaningful: %32
values: %32
are: %32
zero: %32
or: %32
an: %32
expression: %32
involving: %32
the: %32
address: %32
of: %13
previously: %32
defined: %32
data: %32
of: %32
appropriate: %32
type
.: %32
The: %32
declaration: %13
static: %32
char: %32
*
allocp: %32
=: %32
allocbuf
;: %13
defines: %32
allocp: %32
to: %32
be: %32
a: %32
character: %32
pointer: %32
and: %32
initializes: %32
it: %32
to: %32
point: %32
to: %32
the: %32
beginning: %32
of: %32
allocbuf
,: %32
which: %32
is: %32
the: %32
next: %32
free: %32
position: %32
when: %32
the: %32
program: %32
starts
.: %32
This: %32
could: %13
also: %32
have: %32
been: %32
written: %13
static: %32
char: %32
*
allocp: %32
=: %32
&
allocbuf
[
0
]
;: %13
since: %32
the: %32
array: %32
name: %32
is: %32
the: %32
address: %32
of: %32
the: %32
zeroth: %32
element
.: %13
The: %32
test: %13
if: %32
(
allocbuf: %32
+: %32
ALLOCSIZE: %32
-: %32
allocp: %32
>
=: %32
n
): %32
{: %13
/
*: %32
it: %32
fits: %32
*
/: %13
checks: %32
if: %32
there
'
s: %32
enough: %32
room: %32
to: %32
satisfy: %32
a: %32
request: %32
for: %32
n: %32
characters
.: %32
If: %32
there: %32
is
,: %32
the: %32
new: %32
value: %32
of: %32
allocp: %32
would: %32
be: %32
at: %32
most: %32
one: %32
beyond: %32
the: %32
end: %32
of: %32
allocbuf
.: %32
If: %32
the: %13
request: %32
can: %32
be: %32
satisfied
,: %32
alloc: %32
returns: %32
a: %32
pointer: %32
to: %32
the: %32
beginning: %32
of: %32
a: %32
block: %32
of: %32
characters: %32
(
notice: %32
the: %32
declaration: %32
of: %32
the: %32
function: %32
itself
)
.: %32
If: %32
not
,: %32
alloc: %32
must: %32
return: %32
some: %13
signal: %32
that: %32
there: %32
is: %32
no: %32
space: %32
left
.: %32
C: %32
guarantees: %32
that: %32
zero: %32
is: %32
never: %32
a: %32
valid: %32
address: %32
for: %32
data
,: %32
so: %32
a: %32
return: %32
value: %32
of: %32
zero: %32
can: %32
be: %32
used: %32
to: %32
signal: %32
an: %32
abnormal: %32
event
,: %32
in: %32
this: %32
case: %32
no: %13
space
.: %13
Pointers: %32
and: %32
integers: %32
are: %32
not: %32
interchangeable
.: %32
Zero: %32
is: %32
the: %32
sole: %32
exception
:: %32
the: %32
constant: %32
zero: %32
may: %32
be: %32
assigned: %32
to: %32
a: %32
pointer
,: %32
and: %32
a: %32
pointer: %32
may: %32
be: %32
compared: %32
with: %32
the: %32
constant: %13
zero
.: %32
The: %32
symbolic: %32
constant: %32
NULL: %32
is: %32
often: %32
used: %32
in: %32
place: %32
of: %32
zero
,: %32
as: %32
a: %32
mnemonic: %32
to: %32
indicate: %32
more: %32
clearly: %32
that: %32
this: %32
is: %32
a: %32
special: %32
value: %32
for: %32
a: %32
pointer
.: %32
NULL: %32
is: %32
defined: %32
in: %13
<
stdio
.
h
>
.: %32
We: %32
will: %32
use: %32
NULL: %32
henceforth
.: %13
Tests: %32
like: %13
if: %32
(
allocbuf: %32
+: %32
ALLOCSIZE: %32
-: %32
allocp: %32
>
=: %32
n
): %32
{: %13
/
*: %32
it: %32
fits: %32
*
/: %13
and: %13
if: %32
(
p: %32
>
=: %32
allocbuf: %32
&
&: %32
p: %32
<: %32
allocbuf: %32
+: %32
ALLOCSIZE
): %13
show: %32
several: %32
important: %32
facets: %32
of: %32
pointer: %32
arithmetic
.: %32
First
,: %32
pointers: %32
may: %32
be: %32
compared: %32
under: %32
certain: %32
circumstances
.: %32
If: %32
p: %32
and: %32
q: %32
point: %32
to: %32
members: %32
of: %32
the: %32
same: %32
array
,: %32
then: %13
relations: %32
like: %32
=
=
,: %32
!
=
,: %32
<
,: %32
>
=
,: %32
etc
.
,: %32
work: %32
properly
.: %32
For: %32
example
,: %13
p: %32
<: %32
q: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
is: %32
true: %32
if: %32
p: %32
points: %32
to: %32
an: %32
earlier: %32
element: %32
of: %32
the: %32
array: %32
than: %32
q: %32
does
.: %32
Any: %32
pointer: %32
can: %32
be: %32
meaningfully: %32
compared: %32
for: %32
equality: %32
or: %32
inequality: %32
with: %32
zero
.: %32
But: %32
the: %32
behavior: %32
is: %13
undefined: %32
for: %32
arithmetic: %32
or: %32
comparisons: %32
with: %32
pointers: %32
that: %32
do: %32
not: %32
point: %32
to: %32
members: %32
of: %32
the: %32
same: %32
array
.: %32
(
There: %32
is: %32
one: %32
exception
:: %32
the: %32
address: %32
of: %32
the: %32
first: %32
element: %32
past: %32
the: %32
end: %13
of: %32
an: %32
array: %32
can: %32
be: %32
used: %32
in: %32
pointer: %32
arithmetic
.
): %13
Second
,: %32
we: %32
have: %32
already: %32
observed: %32
that: %32
a: %32
pointer: %32
and: %32
an: %32
integer: %32
may: %32
be: %32
added: %32
or: %32
subtracted
.: %32
The: %32
construction: %13
p: %32
+: %32
n: %13
means: %32
the: %32
address: %32
of: %32
the: %32
n
-
th: %32
object: %32
beyond: %32
the: %32
one: %32
p: %32
currently: %32
points: %32
to
.: %32
This: %32
is: %32
true: %32
regardless: %32
of: %32
the: %32
kind: %32
of: %32
object: %32
p: %32
points: %32
to
;: %32
n: %32
is: %32
scaled: %32
according: %32
to: %32
the: %32
size: %32
of: %32
the: %13
objects: %32
p: %32
points: %32
to
,: %32
which: %32
is: %32
determined: %32
by: %32
the: %32
declaration: %32
of: %32
p
.: %32
If: %32
an: %32
int: %32
is: %32
four: %32
bytes
,: %32
for: %32
example
,: %32
the: %32
int: %32
will: %32
be: %32
scaled: %32
by: %32
four
.: %13
Pointer: %32
subtraction: %32
is: %32
also: %32
valid
:: %32
if: %32
p: %32
and: %32
q: %32
point: %32
to: %32
elements: %32
of: %32
the: %32
same: %32
array
,: %32
and: %32
p
<
q
,: %32
then: %32
q
-
p
+
1: %32
is: %32
the: %32
number: %32
of: %32
elements: %32
from: %32
p: %32
to: %32
q: %32
inclusive
.: %32
This: %32
fact: %32
can: %32
be: %13
used: %32
to: %32
write: %32
yet: %32
another: %32
version: %32
of: %32
strlen
:: %13
/
*: %32
strlen
:: %32
return: %32
length: %32
of: %32
string: %32
s: %32
*
/: %13
int: %32
strlen
(
char: %32
*
s
): %13
{: %13
char: %32
*
p: %32
=: %32
s
;: %13
while: %32
(
*
p: %32
!
=: %32
'
\
0
'
): %13
p
+
+
;: %13
return: %32
p: %32
-: %32
s
;: %13
}: %13
In: %32
its: %32
declaration
,: %32
p: %32
is: %32
initialized: %32
to: %32
s
,: %32
that: %32
is
,: %32
to: %32
point: %32
to: %32
the: %32
first: %32
character: %32
of: %32
the: %32
string
.: %32
In: %32
the: %32
while: %32
loop
,: %32
each: %32
character: %32
in: %32
turn: %32
is: %32
examined: %32
until: %32
the: %32
'
\
0
': %32
at: %32
the: %32
end: %32
is: %13
seen
.: %32
Because: %32
p: %32
points: %32
to: %32
characters
,: %32
p
+
+: %32
advances: %32
p: %32
to: %32
the: %32
next: %32
character: %32
each: %32
time
,: %32
and: %32
p
-
s: %32
gives: %32
the: %32
number: %32
of: %32
characters: %32
advanced: %32
over
,: %32
that: %32
is
,: %32
the: %32
string: %32
length
.: %13
(
The: %32
number: %32
of: %32
characters: %32
in: %32
the: %32
string: %32
could: %32
be: %32
too: %32
large: %32
to: %32
store: %32
in: %32
an: %32
int
.: %32
The: %32
header: %32
<
stddef
.
h
>: %32
defines: %32
a: %32
type: %32
ptrdiff
_
t: %32
that: %32
is: %32
large: %32
enough: %32
to: %32
hold: %32
the: %13
signed: %32
difference: %32
of: %32
two: %32
pointer: %32
values
.: %32
If: %32
we: %32
were: %32
being: %32
cautious
,: %32
however
,: %32
we: %32
would: %32
use: %32
size
_
t: %32
for: %32
the: %32
return: %32
value: %32
of: %32
strlen
,: %32
to: %32
match: %32
the: %32
standard: %32
library: %13
version
.: %32
size
_
t: %32
is: %32
the: %32
unsigned: %32
integer: %32
type: %32
returned: %32
by: %32
the: %32
sizeof: %32
operator
.: %13
Pointer: %32
arithmetic: %32
is: %32
consistent
:: %32
if: %32
we: %32
had: %32
been: %32
dealing: %32
with: %32
floats
,: %32
which: %32
occupy: %32
more: %32
storage: %32
that: %32
chars
,: %32
and: %32
if: %32
p: %32
were: %32
a: %32
pointer: %32
to: %32
float
,: %32
p
+
+: %32
would: %32
advance: %32
to: %13
the: %32
next: %32
float
.: %32
Thus: %32
we: %32
could: %32
write: %32
another: %32
version: %32
of: %32
alloc: %32
that: %32
maintains: %32
floats: %32
instead: %32
of: %32
chars
,: %32
merely: %32
by: %32
changing: %32
char: %32
to: %32
float: %32
throughout: %32
alloc: %32
and: %13
afree
.: %32
All: %32
the: %32
pointer: %32
manipulations: %32
automatically: %32
take: %32
into: %32
account: %32
the: %32
size: %32
of: %32
the: %32
objects: %32
pointed: %32
to
.: %13
The: %32
valid: %32
pointer: %32
operations: %32
are: %32
assignment: %32
of: %32
pointers: %32
of: %32
the: %32
same: %32
type
,: %32
adding: %32
or: %32
subtracting: %32
a: %32
pointer: %32
and: %32
an: %32
integer
,: %32
subtracting: %32
or: %32
comparing: %32
two: %32
pointers: %32
to: %32
members: %13
of: %32
the: %32
same: %32
array
,: %32
and: %32
assigning: %32
or: %32
comparing: %32
to: %32
zero
.: %32
All: %32
other: %32
pointer: %32
arithmetic: %32
is: %32
illegal
.: %32
It: %32
is: %32
not: %32
legal: %32
to: %32
add: %32
two: %32
pointers
,: %32
or: %32
to: %32
multiply: %32
or: %32
divide: %32
or: %32
shift: %32
or: %32
mask: %13
them
,: %32
or: %32
to: %32
add: %32
float: %32
or: %32
double: %32
to: %32
them
,: %32
or: %32
even
,: %32
except: %32
for: %32
void: %32
*
,: %32
to: %32
assign: %32
a: %32
pointer: %32
of: %32
one: %32
type: %32
to: %32
a: %32
pointer: %32
of: %32
another: %32
type: %32
without: %32
a: %32
cast
.: %13
5
.
5: %32
Character: %32
Pointers: %32
and: %32
Functions: %13
A: %32
string: %32
constant
,: %32
written: %32
as: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
"
I: %32
am: %32
a: %32
string
": %13
is: %32
an: %32
array: %32
of: %32
characters
.: %32
In: %32
the: %32
internal: %32
representation
,: %32
the: %32
array: %32
is: %32
terminated: %32
with: %32
the: %32
null: %32
character: %32
'
\
0
': %32
so: %32
that: %32
programs: %32
can: %32
find: %32
the: %32
end
.: %32
The: %32
length: %32
in: %32
storage: %32
is: %32
thus: %13
one: %32
more: %32
than: %32
the: %32
number: %32
of: %32
characters: %32
between: %32
the: %32
double: %32
quotes
.: %13
Perhaps: %32
the: %32
most: %32
common: %32
occurrence: %32
of: %32
string: %32
constants: %32
is: %32
as: %32
arguments: %32
to: %32
functions
,: %32
as: %32
in: %13
printf
(
"
hello
,: %32
world
\
n
"
)
;: %13
When: %32
a: %32
character: %32
string: %32
like: %32
this: %32
appears: %32
in: %32
a: %32
program
,: %32
access: %32
to: %32
it: %32
is: %32
through: %32
a: %32
character: %32
pointer
;: %32
printf: %32
receives: %32
a: %32
pointer: %32
to: %32
the: %32
beginning: %32
of: %32
the: %32
character: %32
array
.: %32
That: %13
is
,: %32
a: %32
string: %32
constant: %32
is: %32
accessed: %32
by: %32
a: %32
pointer: %32
to: %32
its: %32
first: %32
element
.: %13
String: %32
constants: %32
need: %32
not: %32
be: %32
function: %32
arguments
.: %32
If: %32
pmessage: %32
is: %32
declared: %32
as: %13
char: %32
*
pmessage
;: %13
then: %32
the: %32
statement: %13
pmessage: %32
=: %32
"
now: %32
is: %32
the: %32
time
"
;: %13
assigns: %32
to: %32
pmessage: %32
a: %32
pointer: %32
to: %32
the: %32
character: %32
array
.: %32
This: %32
is: %32
not: %32
a: %32
string: %32
copy
;: %32
only: %32
pointers: %32
are: %32
involved
.: %32
C: %32
does: %32
not: %32
provide: %32
any: %32
operators: %32
for: %32
processing: %32
an: %32
entire: %32
string: %13
of: %32
characters: %32
as: %32
a: %32
unit
.: %13
There: %32
is: %32
an: %32
important: %32
difference: %32
between: %32
these: %32
definitions
:: %13
char: %32
amessage
[
]: %32
=: %32
"
now: %32
is: %32
the: %32
time
"
;: %32
/
*: %32
an: %32
array: %32
*
/: %13
char: %32
*
pmessage: %32
=: %32
"
now: %32
is: %32
the: %32
time
"
;: %32
/
*: %32
a: %32
pointer: %32
*
/: %13
amessage: %32
is: %32
an: %32
array
,: %32
just: %32
big: %32
enough: %32
to: %32
hold: %32
the: %32
sequence: %32
of: %32
characters: %32
and: %32
'
\
0
': %32
that: %32
initializes: %32
it
.: %32
Individual: %32
characters: %32
within: %32
the: %32
array: %32
may: %32
be: %32
changed: %32
but: %13
amessage: %32
will: %32
always: %32
refer: %32
to: %32
the: %32
same: %32
storage
.: %32
On: %32
the: %32
other: %32
hand
,: %32
pmessage: %32
is: %32
a: %32
pointer
,: %32
initialized: %32
to: %32
point: %32
to: %32
a: %32
string: %32
constant
;: %32
the: %32
pointer: %32
may: %32
subsequently: %32
be: %13
modified: %32
to: %32
point: %32
elsewhere
,: %32
but: %32
the: %32
result: %32
is: %32
undefined: %32
if: %32
you: %32
try: %32
to: %32
modify: %32
the: %32
string: %32
contents
.: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
We: %32
will: %32
illustrate: %32
more: %32
aspects: %32
of: %32
pointers: %32
and: %32
arrays: %32
by: %32
studying: %32
versions: %32
of: %32
two: %32
useful: %32
functions: %32
adapted: %32
from: %32
the: %32
standard: %32
library
.: %32
The: %32
first: %32
function: %32
is: %32
strcpy
(
s
,
t
)
,: %13
which: %32
copies: %32
the: %32
string: %32
t: %32
to: %32
the: %32
string: %32
s
.: %32
It: %32
would: %32
be: %32
nice: %32
just: %32
to: %32
say: %32
s
=
t: %32
but: %32
this: %32
copies: %32
the: %32
pointer
,: %32
not: %32
the: %32
characters
.: %32
To: %32
copy: %32
the: %32
characters
,: %32
we: %32
need: %32
a: %32
loop
.: %32
The: %32
array: %13
version: %32
first
:: %13
/
*: %32
strcpy
:: %32
copy: %32
t: %32
to: %32
s
;: %32
array: %32
subscript: %32
version: %32
*
/: %13
void: %32
strcpy
(
char: %32
*
s
,: %32
char: %32
*
t
): %13
{: %13
int: %32
i
;: %13
i: %32
=: %32
0
;: %13
while: %32
(
(
s
[
i
]: %32
=: %32
t
[
i
]
): %32
!
=: %32
'
\
0
'
): %13
i
+
+
;: %13
}: %13
For: %32
contrast
,: %32
here: %32
is: %32
a: %32
version: %32
of: %32
strcpy: %32
with: %32
pointers
:: %13
/
*: %32
strcpy
:: %32
copy: %32
t: %32
to: %32
s
;: %32
pointer: %32
version: %32
*
/: %13
void: %32
strcpy
(
char: %32
*
s
,: %32
char: %32
*
t
): %13
{: %13
int: %32
i
;: %13
i: %32
=: %32
0
;: %13
while: %32
(
(
*
s: %32
=: %32
*
t
): %32
!
=: %32
'
\
0
'
): %32
{: %13
s
+
+
;: %13
t
+
+
;: %13
}: %13
}: %13
Because: %32
arguments: %32
are: %32
passed: %32
by: %32
value
,: %32
strcpy: %32
can: %32
use: %32
the: %32
parameters: %32
s: %32
and: %32
t: %32
in: %32
any: %32
way: %32
it: %32
pleases
.: %32
Here: %32
they: %32
are: %32
conveniently: %32
initialized: %32
pointers
,: %32
which: %32
are: %32
marched: %13
along: %32
the: %32
arrays: %32
a: %32
character: %32
at: %32
a: %32
time
,: %32
until: %32
the: %32
'
\
0
': %32
that: %32
terminates: %32
t: %32
has: %32
been: %32
copied: %32
into: %32
s
.: %13
In: %32
practice
,: %32
strcpy: %32
would: %32
not: %32
be: %32
written: %32
as: %32
we: %32
showed: %32
it: %32
above
.: %32
Experienced: %32
C: %32
programmers: %32
would: %32
prefer: %13
/
*: %32
strcpy
:: %32
copy: %32
t: %32
to: %32
s
;: %32
pointer: %32
version: %32
2: %32
*
/: %13
void: %32
strcpy
(
char: %32
*
s
,: %32
char: %32
*
t
): %13
{: %13
while: %32
(
(
*
s
+
+: %32
=: %32
*
t
+
+
): %32
!
=: %32
'
\
0
'
): %13
;: %13
}: %13
This: %32
moves: %32
the: %32
increment: %32
of: %32
s: %32
and: %32
t: %32
into: %32
the: %32
test: %32
part: %32
of: %32
the: %32
loop
.: %32
The: %32
value: %32
of: %32
*
t
+
+: %32
is: %32
the: %32
character: %32
that: %32
t: %32
pointed: %32
to: %32
before: %32
t: %32
was: %32
incremented
;: %32
the: %32
postfix: %32
+
+: %32
doesn
'
t: %13
change: %32
t: %32
until: %32
after: %32
this: %32
character: %32
has: %32
been: %32
fetched
.: %32
In: %32
the: %32
same: %32
way
,: %32
the: %32
character: %32
is: %32
stored: %32
into: %32
the: %32
old: %32
s: %32
position: %32
before: %32
s: %32
is: %32
incremented
.: %32
This: %32
character: %32
is: %32
also: %32
the: %32
value: %13
that: %32
is: %32
compared: %32
against: %32
'
\
0
': %32
to: %32
control: %32
the: %32
loop
.: %32
The: %32
net: %32
effect: %32
is: %32
that: %32
characters: %32
are: %32
copied: %32
from: %32
t: %32
to: %32
s
,: %32
up: %32
and: %32
including: %32
the: %32
terminating: %32
'
\
0
'
.: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
As: %32
the: %32
final: %32
abbreviation
,: %32
observe: %32
that: %32
a: %32
comparison: %32
against: %32
'
\
0
': %32
is: %32
redundant
,: %32
since: %32
the: %32
question: %32
is: %32
merely: %32
whether: %32
the: %32
expression: %32
is: %32
zero
.: %32
So: %32
the: %32
function: %32
would: %32
likely: %13
be: %32
written: %32
as: %13
/
*: %32
strcpy
:: %32
copy: %32
t: %32
to: %32
s
;: %32
pointer: %32
version: %32
3: %32
*
/: %13
void: %32
strcpy
(
char: %32
*
s
,: %32
char: %32
*
t
): %13
{: %13
while: %32
(
*
s
+
+: %32
=: %32
*
t
+
+
): %13
;: %13
}: %13
Although: %32
this: %32
may: %32
seem: %32
cryptic: %32
at: %32
first: %32
sight
,: %32
the: %32
notational: %32
convenience: %32
is: %32
considerable
,: %32
and: %32
the: %32
idiom: %32
should: %32
be: %32
mastered
,: %32
because: %32
you: %32
will: %32
see: %32
it: %32
frequently: %32
in: %32
C: %13
programs
.: %13
The: %32
strcpy: %32
in: %32
the: %32
standard: %32
library: %32
(
<
string
.
h
>
): %32
returns: %32
the: %32
target: %32
string: %32
as: %32
its: %32
function: %32
value
.: %13
The: %32
second: %32
routine: %32
that: %32
we: %32
will: %32
examine: %32
is: %32
strcmp
(
s
,
t
)
,: %32
which: %32
compares: %32
the: %32
character: %32
strings: %32
s: %32
and: %32
t
,: %32
and: %32
returns: %32
negative
,: %32
zero: %32
or: %32
positive: %32
if: %32
s: %32
is: %32
lexicographically: %13
less: %32
than
,: %32
equal: %32
to
,: %32
or: %32
greater: %32
than: %32
t
.: %32
The: %32
value: %32
is: %32
obtained: %32
by: %32
subtracting: %32
the: %32
characters: %32
at: %32
the: %32
first: %32
position: %32
where: %32
s: %32
and: %32
t: %32
disagree
.: %13
/
*: %32
strcmp
:: %32
return: %32
<
0: %32
if: %32
s
<
t
,: %32
0: %32
if: %32
s
=
=
t
,: %32
>
0: %32
if: %32
s
>
t: %32
*
/: %13
int: %32
strcmp
(
char: %32
*
s
,: %32
char: %32
*
t
): %13
{: %13
int: %32
i
;: %13
for: %32
(
i: %32
=: %32
0
;: %32
s
[
i
]: %32
=
=: %32
t
[
i
]
;: %32
i
+
+
): %13
if: %32
(
s
[
i
]: %32
=
=: %32
'
\
0
'
): %13
return: %32
0
;: %13
return: %32
s
[
i
]: %32
-: %32
t
[
i
]
;: %13
}: %13
The: %32
pointer: %32
version: %32
of: %32
strcmp
:: %13
/
*: %32
strcmp
:: %32
return: %32
<
0: %32
if: %32
s
<
t
,: %32
0: %32
if: %32
s
=
=
t
,: %32
>
0: %32
if: %32
s
>
t: %32
*
/: %13
int: %32
strcmp
(
char: %32
*
s
,: %32
char: %32
*
t
): %13
{: %13
for: %32
(: %32
;: %32
*
s: %32
=
=: %32
*
t
;: %32
s
+
+
,: %32
t
+
+
): %13
if: %32
(
*
s: %32
=
=: %32
'
\
0
'
): %13
return: %32
0
;: %13
return: %32
*
s: %32
-: %32
*
t
;: %13
}: %13
Since: %32
+
+: %32
and: %32
-
-: %32
are: %32
either: %32
prefix: %32
or: %32
postfix: %32
operators
,: %32
other: %32
combinations: %32
of: %32
*: %32
and: %32
+
+: %32
and: %32
-
-: %32
occur
,: %32
although: %32
less: %32
frequently
.: %32
For: %32
example
,: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
*
-
-
p: %13
decrements: %32
p: %32
before: %32
fetching: %32
the: %32
character: %32
that: %32
p: %32
points: %32
to
.: %32
In: %32
fact
,: %32
the: %32
pair: %32
of: %32
expressions: %13
*
p
+
+: %32
=: %32
val
;: %13
val: %32
=: %32
*
-
-
p
;: %13
/
*: %32
push: %32
val: %32
onto: %32
stack: %32
*
/: %13
/
*: %32
pop: %32
top: %32
of: %32
stack: %32
into: %32
val: %32
*
/: %13
are: %32
the: %32
standard: %32
idiom: %32
for: %32
pushing: %32
and: %32
popping: %32
a: %32
stack
;: %32
see: %32
Section: %32
4
.
3
.: %13
The: %32
header: %32
<
string
.
h
>: %32
contains: %32
declarations: %32
for: %32
the: %32
functions: %32
mentioned: %32
in: %32
this: %32
section
,: %32
plus: %32
a: %32
variety: %32
of: %32
other: %32
string
-
handling: %32
functions: %32
from: %32
the: %32
standard: %32
library
.: %13
Exercise: %32
5
-
3
.: %32
Write: %32
a: %32
pointer: %32
version: %32
of: %32
the: %32
function: %32
strcat: %32
that: %32
we: %32
showed: %32
in: %32
Chapter: %32
2
:: %32
strcat
(
s
,
t
): %32
copies: %32
the: %32
string: %32
t: %32
to: %32
the: %32
end: %32
of: %32
s
.: %13
Exercise: %32
5
-
4
.: %32
Write: %32
the: %32
function: %32
strend
(
s
,
t
)
,: %32
which: %32
returns: %32
1: %32
if: %32
the: %32
string: %32
t: %32
occurs: %32
at: %32
the: %32
end: %32
of: %32
the: %32
string: %32
s
,: %32
and: %32
zero: %32
otherwise
.: %13
Exercise: %32
5
-
5
.: %32
Write: %32
versions: %32
of: %32
the: %32
library: %32
functions: %32
strncpy
,: %32
strncat
,: %32
and: %32
strncmp
,: %32
which: %32
operate: %32
on: %32
at: %32
most: %32
the: %32
first: %32
n: %32
characters: %32
of: %32
their: %32
argument: %32
strings
.: %32
For: %13
example
,: %32
strncpy
(
s
,
t
,
n
): %32
copies: %32
at: %32
most: %32
n: %32
characters: %32
of: %32
t: %32
to: %32
s
.: %32
Full: %32
descriptions: %32
are: %32
in: %32
Appendix: %32
B
.: %13
Exercise: %32
5
-
6
.: %32
Rewrite: %32
appropriate: %32
programs: %32
from: %32
earlier: %32
chapters: %32
and: %32
exercises: %32
with: %32
pointers: %32
instead: %32
of: %32
array: %32
indexing
.: %32
Good: %32
possibilities: %32
include: %32
getline: %32
(
Chapters: %32
1: %13
and: %32
4
)
,: %32
atoi
,: %32
itoa
,: %32
and: %32
their: %32
variants: %32
(
Chapters: %32
2
,: %32
3
,: %32
and: %32
4
)
,: %32
reverse: %32
(
Chapter: %32
3
)
,: %32
and: %32
strindex: %32
and: %32
getop: %32
(
Chapter: %32
4
)
.: %13
5
.
6: %32
Pointer: %32
Arrays
;: %32
Pointers: %32
to: %32
Pointers: %13
Since: %32
pointers: %32
are: %32
variables: %32
themselves
,: %32
they: %32
can: %32
be: %32
stored: %32
in: %32
arrays: %32
just: %32
as: %32
other: %32
variables: %32
can
.: %32
Let: %32
us: %32
illustrate: %32
by: %32
writing: %32
a: %32
program: %32
that: %32
will: %32
sort: %32
a: %32
set: %32
of: %32
text: %32
lines: %32
into: %13
alphabetic: %32
order
,: %32
a: %32
stripped
-
down: %32
version: %32
of: %32
the: %32
UNIX: %32
program: %32
sort
.: %13
In: %32
Chapter: %32
3
,: %32
we: %32
presented: %32
a: %32
Shell: %32
sort: %32
function: %32
that: %32
would: %32
sort: %32
an: %32
array: %32
of: %32
integers
,: %32
and: %32
in: %32
Chapter: %32
4: %32
we: %32
improved: %32
on: %32
it: %32
with: %32
a: %32
quicksort
.: %32
The: %32
same: %32
algorithms: %32
will: %32
work
,: %13
except: %32
that: %32
now: %32
we: %32
have: %32
to: %32
deal: %32
with: %32
lines: %32
of: %32
text
,: %32
which: %32
are: %32
of: %32
different: %32
lengths
,: %32
and: %32
which
,: %32
unlike: %32
integers
,: %32
can
'
t: %32
be: %32
compared: %32
or: %32
moved: %32
in: %32
a: %32
single: %32
operation
.: %32
We: %32
need: %32
a: %13
data: %32
representation: %32
that: %32
will: %32
cope: %32
efficiently: %32
and: %32
conveniently: %32
with: %32
variable
-
length: %32
text: %32
lines
.: %13
This: %32
is: %32
where: %32
the: %32
array: %32
of: %32
pointers: %32
enters
.: %32
If: %32
the: %32
lines: %32
to: %32
be: %32
sorted: %32
are: %32
stored: %32
end
-
to
-
end: %32
in: %32
one: %32
long: %32
character: %32
array
,: %32
then: %32
each: %32
line: %32
can: %32
be: %32
accessed: %32
by: %32
a: %32
pointer: %32
to: %32
its: %32
first: %13
character
.: %32
The: %32
pointers: %32
themselves: %32
can: %32
bee: %32
stored: %32
in: %32
an: %32
array
.: %32
Two: %32
lines: %32
can: %32
be: %32
compared: %32
by: %32
passing: %32
their: %32
pointers: %32
to: %32
strcmp
.: %32
When: %32
two: %32
out
-
of
-
order: %32
lines: %32
have: %32
to: %32
be: %13
exchanged
,: %32
the: %32
pointers: %32
in: %32
the: %32
pointer: %32
array: %32
are: %32
exchanged
,: %32
not: %32
the: %32
text: %32
lines: %32
themselves
.: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
This: %32
eliminates: %32
the: %32
twin: %32
problems: %32
of: %32
complicated: %32
storage: %32
management: %32
and: %32
high: %32
overhead: %32
that: %32
would: %32
go: %32
with: %32
moving: %32
the: %32
lines: %32
themselves
.: %13
The: %32
sorting: %32
process: %32
has: %32
three: %32
steps
:: %13
read: %32
all: %32
the: %32
lines: %32
of: %32
input: %13
sort: %32
them: %13
print: %32
them: %32
in: %32
order: %13
As: %32
usual
,: %32
it
'
s: %32
best: %32
to: %32
divide: %32
the: %32
program: %32
into: %32
functions: %32
that: %32
match: %32
this: %32
natural: %32
division
,: %32
with: %32
the: %32
main: %32
routine: %32
controlling: %32
the: %32
other: %32
functions
.: %32
Let: %32
us: %32
defer: %32
the: %32
sorting: %32
step: %13
for: %32
a: %32
moment
,: %32
and: %32
concentrate: %32
on: %32
the: %32
data: %32
structure: %32
and: %32
the: %32
input: %32
and: %32
output
.: %13
The: %32
input: %32
routine: %32
has: %32
to: %32
collect: %32
and: %32
save: %32
the: %32
characters: %32
of: %32
each: %32
line
,: %32
and: %32
build: %32
an: %32
array: %32
of: %32
pointers: %32
to: %32
the: %32
lines
.: %32
It: %32
will: %32
also: %32
have: %32
to: %32
count: %32
the: %32
number: %32
of: %32
input: %32
lines
,: %32
since: %13
that: %32
information: %32
is: %32
needed: %32
for: %32
sorting: %32
and: %32
printing
.: %32
Since: %32
the: %32
input: %32
function: %32
can: %32
only: %32
cope: %32
with: %32
a: %32
finite: %32
number: %32
of: %32
input: %32
lines
,: %32
it: %32
can: %32
return: %32
some: %32
illegal: %32
count: %32
like: %32
-
1: %32
if: %32
too: %13
much: %32
input: %32
is: %32
presented
.: %13
The: %32
output: %32
routine: %32
only: %32
has: %32
to: %32
print: %32
the: %32
lines: %32
in: %32
the: %32
order: %32
in: %32
which: %32
they: %32
appear: %32
in: %32
the: %32
array: %32
of: %32
pointers
.: %13
#
include: %32
<
stdio
.
h
>: %13
#
include: %32
<
string
.
h
>: %13
#
define: %32
MAXLINES: %32
5
0
0
0: %32
/
*: %32
max: %32
#
lines: %32
to: %32
be: %32
sorted: %32
*
/: %13
char: %32
*
lineptr
[
MAXLINES
]
;: %32
/
*: %32
pointers: %32
to: %32
text: %32
lines: %32
*
/: %13
int: %32
readlines
(
char: %32
*
lineptr
[
]
,: %32
int: %32
nlines
)
;: %13
void: %32
writelines
(
char: %32
*
lineptr
[
]
,: %32
int: %32
nlines
)
;: %13
void: %32
qsort
(
char: %32
*
lineptr
[
]
,: %32
int: %32
left
,: %32
int: %32
right
)
;: %13
/
*: %32
sort: %32
input: %32
lines: %32
*
/: %13
main
(
): %13
{: %13
int: %32
nlines
;: %13
/
*: %32
number: %32
of: %32
input: %32
lines: %32
read: %32
*
/: %13
if: %32
(
(
nlines: %32
=: %32
readlines
(
lineptr
,: %32
MAXLINES
)
): %32
>
=: %32
0
): %32
{: %13
qsort
(
lineptr
,: %32
0
,: %32
nlines
-
1
)
;: %13
writelines
(
lineptr
,: %32
nlines
)
;: %13
return: %32
0
;: %13
}: %32
else: %32
{: %13
printf
(
"
error
:: %32
input: %32
too: %32
big: %32
to: %32
sort
\
n
"
)
;: %13
return: %32
1
;: %13
}: %13
}: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
#
define: %32
MAXLEN: %32
1
0
0
0: %32
/
*: %32
max: %32
length: %32
of: %32
any: %32
input: %32
line: %32
*
/: %13
int: %32
getline
(
char: %32
*
,: %32
int
)
;: %13
char: %32
*
alloc
(
int
)
;: %13
/
*: %32
readlines
:: %32
read: %32
input: %32
lines: %32
*
/: %13
int: %32
readlines
(
char: %32
*
lineptr
[
]
,: %32
int: %32
maxlines
): %13
{: %13
int: %32
len
,: %32
nlines
;: %13
char: %32
*
p
,: %32
line
[
MAXLEN
]
;: %13
nlines: %32
=: %32
0
;: %13
while: %32
(
(
len: %32
=: %32
getline
(
line
,: %32
MAXLEN
)
): %32
>: %32
0
): %13
if: %32
(
nlines: %32
>
=: %32
maxlines: %32
|
|: %32
p: %32
=: %32
alloc
(
len
): %32
=
=: %32
NULL
): %13
return: %32
-
1
;: %13
else: %32
{: %13
line
[
len
-
1
]: %32
=: %32
'
\
0
'
;: %32
/
*: %32
delete: %32
newline: %32
*
/: %13
strcpy
(
p
,: %32
line
)
;: %13
lineptr
[
nlines
+
+
]: %32
=: %32
p
;: %13
}: %13
return: %32
nlines
;: %13
}: %13
/
*: %32
writelines
:: %32
write: %32
output: %32
lines: %32
*
/: %13
void: %32
writelines
(
char: %32
*
lineptr
[
]
,: %32
int: %32
nlines
): %13
{: %13
int: %32
i
;: %13
for: %32
(
i: %32
=: %32
0
;: %32
i: %32
<: %32
nlines
;: %32
i
+
+
): %13
printf
(
"
%:
s
\
n
"
,: %32
lineptr
[
i
]
)
;: %13
}: %13
The: %32
function: %32
getline: %32
is: %32
from: %32
Section: %32
1
.
9
.: %13
The: %32
main: %32
new: %32
thing: %32
is: %32
the: %32
declaration: %32
for: %32
lineptr
:: %13
char: %32
*
lineptr
[
MAXLINES
]: %13
says: %32
that: %32
lineptr: %32
is: %32
an: %32
array: %32
of: %32
MAXLINES: %32
elements
,: %32
each: %32
element: %32
of: %32
which: %32
is: %32
a: %32
pointer: %32
to: %32
a: %32
char
.: %32
That: %32
is
,: %32
lineptr
[
i
]: %32
is: %32
a: %32
character: %32
pointer
,: %32
and: %32
*
lineptr
[
i
]: %13
is: %32
the: %32
character: %32
it: %32
points: %32
to
,: %32
the: %32
first: %32
character: %32
of: %32
the: %32
i
-
th: %32
saved: %32
text: %32
line
.: %13
Since: %32
lineptr: %32
is: %32
itself: %32
the: %32
name: %32
of: %32
an: %32
array
,: %32
it: %32
can: %32
be: %32
treated: %32
as: %32
a: %32
pointer: %32
in: %32
the: %32
same: %32
manner: %32
as: %32
in: %32
our: %32
earlier: %32
examples
,: %32
and: %32
writelines: %32
can: %32
be: %32
written: %32
instead: %32
as: %13
/
*: %32
writelines
:: %13
write: %32
output: %32
lines: %32
*
/: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
void: %32
writelines
(
char: %32
*
lineptr
[
]
,: %32
int: %32
nlines
): %13
{: %13
while: %32
(
nlines
-
-: %32
>: %32
0
): %13
printf
(
"
%:
s
\
n
"
,: %32
*
lineptr
+
+
)
;: %13
}: %13
Initially
,: %32
*
lineptr: %32
points: %32
to: %32
the: %32
first: %32
line
;: %32
each: %32
element: %32
advances: %32
it: %32
to: %32
the: %32
next: %32
line: %32
pointer: %32
while: %32
nlines: %32
is: %32
counted: %32
down
.: %13
With: %32
input: %32
and: %32
output: %32
under: %32
control
,: %32
we: %32
can: %32
proceed: %32
to: %32
sorting
.: %32
The: %32
quicksort: %32
from: %32
Chapter: %32
4: %32
needs: %32
minor: %32
changes
:: %32
the: %32
declarations: %32
have: %32
to: %32
be: %32
modified
,: %32
and: %32
the: %13
comparison: %32
operation: %32
must: %32
be: %32
done: %32
by: %32
calling: %32
strcmp
.: %32
The: %32
algorithm: %32
remains: %32
the: %32
same
,: %32
which: %32
gives: %32
us: %32
some: %32
confidence: %32
that: %32
it: %32
will: %32
still: %32
work
.: %13
/
*: %32
qsort
:: %32
sort: %32
v
[
left
]
.
.
.
v
[
right
]: %32
into: %32
increasing: %32
order: %32
*
/: %13
void: %32
qsort
(
char: %32
*
v
[
]
,: %32
int: %32
left
,: %32
int: %32
right
): %13
{: %13
int: %32
i
,: %32
last
;: %13
void: %32
swap
(
char: %32
*
v
[
]
,: %32
int: %32
i
,: %32
int: %32
j
)
;: %13
if: %32
(
left: %32
>
=: %32
right
): %32
/
*: %32
do: %32
nothing: %32
if: %32
array: %32
contains: %32
*
/: %13
return
;: %13
/
*: %32
fewer: %32
than: %32
two: %32
elements: %32
*
/: %13
swap
(
v
,: %32
left
,: %32
(
left: %32
+: %32
right
)
/
2
)
;: %13
last: %32
=: %32
left
;: %13
for: %32
(
i: %32
=: %32
left
+
1
;: %32
i: %32
<
=: %32
right
;: %32
i
+
+
): %13
if: %32
(
strcmp
(
v
[
i
]
,: %32
v
[
left
]
): %32
<: %32
0
): %13
swap
(
v
,: %32
+
+
last
,: %32
i
)
;: %13
swap
(
v
,: %32
left
,: %32
last
)
;: %13
qsort
(
v
,: %32
left
,: %32
last
-
1
)
;: %13
qsort
(
v
,: %32
last
+
1
,: %32
right
)
;: %13
}: %13
Similarly
,: %32
the: %32
swap: %32
routine: %32
needs: %32
only: %32
trivial: %32
changes
:: %13
/
*: %32
swap
:: %32
interchange: %32
v
[
i
]: %32
and: %32
v
[
j
]: %32
*
/: %13
void: %32
swap
(
char: %32
*
v
[
]
,: %32
int: %32
i
,: %32
int: %32
j
): %13
{: %13
char: %32
*
temp
;: %13
temp: %32
=: %32
v
[
i
]
;: %13
v
[
i
]: %32
=: %32
v
[
j
]
;: %13
v
[
j
]: %32
=: %32
temp
;: %13
}: %13
Since: %32
any: %32
individual: %32
element: %32
of: %32
v: %32
(
alias: %32
lineptr
): %32
is: %32
a: %32
character: %32
pointer
,: %32
temp: %32
must: %32
be: %32
also
,: %32
so: %32
one: %32
can: %32
be: %32
copied: %32
to: %32
the: %32
other
.: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
Exercise: %32
5
-
7
.: %32
Rewrite: %32
readlines: %32
to: %32
store: %32
lines: %32
in: %32
an: %32
array: %32
supplied: %32
by: %32
main
,: %32
rather: %32
than: %32
calling: %32
alloc: %32
to: %32
maintain: %32
storage
.: %32
How: %32
much: %32
faster: %32
is: %32
the: %32
program
?: %13
5
.
7: %32
Multi
-
dimensional: %32
Arrays: %13
C: %32
provides: %32
rectangular: %32
multi
-
dimensional: %32
arrays
,: %32
although: %32
in: %32
practice: %32
they: %32
are: %32
much: %32
less: %32
used: %32
than: %32
arrays: %32
of: %32
pointers
.: %32
In: %32
this: %32
section
,: %32
we: %32
will: %32
show: %32
some: %32
of: %32
their: %13
properties
.: %13
Consider: %32
the: %32
problem: %32
of: %32
date: %32
conversion
,: %32
from: %32
day: %32
of: %32
the: %32
month: %32
to: %32
day: %32
of: %32
the: %32
year: %32
and: %32
vice: %32
versa
.: %32
For: %32
example
,: %32
March: %32
1: %32
is: %32
the: %32
6
0
th: %32
day: %32
of: %32
a: %32
non
-
leap: %32
year
,: %32
and: %32
the: %32
6
1
st: %13
day: %32
of: %32
a: %32
leap: %32
year
.: %32
Let: %32
us: %32
define: %32
two: %32
functions: %32
to: %32
do: %32
the: %32
conversions
:: %32
day
_
of
_
year: %32
converts: %32
the: %32
month: %32
and: %32
day: %32
into: %32
the: %32
day: %32
of: %32
the: %32
year
,: %32
and: %32
month
_
day: %32
converts: %32
the: %13
day: %32
of: %32
the: %32
year: %32
into: %32
the: %32
month: %32
and: %32
day
.: %32
Since: %32
this: %32
latter: %32
function: %32
computes: %32
two: %32
values
,: %32
the: %32
month: %32
and: %32
day: %32
arguments: %32
will: %32
be: %32
pointers
:: %13
month
_
day
(
1
9
8
8
,: %32
6
0
,: %32
&
m
,: %32
&
d
): %13
sets: %32
m: %32
to: %32
2: %32
and: %32
d: %32
to: %32
2
9: %32
(
February: %32
2
9
th
)
.: %13
These: %32
functions: %32
both: %32
need: %32
the: %32
same: %32
information
,: %32
a: %32
table: %32
of: %32
the: %32
number: %32
of: %32
days: %32
in: %32
each: %32
month: %32
(
`
`
thirty: %32
days: %32
hath: %32
September: %32
.
.
.
'
'
)
.: %32
Since: %32
the: %32
number: %32
of: %32
days: %32
per: %32
month: %13
differs: %32
for: %32
leap: %32
years: %32
and: %32
non
-
leap: %32
years
,: %32
it
'
s: %32
easier: %32
to: %32
separate: %32
them: %32
into: %32
two: %32
rows: %32
of: %32
a: %32
two
-
dimensional: %32
array: %32
than: %32
to: %32
keep: %32
track: %32
of: %32
what: %32
happens: %32
to: %32
February: %32
during: %13
computation
.: %32
The: %32
array: %32
and: %32
the: %32
functions: %32
for: %32
performing: %32
the: %32
transformations: %32
are: %32
as: %32
follows
:: %13
static: %32
char: %32
daytab
[
2
]
[
1
3
]: %32
=: %32
{: %13
{
0
,: %32
3
1
,: %32
2
8
,: %32
3
1
,: %32
3
0
,: %32
3
1
,: %32
3
0
,: %32
3
1
,: %32
3
1
,: %32
3
0
,: %32
3
1
,: %32
3
0
,: %32
3
1
}
,: %13
{
0
,: %32
3
1
,: %32
2
9
,: %32
3
1
,: %32
3
0
,: %32
3
1
,: %32
3
0
,: %32
3
1
,: %32
3
1
,: %32
3
0
,: %32
3
1
,: %32
3
0
,: %32
3
1
}: %13
}
;: %13
/
*: %32
day
_
of
_
year
:: %32
set: %32
day: %32
of: %32
year: %32
from: %32
month: %32
&: %32
day: %32
*
/: %13
int: %32
day
_
of
_
year
(
int: %32
year
,: %32
int: %32
month
,: %32
int: %32
day
): %13
{: %13
int: %32
i
,: %32
leap
;: %13
leap: %32
=: %32
year
%:
4: %32
=
=: %32
0: %32
&
&: %32
year
%:
1
0
0: %32
!
=: %32
0: %32
|
|: %32
year
%:
4
0
0: %32
=
=: %32
0
;: %13
for: %32
(
i: %32
=: %32
1
;: %32
i: %32
<: %32
month
;: %32
i
+
+
): %13
day: %32
+
=: %32
daytab
[
leap
]
[
i
]
;: %13
return: %32
day
;: %13
}: %13
/
*: %32
month
_
day
:: %32
set: %32
month
,: %32
day: %32
from: %32
day: %32
of: %32
year: %32
*
/: %13
void: %32
month
_
day
(
int: %32
year
,: %32
int: %32
yearday
,: %32
int: %32
*
pmonth
,: %32
int: %32
*
pday
): %13
{: %13
int: %32
i
,: %32
leap
;: %13
leap: %32
=: %32
year
%:
4: %32
=
=: %32
0: %32
&
&: %32
year
%:
1
0
0: %32
!
=: %32
0: %32
|
|: %32
year
%:
4
0
0: %32
=
=: %32
0
;: %13
for: %32
(
i: %32
=: %32
1
;: %32
yearday: %32
>: %32
daytab
[
leap
]
[
i
]
;: %32
i
+
+
): %13
yearday: %32
-
=: %32
daytab
[
leap
]
[
i
]
;: %13
*
pmonth: %32
=: %32
i
;: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
*
pday: %32
=: %32
yearday
;: %13
}: %13
Recall: %32
that: %32
the: %32
arithmetic: %32
value: %32
of: %32
a: %32
logical: %32
expression
,: %32
such: %32
as: %32
the: %32
one: %32
for: %32
leap
,: %32
is: %32
either: %32
zero: %32
(
false
): %32
or: %32
one: %32
(
true
)
,: %32
so: %32
it: %32
can: %32
be: %32
used: %32
as: %32
a: %32
subscript: %32
of: %32
the: %32
array: %32
daytab
.: %13
The: %32
array: %32
daytab: %32
has: %32
to: %32
be: %32
external: %32
to: %32
both: %32
day
_
of
_
year: %32
and: %32
month
_
day
,: %32
so: %32
they: %32
can: %32
both: %32
use: %32
it
.: %32
We: %32
made: %32
it: %32
char: %32
to: %32
illustrate: %32
a: %32
legitimate: %32
use: %32
of: %32
char: %32
for: %13
storing: %32
small: %32
non
-
character: %32
integers
.: %13
daytab: %32
is: %32
the: %32
first: %32
two
-
dimensional: %32
array: %32
we: %32
have: %32
dealt: %32
with
.: %32
In: %32
C
,: %32
a: %32
two
-
dimensional: %32
array: %32
is: %32
really: %32
a: %32
one
-
dimensional: %32
array
,: %32
each: %32
of: %32
whose: %32
elements: %32
is: %32
an: %32
array
.: %32
Hence: %13
subscripts: %32
are: %32
written: %32
as: %13
daytab
[
i
]
[
j
]: %13
/
*: %32
[
row
]
[
col
]: %32
*
/: %13
rather: %32
than: %13
daytab
[
i
,
j
]: %13
/
*: %32
WRONG: %32
*
/: %13
Other: %32
than: %32
this: %32
notational: %32
distinction
,: %32
a: %32
two
-
dimensional: %32
array: %32
can: %32
be: %32
treated: %32
in: %32
much: %32
the: %32
same: %32
way: %32
as: %32
in: %32
other: %32
languages
.: %32
Elements: %32
are: %32
stored: %32
by: %32
rows
,: %32
so: %32
the: %32
rightmost: %13
subscript
,: %32
or: %32
column
,: %32
varies: %32
fastest: %32
as: %32
elements: %32
are: %32
accessed: %32
in: %32
storage: %32
order
.: %13
An: %32
array: %32
is: %32
initialized: %32
by: %32
a: %32
list: %32
of: %32
initializers: %32
in: %32
braces
;: %32
each: %32
row: %32
of: %32
a: %32
two
-
dimensional: %32
array: %32
is: %32
initialized: %32
by: %32
a: %32
corresponding: %32
sub
-
list
.: %32
We: %32
started: %32
the: %32
array: %32
daytab: %32
with: %32
a: %13
column: %32
of: %32
zero: %32
so: %32
that: %32
month: %32
numbers: %32
can: %32
run: %32
from: %32
the: %32
natural: %32
1: %32
to: %32
1
2: %32
instead: %32
of: %32
0: %32
to: %32
1
1
.: %32
Since: %32
space: %32
is: %32
not: %32
at: %32
a: %32
premium: %32
here
,: %32
this: %32
is: %32
clearer: %32
than: %32
adjusting: %32
the: %32
indices
.: %13
If: %32
a: %32
two
-
dimensional: %32
array: %32
is: %32
to: %32
be: %32
passed: %32
to: %32
a: %32
function
,: %32
the: %32
parameter: %32
declaration: %32
in: %32
the: %32
function: %32
must: %32
include: %32
the: %32
number: %32
of: %32
columns
;: %32
the: %32
number: %32
of: %32
rows: %32
is: %32
irrelevant
,: %13
since: %32
what: %32
is: %32
passed: %32
is
,: %32
as: %32
before
,: %32
a: %32
pointer: %32
to: %32
an: %32
array: %32
of: %32
rows
,: %32
where: %32
each: %32
row: %32
is: %32
an: %32
array: %32
of: %32
1
3: %32
ints
.: %32
In: %32
this: %32
particular: %32
case
,: %32
it: %32
is: %32
a: %32
pointer: %32
to: %32
objects: %32
that: %32
are: %32
arrays: %32
of: %32
1
3: %13
ints
.: %32
Thus: %32
if: %32
the: %32
array: %32
daytab: %32
is: %32
to: %32
be: %32
passed: %32
to: %32
a: %32
function: %32
f
,: %32
the: %32
declaration: %32
of: %32
f: %32
would: %32
be
:: %13
f
(
int: %32
daytab
[
2
]
[
1
3
]
): %32
{: %32
.
.
.: %32
}: %13
It: %32
could: %32
also: %32
be: %13
f
(
int: %32
daytab
[
]
[
1
3
]
): %32
{: %32
.
.
.: %32
}: %13
since: %32
the: %32
number: %32
of: %32
rows: %32
is: %32
irrelevant
,: %32
or: %32
it: %32
could: %32
be: %13
f
(
int: %32
(
*
daytab
)
[
1
3
]
): %32
{: %32
.
.
.: %32
}: %13
which: %32
says: %32
that: %32
the: %32
parameter: %32
is: %32
a: %32
pointer: %32
to: %32
an: %32
array: %32
of: %32
1
3: %32
integers
.: %32
The: %32
parentheses: %32
are: %32
necessary: %32
since: %32
brackets: %32
[
]: %32
have: %32
higher: %32
precedence: %32
than: %32
*
.: %32
Without: %32
parentheses
,: %13
the: %32
declaration: %13
int: %32
*
daytab
[
1
3
]: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
is: %32
an: %32
array: %32
of: %32
1
3: %32
pointers: %32
to: %32
integers
.: %32
More: %32
generally
,: %32
only: %32
the: %32
first: %32
dimension: %32
(
subscript
): %32
of: %32
an: %32
array: %32
is: %32
free
;: %32
all: %32
the: %32
others: %32
have: %32
to: %32
be: %32
specified
.: %13
Section: %32
5
.
1
2: %32
has: %32
a: %32
further: %32
discussion: %32
of: %32
complicated: %32
declarations
.: %13
Exercise: %32
5
-
8
.: %32
There: %32
is: %32
no: %32
error: %32
checking: %32
in: %32
day
_
of
_
year: %32
or: %32
month
_
day
.: %32
Remedy: %32
this: %32
defect
.: %13
5
.
8: %32
Initialization: %32
of: %32
Pointer: %32
Arrays: %13
Consider: %32
the: %32
problem: %32
of: %32
writing: %32
a: %32
function: %32
month
_
name
(
n
)
,: %32
which: %32
returns: %32
a: %32
pointer: %32
to: %32
a: %32
character: %32
string: %32
containing: %32
the: %32
name: %32
of: %32
the: %32
n
-
th: %32
month
.: %32
This: %32
is: %32
an: %32
ideal: %13
application: %32
for: %32
an: %32
internal: %32
static: %32
array
.: %32
month
_
name: %32
contains: %32
a: %32
private: %32
array: %32
of: %32
character: %32
strings
,: %32
and: %32
returns: %32
a: %32
pointer: %32
to: %32
the: %32
proper: %32
one: %32
when: %32
called
.: %32
This: %32
section: %13
shows: %32
how: %32
that: %32
array: %32
of: %32
names: %32
is: %32
initialized
.: %13
The: %32
syntax: %32
is: %32
similar: %32
to: %32
previous: %32
initializations
:: %13
/
*: %32
month
_
name
:: %32
return: %32
name: %32
of: %32
n
-
th: %32
month: %32
*
/: %13
char: %32
*
month
_
name
(
int: %32
n
): %13
{: %13
static: %32
char: %32
*
name
[
]: %32
=: %32
{: %13
"
Illegal: %32
month
"
,: %13
"
January
"
,: %32
"
February
"
,: %32
"
March
"
,: %13
"
April
"
,: %32
"
May
"
,: %32
"
June
"
,: %13
"
July
"
,: %32
"
August
"
,: %32
"
September
"
,: %13
"
October
"
,: %32
"
November
"
,: %32
"
December
": %13
}
;: %13
return: %32
(
n: %32
<: %32
1: %32
|
|: %32
n: %32
>: %32
1
2
): %32
?: %32
name
[
0
]: %32
:: %32
name
[
n
]
;: %13
}: %13
The: %32
declaration: %32
of: %32
name
,: %32
which: %32
is: %32
an: %32
array: %32
of: %32
character: %32
pointers
,: %32
is: %32
the: %32
same: %32
as: %32
lineptr: %32
in: %32
the: %32
sorting: %32
example
.: %32
The: %32
initializer: %32
is: %32
a: %32
list: %32
of: %32
character: %32
strings
;: %32
each: %32
is: %13
assigned: %32
to: %32
the: %32
corresponding: %32
position: %32
in: %32
the: %32
array
.: %32
The: %32
characters: %32
of: %32
the: %32
i
-
th: %32
string: %32
are: %32
placed: %32
somewhere
,: %32
and: %32
a: %32
pointer: %32
to: %32
them: %32
is: %32
stored: %32
in: %32
name
[
i
]
.: %32
Since: %32
the: %32
size: %32
of: %13
the: %32
array: %32
name: %32
is: %32
not: %32
specified
,: %32
the: %32
compiler: %32
counts: %32
the: %32
initializers: %32
and: %32
fills: %32
in: %32
the: %32
correct: %32
number
.: %13
5
.
9: %32
Pointers: %32
vs
.: %32
Multi
-
dimensional: %32
Arrays: %13
Newcomers: %32
to: %32
C: %32
are: %32
sometimes: %32
confused: %32
about: %32
the: %32
difference: %32
between: %32
a: %32
two
-
dimensional: %32
array: %32
and: %32
an: %32
array: %32
of: %32
pointers
,: %32
such: %32
as: %32
name: %32
in: %32
the: %32
example: %32
above
.: %32
Given: %32
the: %13
definitions: %13
int: %32
a
[
1
0
]
[
2
0
]
;: %13
int: %32
*
b
[
1
0
]
;: %13
then: %32
a
[
3
]
[
4
]: %32
and: %32
b
[
3
]
[
4
]: %32
are: %32
both: %32
syntactically: %32
legal: %32
references: %32
to: %32
a: %32
single: %32
int
.: %32
But: %32
a: %32
is: %32
a: %32
true: %32
two
-
dimensional: %32
array
:: %32
2
0
0: %32
int
-
sized: %32
locations: %32
have: %32
been: %32
set: %32
aside
,: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
and: %32
the: %32
conventional: %32
rectangular: %32
subscript: %32
calculation: %32
2
0: %32
*: %32
row: %32
+
col: %32
is: %32
used: %32
to: %32
find: %32
the: %32
element: %32
a
[
row
,
col
]
.: %32
For: %32
b
,: %32
however
,: %32
the: %32
definition: %32
only: %32
allocates: %32
1
0: %32
pointers: %13
and: %32
does: %32
not: %32
initialize: %32
them
;: %32
initialization: %32
must: %32
be: %32
done: %32
explicitly
,: %32
either: %32
statically: %32
or: %32
with: %32
code
.: %32
Assuming: %32
that: %32
each: %32
element: %32
of: %32
b: %32
does: %32
point: %32
to: %32
a: %32
twenty
-
element: %32
array
,: %13
then: %32
there: %32
will: %32
be: %32
2
0
0: %32
ints: %32
set: %32
aside
,: %32
plus: %32
ten: %32
cells: %32
for: %32
the: %32
pointers
.: %32
The: %32
important: %32
advantage: %32
of: %32
the: %32
pointer: %32
array: %32
is: %32
that: %32
the: %32
rows: %32
of: %32
the: %32
array: %32
may: %32
be: %32
of: %32
different: %32
lengths
.: %13
That: %32
is
,: %32
each: %32
element: %32
of: %32
b: %32
need: %32
not: %32
point: %32
to: %32
a: %32
twenty
-
element: %32
vector
;: %32
some: %32
may: %32
point: %32
to: %32
two: %32
elements
,: %32
some: %32
to: %32
fifty
,: %32
and: %32
some: %32
to: %32
none: %32
at: %32
all
.: %13
Although: %32
we: %32
have: %32
phrased: %32
this: %32
discussion: %32
in: %32
terms: %32
of: %32
integers
,: %32
by: %32
far: %32
the: %32
most: %32
frequent: %32
use: %32
of: %32
arrays: %32
of: %32
pointers: %32
is: %32
to: %32
store: %32
character: %32
strings: %32
of: %32
diverse: %32
lengths
,: %32
as: %32
in: %32
the: %13
function: %32
month
_
name
.: %32
Compare: %32
the: %32
declaration: %32
and: %32
picture: %32
for: %32
an: %32
array: %32
of: %32
pointers
:: %13
char: %32
*
name
[
]: %32
=: %32
{: %32
"
Illegal: %32
month
"
,: %32
"
Jan
"
,: %32
"
Feb
"
,: %32
"
Mar
": %32
}
;: %13
with: %32
those: %32
for: %32
a: %32
two
-
dimensional: %32
array
:: %13
char: %32
aname
[
]
[
1
5
]: %32
=: %32
{: %32
"
Illegal: %32
month
"
,: %32
"
Jan
"
,: %32
"
Feb
"
,: %32
"
Mar
": %32
}
;: %13
Exercise: %32
5
-
9
.: %32
Rewrite: %32
the: %32
routines: %32
day
_
of
_
year: %32
and: %32
month
_
day: %32
with: %32
pointers: %32
instead: %32
of: %32
indexing
.: %13
5
.
1
0: %32
Command
-
line: %32
Arguments: %13
In: %32
environments: %32
that: %32
support: %32
C
,: %32
there: %32
is: %32
a: %32
way: %32
to: %32
pass: %32
command
-
line: %32
arguments: %32
or: %32
parameters: %32
to: %32
a: %32
program: %32
when: %32
it: %32
begins: %32
executing
.: %32
When: %32
main: %32
is: %32
called
,: %32
it: %32
is: %32
called: %13
with: %32
two: %32
arguments
.: %32
The: %32
first: %32
(
conventionally: %32
called: %32
argc
,: %32
for: %32
argument: %32
count
): %32
is: %32
the: %32
number: %32
of: %32
command
-
line: %32
arguments: %32
the: %32
program: %32
was: %32
invoked: %32
with
;: %32
the: %32
second: %13
(
argv
,: %32
for: %32
argument: %32
vector
): %32
is: %32
a: %32
pointer: %32
to: %32
an: %32
array: %32
of: %32
character: %32
strings: %32
that: %32
contain: %32
the: %32
arguments
,: %32
one: %32
per: %32
string
.: %32
We: %32
customarily: %32
use: %32
multiple: %32
levels: %32
of: %32
pointers: %32
to: %13
manipulate: %32
these: %32
character: %32
strings
.: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
The: %32
simplest: %32
illustration: %32
is: %32
the: %32
program: %32
echo
,: %32
which: %32
echoes: %32
its: %32
command
-
line: %32
arguments: %32
on: %32
a: %32
single: %32
line
,: %32
separated: %32
by: %32
blanks
.: %32
That: %32
is
,: %32
the: %32
command: %13
echo: %32
hello
,: %32
world: %13
prints: %32
the: %32
output: %13
hello
,: %32
world: %13
By: %32
convention
,: %32
argv
[
0
]: %32
is: %32
the: %32
name: %32
by: %32
which: %32
the: %32
program: %32
was: %32
invoked
,: %32
so: %32
argc: %32
is: %32
at: %32
least: %32
1
.: %32
If: %32
argc: %32
is: %32
1
,: %32
there: %32
are: %32
no: %32
command
-
line: %32
arguments: %32
after: %32
the: %32
program: %13
name
.: %32
In: %32
the: %32
example: %32
above
,: %32
argc: %32
is: %32
3
,: %32
and: %32
argv
[
0
]
,: %32
argv
[
1
]
,: %32
and: %32
argv
[
2
]: %32
are: %32
"
echo
"
,: %32
"
hello
,
"
,: %32
and: %32
"
world
": %32
respectively
.: %32
The: %32
first: %32
optional: %32
argument: %32
is: %13
argv
[
1
]: %32
and: %32
the: %32
last: %32
is: %32
argv
[
argc
-
1
]
;: %32
additionally
,: %32
the: %32
standard: %32
requires: %32
that: %32
argv
[
argc
]: %32
be: %32
a: %32
null: %32
pointer
.: %13
The: %32
first: %32
version: %32
of: %32
echo: %32
treats: %32
argv: %32
as: %32
an: %32
array: %32
of: %32
character: %32
pointers
:: %13
#
include: %32
<
stdio
.
h
>: %13
/
*: %32
echo: %32
command
-
line: %32
arguments
;: %32
1
st: %32
version: %32
*
/: %13
main
(
int: %32
argc
,: %32
char: %32
*
argv
[
]
): %13
{: %13
int: %32
i
;: %13
for: %32
(
i: %32
=: %32
1
;: %32
i: %32
<: %32
argc
;: %32
i
+
+
): %13
printf
(
"
%:
s
%:
s
"
,: %32
argv
[
i
]
,: %32
(
i: %32
<: %32
argc
-
1
): %32
?: %32
": %32
": %32
:: %32
"
"
)
;: %13
printf
(
"
\
n
"
)
;: %13
return: %32
0
;: %13
}: %13
Since: %32
argv: %32
is: %32
a: %32
pointer: %32
to: %32
an: %32
array: %32
of: %32
pointers
,: %32
we: %32
can: %32
manipulate: %32
the: %32
pointer: %32
rather: %32
than: %32
index: %32
the: %32
array
.: %32
This: %32
next: %32
variant: %32
is: %32
based: %32
on: %32
incrementing: %32
argv
,: %32
which: %32
is: %32
a: %13
pointer: %32
to: %32
pointer: %32
to: %32
char
,: %32
while: %32
argc: %32
is: %32
counted: %32
down
:: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
#
include: %32
<
stdio
.
h
>: %13
/
*: %32
echo: %32
command
-
line: %32
arguments
;: %32
2
nd: %32
version: %32
*
/: %13
main
(
int: %32
argc
,: %32
char: %32
*
argv
[
]
): %13
{: %13
while: %32
(
-
-
argc: %32
>: %32
0
): %13
printf
(
"
%:
s
%:
s
"
,: %32
*
+
+
argv
,: %32
(
argc: %32
>: %32
1
): %32
?: %32
": %32
": %32
:: %32
"
"
)
;: %13
printf
(
"
\
n
"
)
;: %13
return: %32
0
;: %13
}: %13
Since: %32
argv: %32
is: %32
a: %32
pointer: %32
to: %32
the: %32
beginning: %32
of: %32
the: %32
array: %32
of: %32
argument: %32
strings
,: %32
incrementing: %32
it: %32
by: %32
1: %32
(
+
+
argv
): %32
makes: %32
it: %32
point: %32
at: %32
the: %32
original: %32
argv
[
1
]: %32
instead: %32
of: %32
argv
[
0
]
.: %13
Each: %32
successive: %32
increment: %32
moves: %32
it: %32
along: %32
to: %32
the: %32
next: %32
argument
;: %32
*
argv: %32
is: %32
then: %32
the: %32
pointer: %32
to: %32
that: %32
argument
.: %32
At: %32
the: %32
same: %32
time
,: %32
argc: %32
is: %32
decremented
;: %32
when: %32
it: %32
becomes: %13
zero
,: %32
there: %32
are: %32
no: %32
arguments: %32
left: %32
to: %32
print
.: %13
Alternatively
,: %32
we: %32
could: %32
write: %32
the: %32
printf: %32
statement: %32
as: %13
printf
(
(
argc: %32
>: %32
1
): %32
?: %32
"
%:
s: %32
": %32
:: %32
"
%:
s
"
,: %32
*
+
+
argv
)
;: %13
This: %32
shows: %32
that: %32
the: %32
format: %32
argument: %32
of: %32
printf: %32
can: %32
be: %32
an: %32
expression: %32
too
.: %13
As: %32
a: %32
second: %32
example
,: %32
let: %32
us: %32
make: %32
some: %32
enhancements: %32
to: %32
the: %32
pattern
-
finding: %32
program: %32
from: %32
Section: %32
4
.
1
.: %32
If: %32
you: %32
recall
,: %32
we: %32
wired: %32
the: %32
search: %32
pattern: %32
deep: %32
into: %32
the: %32
program
,: %32
an: %13
obviously: %32
unsatisfactory: %32
arrangement
.: %32
Following: %32
the: %32
lead: %32
of: %32
the: %32
UNIX: %32
program: %32
grep
,: %32
let: %32
us: %32
enhance: %32
the: %32
program: %32
so: %32
the: %32
pattern: %32
to: %32
be: %32
matched: %32
is: %32
specified: %32
by: %32
the: %32
first: %13
argument: %32
on: %32
the: %32
command: %32
line
.: %13
#
include: %32
<
stdio
.
h
>: %13
#
include: %32
<
string
.
h
>: %13
#
define: %32
MAXLINE: %32
1
0
0
0: %13
int: %32
getline
(
char: %32
*
line
,: %32
int: %32
max
)
;: %13
/
*: %32
find
:: %32
print: %32
lines: %32
that: %32
match: %32
pattern: %32
from: %32
1
st: %32
arg: %32
*
/: %13
main
(
int: %32
argc
,: %32
char: %32
*
argv
[
]
): %13
{: %13
char: %32
line
[
MAXLINE
]
;: %13
int: %32
found: %32
=: %32
0
;: %13
if: %32
(
argc: %32
!
=: %32
2
): %13
printf
(
"
Usage
:: %32
find: %32
pattern
\
n
"
)
;: %13
else: %13
while: %32
(
getline
(
line
,: %32
MAXLINE
): %32
>: %32
0
): %13
if: %32
(
strstr
(
line
,: %32
argv
[
1
]
): %32
!
=: %32
NULL
): %32
{: %13
printf
(
"
%:
s
"
,: %32
line
)
;: %13
found
+
+
;: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
}: %13
return: %32
found
;: %13
}: %13
The: %32
standard: %32
library: %32
function: %32
strstr
(
s
,
t
): %32
returns: %32
a: %32
pointer: %32
to: %32
the: %32
first: %32
occurrence: %32
of: %32
the: %32
string: %32
t: %32
in: %32
the: %32
string: %32
s
,: %32
or: %32
NULL: %32
if: %32
there: %32
is: %32
none
.: %32
It: %32
is: %32
declared: %32
in: %13
<
string
.
h
>
.: %13
The: %32
model: %32
can: %32
now: %32
be: %32
elaborated: %32
to: %32
illustrate: %32
further: %32
pointer: %32
constructions
.: %32
Suppose: %32
we: %32
want: %32
to: %32
allow: %32
two: %32
optional: %32
arguments
.: %32
One: %32
says: %32
`
`
print: %32
all: %32
the: %32
lines: %32
except: %32
those: %13
that: %32
match: %32
the: %32
pattern
;
'
': %32
the: %32
second: %32
says: %32
`
`
precede: %32
each: %32
printed: %32
line: %32
by: %32
its: %32
line: %32
number
.
'
': %13
A: %32
common: %32
convention: %32
for: %32
C: %32
programs: %32
on: %32
UNIX: %32
systems: %32
is: %32
that: %32
an: %32
argument: %32
that: %32
begins: %32
with: %32
a: %32
minus: %32
sign: %32
introduces: %32
an: %32
optional: %32
flag: %32
or: %32
parameter
.: %32
If: %32
we: %32
choose: %32
-
x: %32
(
for: %13
`
`
except
'
'
): %32
to: %32
signal: %32
the: %32
inversion
,: %32
and: %32
-
n: %32
(
`
`
number
'
'
): %32
to: %32
request: %32
line: %32
numbering
,: %32
then: %32
the: %32
command: %13
find: %32
-
x: %32
-
npattern: %13
will: %32
print: %32
each: %32
line: %32
that: %32
doesn
'
t: %32
match: %32
the: %32
pattern
,: %32
preceded: %32
by: %32
its: %32
line: %32
number
.: %13
Optional: %32
arguments: %32
should: %32
be: %32
permitted: %32
in: %32
any: %32
order
,: %32
and: %32
the: %32
rest: %32
of: %32
the: %32
program: %32
should: %32
be: %32
independent: %32
of: %32
the: %32
number: %32
of: %32
arguments: %32
that: %32
we: %32
present
.: %32
Furthermore
,: %32
it: %32
is: %13
convenient: %32
for: %32
users: %32
if: %32
option: %32
arguments: %32
can: %32
be: %32
combined
,: %32
as: %32
in: %13
find: %32
-
nx: %32
pattern: %13
Here: %32
is: %32
the: %32
program
:: %13
#
include: %32
<
stdio
.
h
>: %13
#
include: %32
<
string
.
h
>: %13
#
define: %32
MAXLINE: %32
1
0
0
0: %13
int: %32
getline
(
char: %32
*
line
,: %32
int: %32
max
)
;: %13
/
*: %32
find
:: %32
print: %32
lines: %32
that: %32
match: %32
pattern: %32
from: %32
1
st: %32
arg: %32
*
/: %13
main
(
int: %32
argc
,: %32
char: %32
*
argv
[
]
): %13
{: %13
char: %32
line
[
MAXLINE
]
;: %13
long: %32
lineno: %32
=: %32
0
;: %13
int: %32
c
,: %32
except: %32
=: %32
0
,: %32
number: %32
=: %32
0
,: %32
found: %32
=: %32
0
;: %13
while: %32
(
-
-
argc: %32
>: %32
0: %32
&
&: %32
(
*
+
+
argv
)
[
0
]: %32
=
=: %32
'
-
'
): %13
while: %32
(
c: %32
=: %32
*
+
+
argv
[
0
]
): %13
switch: %32
(
c
): %32
{: %13
case: %32
'
x
'
:: %13
except: %32
=: %32
1
;: %13
break
;: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
case: %32
'
n
'
:: %13
number: %32
=: %32
1
;: %13
break
;: %13
default
:: %13
printf
(
"
find
:: %32
illegal: %32
option: %32
%:
c
\
n
"
,: %32
c
)
;: %13
argc: %32
=: %32
0
;: %13
found: %32
=: %32
-
1
;: %13
break
;: %13
}: %13
if: %32
(
argc: %32
!
=: %32
1
): %13
printf
(
"
Usage
:: %32
find: %32
-
x: %32
-
n: %32
pattern
\
n
"
)
;: %13
else: %13
while: %32
(
getline
(
line
,: %32
MAXLINE
): %32
>: %32
0
): %32
{: %13
lineno
+
+
;: %13
if: %32
(
(
strstr
(
line
,: %32
*
argv
): %32
!
=: %32
NULL
): %32
!
=: %32
except
): %32
{: %13
if: %32
(
number
): %13
printf
(
"
%:
ld
::
"
,: %32
lineno
)
;: %13
printf
(
"
%:
s
"
,: %32
line
)
;: %13
found
+
+
;: %13
}: %13
}: %13
return: %32
found
;: %13
}: %13
argc: %32
is: %32
decremented: %32
and: %32
argv: %32
is: %32
incremented: %32
before: %32
each: %32
optional: %32
argument
.: %32
At: %32
the: %32
end: %32
of: %32
the: %32
loop
,: %32
if: %32
there: %32
are: %32
no: %32
errors
,: %32
argc: %32
tells: %32
how: %32
many: %32
arguments: %32
remain: %13
unprocessed: %32
and: %32
argv: %32
points: %32
to: %32
the: %32
first: %32
of: %32
these
.: %32
Thus: %32
argc: %32
should: %32
be: %32
1: %32
and: %32
*
argv: %32
should: %32
point: %32
at: %32
the: %32
pattern
.: %32
Notice: %32
that: %32
*
+
+
argv: %32
is: %32
a: %32
pointer: %32
to: %32
an: %32
argument: %32
string
,: %13
so: %32
(
*
+
+
argv
)
[
0
]: %32
is: %32
its: %32
first: %32
character
.: %32
(
An: %32
alternate: %32
valid: %32
form: %32
would: %32
be: %32
*
*
+
+
argv
.
): %32
Because: %32
[
]: %32
binds: %32
tighter: %32
than: %32
*: %32
and: %32
+
+
,: %32
the: %32
parentheses: %32
are: %32
necessary
;: %32
without: %13
them: %32
the: %32
expression: %32
would: %32
be: %32
taken: %32
as: %32
*
+
+
(
argv
[
0
]
)
.: %32
In: %32
fact
,: %32
that: %32
is: %32
what: %32
we: %32
have: %32
used: %32
in: %32
the: %32
inner: %32
loop
,: %32
where: %32
the: %32
task: %32
is: %32
to: %32
walk: %32
along: %32
a: %32
specific: %32
argument: %32
string
.: %32
In: %13
the: %32
inner: %32
loop
,: %32
the: %32
expression: %32
*
+
+
argv
[
0
]: %32
increments: %32
the: %32
pointer: %32
argv
[
0
]
!: %13
It: %32
is: %32
rare: %32
that: %32
one: %32
uses: %32
pointer: %32
expressions: %32
more: %32
complicated: %32
than: %32
these
;: %32
in: %32
such: %32
cases
,: %32
breaking: %32
them: %32
into: %32
two: %32
or: %32
three: %32
steps: %32
will: %32
be: %32
more: %32
intuitive
.: %13
Exercise: %32
5
-
1
0
.: %32
Write: %32
the: %32
program: %32
expr
,: %32
which: %32
evaluates: %32
a: %32
reverse: %32
Polish: %32
expression: %32
from: %32
the: %32
command: %32
line
,: %32
where: %32
each: %32
operator: %32
or: %32
operand: %32
is: %32
a: %32
separate: %32
argument
.: %32
For: %13
example
,: %13
expr: %32
2: %32
3: %32
4: %32
+: %32
*: %13
evaluates: %32
2: %32
*: %32
(
3
+
4
)
.: %13
Exercise: %32
5
-
1
1
.: %32
Modify: %32
the: %32
program: %32
entab: %32
and: %32
detab: %32
(
written: %32
as: %32
exercises: %32
in: %32
Chapter: %32
1
): %32
to: %32
accept: %32
a: %32
list: %32
of: %32
tab: %32
stops: %32
as: %32
arguments
.: %32
Use: %32
the: %32
default: %32
tab: %32
settings: %32
if: %32
there: %13
are: %32
no: %32
arguments
.: %13
Exercise: %32
5
-
1
2
.: %32
Extend: %32
entab: %32
and: %32
detab: %32
to: %32
accept: %32
the: %32
shorthand: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
entab: %32
-
m: %32
+
n: %13
to: %32
mean: %32
tab: %32
stops: %32
every: %32
n: %32
columns
,: %32
starting: %32
at: %32
column: %32
m
.: %32
Choose: %32
convenient: %32
(
for: %32
the: %32
user
): %32
default: %32
behavior
.: %13
Exercise: %32
5
-
1
3
.: %32
Write: %32
the: %32
program: %32
tail
,: %32
which: %32
prints: %32
the: %32
last: %32
n: %32
lines: %32
of: %32
its: %32
input
.: %32
By: %32
default
,: %32
n: %32
is: %32
set: %32
to: %32
1
0
,: %32
let: %32
us: %32
say
,: %32
but: %32
it: %32
can: %32
be: %32
changed: %32
by: %32
an: %32
optional: %32
argument: %32
so: %13
that: %13
tail: %32
-
n: %13
prints: %32
the: %32
last: %32
n: %32
lines
.: %32
The: %32
program: %32
should: %32
behave: %32
rationally: %32
no: %32
matter: %32
how: %32
unreasonable: %32
the: %32
input: %32
or: %32
the: %32
value: %32
of: %32
n
.: %32
Write: %32
the: %32
program: %32
so: %32
it: %32
makes: %32
the: %32
best: %32
use: %32
of: %13
available: %32
storage
;: %32
lines: %32
should: %32
be: %32
stored: %32
as: %32
in: %32
the: %32
sorting: %32
program: %32
of: %32
Section: %32
5
.
6
,: %32
not: %32
in: %32
a: %32
two
-
dimensional: %32
array: %32
of: %32
fixed: %32
size
.: %13
5
.
1
1: %32
Pointers: %32
to: %32
Functions: %13
In: %32
C
,: %32
a: %32
function: %32
itself: %32
is: %32
not: %32
a: %32
variable
,: %32
but: %32
it: %32
is: %32
possible: %32
to: %32
define: %32
pointers: %32
to: %32
functions
,: %32
which: %32
can: %32
be: %32
assigned
,: %32
placed: %32
in: %32
arrays
,: %32
passed: %32
to: %32
functions
,: %32
returned: %32
by: %32
functions
,: %13
and: %32
so: %32
on
.: %32
We: %32
will: %32
illustrate: %32
this: %32
by: %32
modifying: %32
the: %32
sorting: %32
procedure: %32
written: %32
earlier: %32
in: %32
this: %32
chapter: %32
so: %32
that: %32
if: %32
the: %32
optional: %32
argument: %32
-
n: %32
is: %32
given
,: %32
it: %32
will: %32
sort: %32
the: %32
input: %32
lines: %13
numerically: %32
instead: %32
of: %32
lexicographically
.: %13
A: %32
sort: %32
often: %32
consists: %32
of: %32
three: %32
parts: %32
-: %32
a: %32
comparison: %32
that: %32
determines: %32
the: %32
ordering: %32
of: %32
any: %32
pair: %32
of: %32
objects
,: %32
an: %32
exchange: %32
that: %32
reverses: %32
their: %32
order
,: %32
and: %32
a: %32
sorting: %32
algorithm: %32
that: %13
makes: %32
comparisons: %32
and: %32
exchanges: %32
until: %32
the: %32
objects: %32
are: %32
in: %32
order
.: %32
The: %32
sorting: %32
algorithm: %32
is: %32
independent: %32
of: %32
the: %32
comparison: %32
and: %32
exchange: %32
operations
,: %32
so: %32
by: %32
passing: %32
different: %13
comparison: %32
and: %32
exchange: %32
functions: %32
to: %32
it
,: %32
we: %32
can: %32
arrange: %32
to: %32
sort: %32
by: %32
different: %32
criteria
.: %32
This: %32
is: %32
the: %32
approach: %32
taken: %32
in: %32
our: %32
new: %32
sort
.: %13
Lexicographic: %32
comparison: %32
of: %32
two: %32
lines: %32
is: %32
done: %32
by: %32
strcmp
,: %32
as: %32
before
;: %32
we: %32
will: %32
also: %32
need: %32
a: %32
routine: %32
numcmp: %32
that: %32
compares: %32
two: %32
lines: %32
on: %32
the: %32
basis: %32
of: %32
numeric: %32
value: %32
and: %13
returns: %32
the: %32
same: %32
kind: %32
of: %32
condition: %32
indication: %32
as: %32
strcmp: %32
does
.: %32
These: %32
functions: %32
are: %32
declared: %32
ahead: %32
of: %32
main: %32
and: %32
a: %32
pointer: %32
to: %32
the: %32
appropriate: %32
one: %32
is: %32
passed: %32
to: %32
qsort
.: %32
We: %13
have: %32
skimped: %32
on: %32
error: %32
processing: %32
for: %32
arguments
,: %32
so: %32
as: %32
to: %32
concentrate: %32
on: %32
the: %32
main: %32
issues
.: %13
#
include: %32
<
stdio
.
h
>: %13
#
include: %32
<
string
.
h
>: %13
#
define: %32
MAXLINES: %32
5
0
0
0: %13
char: %32
*
lineptr
[
MAXLINES
]
;: %13
/
*: %32
max: %32
#
lines: %32
to: %32
be: %32
sorted: %32
*
/: %13
/
*: %32
pointers: %32
to: %32
text: %32
lines: %32
*
/: %13
int: %32
readlines
(
char: %32
*
lineptr
[
]
,: %32
int: %32
nlines
)
;: %13
void: %32
writelines
(
char: %32
*
lineptr
[
]
,: %32
int: %32
nlines
)
;: %13
void: %32
qsort
(
void: %32
*
lineptr
[
]
,: %32
int: %32
left
,: %32
int: %32
right
,: %13
int: %32
(
*
comp
)
(
void: %32
*
,: %32
void: %32
*
)
)
;: %13
int: %32
numcmp
(
char: %32
*
,: %32
char: %32
*
)
;: %13
/
*: %32
sort: %32
input: %32
lines: %32
*
/: %13
main
(
int: %32
argc
,: %32
char: %32
*
argv
[
]
): %13
{: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
int: %32
nlines
;: %13
int: %32
numeric: %32
=: %32
0
;: %13
/
*: %32
number: %32
of: %32
input: %32
lines: %32
read: %32
*
/: %13
/
*: %32
1: %32
if: %32
numeric: %32
sort: %32
*
/: %13
if: %32
(
argc: %32
>: %32
1: %32
&
&: %32
strcmp
(
argv
[
1
]
,: %32
"
-
n
"
): %32
=
=: %32
0
): %13
numeric: %32
=: %32
1
;: %13
if: %32
(
(
nlines: %32
=: %32
readlines
(
lineptr
,: %32
MAXLINES
)
): %32
>
=: %32
0
): %32
{: %13
qsort
(
(
void
*
*
): %32
lineptr
,: %32
0
,: %32
nlines
-
1
,: %13
(
int: %32
(
*
)
(
void
*
,
void
*
)
)
(
numeric: %32
?: %32
numcmp: %32
:: %32
strcmp
)
)
;: %13
writelines
(
lineptr
,: %32
nlines
)
;: %13
return: %32
0
;: %13
}: %32
else: %32
{: %13
printf
(
"
input: %32
too: %32
big: %32
to: %32
sort
\
n
"
)
;: %13
return: %32
1
;: %13
}: %13
}: %13
In: %32
the: %32
call: %32
to: %32
qsort
,: %32
strcmp: %32
and: %32
numcmp: %32
are: %32
addresses: %32
of: %32
functions
.: %32
Since: %32
they: %32
are: %32
known: %32
to: %32
be: %32
functions
,: %32
the: %32
&: %32
is: %32
not: %32
necessary
,: %32
in: %32
the: %32
same: %32
way: %32
that: %32
it: %32
is: %32
not: %32
needed: %13
before: %32
an: %32
array: %32
name
.: %13
We: %32
have: %32
written: %32
qsort: %32
so: %32
it: %32
can: %32
process: %32
any: %32
data: %32
type
,: %32
not: %32
just: %32
character: %32
strings
.: %32
As: %32
indicated: %32
by: %32
the: %32
function: %32
prototype
,: %32
qsort: %32
expects: %32
an: %32
array: %32
of: %32
pointers
,: %32
two: %13
integers
,: %32
and: %32
a: %32
function: %32
with: %32
two: %32
pointer: %32
arguments
.: %32
The: %32
generic: %32
pointer: %32
type: %32
void: %32
*: %32
is: %32
used: %32
for: %32
the: %32
pointer: %32
arguments
.: %32
Any: %32
pointer: %32
can: %32
be: %32
cast: %32
to: %32
void: %32
*: %32
and: %32
back: %13
again: %32
without: %32
loss: %32
of: %32
information
,: %32
so: %32
we: %32
can: %32
call: %32
qsort: %32
by: %32
casting: %32
arguments: %32
to: %32
void: %32
*
.: %32
The: %32
elaborate: %32
cast: %32
of: %32
the: %32
function: %32
argument: %32
casts: %32
the: %32
arguments: %32
of: %32
the: %13
comparison: %32
function
.: %32
These: %32
will: %32
generally: %32
have: %32
no: %32
effect: %32
on: %32
actual: %32
representation
,: %32
but: %32
assure: %32
the: %32
compiler: %32
that: %32
all: %32
is: %32
well
.: %13
/
*: %32
qsort
:: %32
sort: %32
v
[
left
]
.
.
.
v
[
right
]: %32
into: %32
increasing: %32
order: %32
*
/: %13
void: %32
qsort
(
void: %32
*
v
[
]
,: %32
int: %32
left
,: %32
int: %32
right
,: %13
int: %32
(
*
comp
)
(
void: %32
*
,: %32
void: %32
*
)
): %13
{: %13
int: %32
i
,: %32
last
;: %13
void: %32
swap
(
void: %32
*
v
[
]
,: %32
int
,: %32
int
)
;: %13
if: %32
(
left: %32
>
=: %32
right
): %13
/
*: %32
do: %32
nothing: %32
if: %32
array: %32
contains: %32
*
/: %13
return
;: %13
/
*: %32
fewer: %32
than: %32
two: %32
elements: %32
*
/: %13
swap
(
v
,: %32
left
,: %32
(
left: %32
+: %32
right
)
/
2
)
;: %13
last: %32
=: %32
left
;: %13
for: %32
(
i: %32
=: %32
left
+
1
;: %32
i: %32
<
=: %32
right
;: %32
i
+
+
): %13
if: %32
(
(
*
comp
)
(
v
[
i
]
,: %32
v
[
left
]
): %32
<: %32
0
): %13
swap
(
v
,: %32
+
+
last
,: %32
i
)
;: %13
swap
(
v
,: %32
left
,: %32
last
)
;: %13
qsort
(
v
,: %32
left
,: %32
last
-
1
,: %32
comp
)
;: %13
qsort
(
v
,: %32
last
+
1
,: %32
right
,: %32
comp
)
;: %13
}: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
The: %32
declarations: %32
should: %32
be: %32
studied: %32
with: %32
some: %32
care
.: %32
The: %32
fourth: %32
parameter: %32
of: %32
qsort: %32
is: %13
int: %32
(
*
comp
)
(
void: %32
*
,: %32
void: %32
*
): %13
which: %32
says: %32
that: %32
comp: %32
is: %32
a: %32
pointer: %32
to: %32
a: %32
function: %32
that: %32
has: %32
two: %32
void: %32
*: %32
arguments: %32
and: %32
returns: %32
an: %32
int
.: %13
The: %32
use: %32
of: %32
comp: %32
in: %32
the: %32
line: %13
if: %32
(
(
*
comp
)
(
v
[
i
]
,: %32
v
[
left
]
): %32
<: %32
0
): %13
is: %32
consistent: %32
with: %32
the: %32
declaration
:: %32
comp: %32
is: %32
a: %32
pointer: %32
to: %32
a: %32
function
,: %32
*
comp: %32
is: %32
the: %32
function
,: %32
and: %13
(
*
comp
)
(
v
[
i
]
,: %32
v
[
left
]
): %13
is: %32
the: %32
call: %32
to: %32
it
.: %32
The: %32
parentheses: %32
are: %32
needed: %32
so: %32
the: %32
components: %32
are: %32
correctly: %32
associated
;: %32
without: %32
them
,: %13
int: %32
*
comp
(
void: %32
*
,: %32
void: %32
*
): %13
/
*: %32
WRONG: %32
*
/: %13
says: %32
that: %32
comp: %32
is: %32
a: %32
function: %32
returning: %32
a: %32
pointer: %32
to: %32
an: %32
int
,: %32
which: %32
is: %32
very: %32
different
.: %13
We: %32
have: %32
already: %32
shown: %32
strcmp
,: %32
which: %32
compares: %32
two: %32
strings
.: %32
Here: %32
is: %32
numcmp
,: %32
which: %32
compares: %32
two: %32
strings: %32
on: %32
a: %32
leading: %32
numeric: %32
value
,: %32
computed: %32
by: %32
calling: %32
atof
:: %13
#
include: %32
<
stdlib
.
h
>: %13
/
*: %32
numcmp
:: %32
compare: %32
s
1: %32
and: %32
s
2: %32
numerically: %32
*
/: %13
int: %32
numcmp
(
char: %32
*
s
1
,: %32
char: %32
*
s
2
): %13
{: %13
double: %32
v
1
,: %32
v
2
;: %13
v
1: %32
=: %32
atof
(
s
1
)
;: %13
v
2: %32
=: %32
atof
(
s
2
)
;: %13
if: %32
(
v
1: %32
<: %32
v
2
): %13
return: %32
-
1
;: %13
else: %32
if: %32
(
v
1: %32
>: %32
v
2
): %13
return: %32
1
;: %13
else: %13
return: %32
0
;: %13
}: %13
The: %32
swap: %32
function
,: %32
which: %32
exchanges: %32
two: %32
pointers
,: %32
is: %32
identical: %32
to: %32
what: %32
we: %32
presented: %32
earlier: %32
in: %32
the: %32
chapter
,: %32
except: %32
that: %32
the: %32
declarations: %32
are: %32
changed: %32
to: %32
void: %32
*
.: %13
void: %32
swap
(
void: %32
*
v
[
]
,: %13
{: %13
int: %32
i
,: %32
int: %32
j
;
): %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
void: %32
*
temp
;: %13
temp: %32
=: %32
v
[
i
]
;: %13
v
[
i
]: %32
=: %32
v
[
j
]
;: %13
v
[
j
]: %32
=: %32
temp
;: %13
}: %13
A: %32
variety: %32
of: %32
other: %32
options: %32
can: %32
be: %32
added: %32
to: %32
the: %32
sorting: %32
program
;: %32
some: %32
make: %32
challenging: %32
exercises
.: %13
Exercise: %32
5
-
1
4
.: %32
Modify: %32
the: %32
sort: %32
program: %32
to: %32
handle: %32
a: %32
-
r: %32
flag
,: %32
which: %32
indicates: %32
sorting: %32
in: %32
reverse: %32
(
decreasing
): %32
order
.: %32
Be: %32
sure: %32
that: %32
-
r: %32
works: %32
with: %32
-
n
.: %13
Exercise: %32
5
-
1
5
.: %32
Add: %32
the: %32
option: %32
-
f: %32
to: %32
fold: %32
upper: %32
and: %32
lower: %32
case: %32
together
,: %32
so: %32
that: %32
case: %32
distinctions: %32
are: %32
not: %32
made: %32
during: %32
sorting
;: %32
for: %32
example
,: %32
a: %32
and: %32
A: %32
compare: %32
equal
.: %13
Exercise: %32
5
-
1
6
.: %32
Add: %32
the: %32
-
d: %32
(
`
`
directory: %32
order
'
'
): %32
option
,: %32
which: %32
makes: %32
comparisons: %32
only: %32
on: %32
letters
,: %32
numbers: %32
and: %32
blanks
.: %32
Make: %32
sure: %32
it: %32
works: %32
in: %32
conjunction: %32
with: %32
-
f
.: %13
Exercise: %32
5
-
1
7
.: %32
Add: %32
a: %32
field
-
searching: %32
capability
,: %32
so: %32
sorting: %32
may: %32
bee: %32
done: %32
on: %32
fields: %32
within: %32
lines
,: %32
each: %32
field: %32
sorted: %32
according: %32
to: %32
an: %32
independent: %32
set: %32
of: %32
options
.: %32
(
The: %32
index: %32
for: %13
this: %32
book: %32
was: %32
sorted: %32
with: %32
-
df: %32
for: %32
the: %32
index: %32
category: %32
and: %32
-
n: %32
for: %32
the: %32
page: %32
numbers
.
): %13
5
.
1
2: %32
Complicated: %32
Declarations: %13
C: %32
is: %32
sometimes: %32
castigated: %32
for: %32
the: %32
syntax: %32
of: %32
its: %32
declarations
,: %32
particularly: %32
ones: %32
that: %32
involve: %32
pointers: %32
to: %32
functions
.: %32
The: %32
syntax: %32
is: %32
an: %32
attempt: %32
to: %32
make: %32
the: %32
declaration: %32
and: %32
the: %13
use: %32
agree
;: %32
it: %32
works: %32
well: %32
for: %32
simple: %32
cases
,: %32
but: %32
it: %32
can: %32
be: %32
confusing: %32
for: %32
the: %32
harder: %32
ones
,: %32
because: %32
declarations: %32
cannot: %32
be: %32
read: %32
left: %32
to: %32
right
,: %32
and: %32
because: %32
parentheses: %32
are: %32
over
-: %13
used
.: %32
The: %32
difference: %32
between: %13
int: %32
*
f
(
)
;: %32
/
*: %32
f
:: %32
function: %32
returning: %32
pointer: %32
to: %32
int: %32
*
/: %13
int: %32
(
*
pf
)
(
)
;: %32
/
*: %32
pf
:: %32
pointer: %32
to: %32
function: %32
returning: %32
int: %32
*
/: %13
and: %13
illustrates: %32
the: %32
problem
:: %32
*: %32
is: %32
a: %32
prefix: %32
operator: %32
and: %32
it: %32
has: %32
lower: %32
precedence: %32
than: %32
(
)
,: %32
so: %32
parentheses: %32
are: %32
necessary: %32
to: %32
force: %32
the: %32
proper: %32
association
.: %13
Although: %32
truly: %32
complicated: %32
declarations: %32
rarely: %32
arise: %32
in: %32
practice
,: %32
it: %32
is: %32
important: %32
to: %32
know: %32
how: %32
to: %32
understand: %32
them
,: %32
and
,: %32
if: %32
necessary
,: %32
how: %32
to: %32
create: %32
them
.: %32
One: %32
good: %32
way: %32
to: %13
synthesize: %32
declarations: %32
is: %32
in: %32
small: %32
steps: %32
with: %32
typedef
,: %32
which: %32
is: %32
discussed: %32
in: %32
Section: %32
6
.
7
.: %32
As: %32
an: %32
alternative
,: %32
in: %32
this: %32
section: %32
we: %32
will: %32
present: %32
a: %32
pair: %32
of: %32
programs: %32
that: %32
convert: %13
from: %32
valid: %32
C: %32
to: %32
a: %32
word: %32
description: %32
and: %32
back: %32
again
.: %32
The: %32
word: %32
description: %32
reads: %32
left: %32
to: %32
right
.: %13
The: %32
first
,: %32
dcl
,: %32
is: %32
the: %32
more: %32
complex
.: %32
It: %32
converts: %32
a: %32
C: %32
declaration: %32
into: %32
a: %32
word: %32
description
,: %32
as: %32
in: %32
these: %32
examples
:: %13
char: %32
*
*
argv: %13
argv
:: %32
pointer: %32
to: %32
char: %13
int: %32
(
*
daytab
)
[
1
3
]: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
daytab
:: %32
pointer: %32
to: %32
array
[
1
3
]: %32
of: %32
int: %13
int: %32
*
daytab
[
1
3
]: %13
daytab
:: %32
array
[
1
3
]: %32
of: %32
pointer: %32
to: %32
int: %13
void: %32
*
comp
(
): %13
comp
:: %32
function: %32
returning: %32
pointer: %32
to: %32
void: %13
void: %32
(
*
comp
)
(
): %13
comp
:: %32
pointer: %32
to: %32
function: %32
returning: %32
void: %13
char: %32
(
*
(
*
x
(
)
)
[
]
)
(
): %13
x
:: %32
function: %32
returning: %32
pointer: %32
to: %32
array
[
]: %32
of: %13
pointer: %32
to: %32
function: %32
returning: %32
char: %13
char: %32
(
*
(
*
x
[
3
]
)
(
)
)
[
5
]: %13
x
:: %32
array
[
3
]: %32
of: %32
pointer: %32
to: %32
function: %32
returning: %13
pointer: %32
to: %32
array
[
5
]: %32
of: %32
char: %13
dcl: %32
is: %32
based: %32
on: %32
the: %32
grammar: %32
that: %32
specifies: %32
a: %32
declarator
,: %32
which: %32
is: %32
spelled: %32
out: %32
precisely: %32
in: %32
Appendix: %32
A
,: %32
Section: %32
8
.
5
;: %32
this: %32
is: %32
a: %32
simplified: %32
form
:: %13
dcl
:: %13
optional: %32
*
'
s: %32
direct
-
dcl: %13
direct
-
dcl: %32
name: %13
(
dcl
): %13
direct
-
dcl
(
): %13
direct
-
dcl
[
optional: %32
size
]: %13
In: %32
words
,: %32
a: %32
dcl: %32
is: %32
a: %32
direct
-
dcl
,: %32
perhaps: %32
preceded: %32
by: %32
*
'
s
.: %32
A: %32
direct
-
dcl: %32
is: %32
a: %32
name
,: %32
or: %32
a: %32
parenthesized: %32
dcl
,: %32
or: %32
a: %32
direct
-
dcl: %32
followed: %32
by: %32
parentheses
,: %32
or: %32
a: %32
direct
-
dcl: %32
followed: %32
by: %13
brackets: %32
with: %32
an: %32
optional: %32
size
.: %13
This: %32
grammar: %32
can: %32
be: %32
used: %32
to: %32
parse: %32
functions
.: %32
For: %32
instance
,: %32
consider: %32
this: %32
declarator
:: %13
(
*
pfa
[
]
)
(
): %13
pfa: %32
will: %32
be: %32
identified: %32
as: %32
a: %32
name: %32
and: %32
thus: %32
as: %32
a: %32
direct
-
dcl
.: %32
Then: %32
pfa
[
]: %32
is: %32
also: %32
a: %32
direct
-
dcl
.: %32
Then: %32
*
pfa
[
]: %32
is: %32
recognized: %32
as: %32
a: %32
dcl
,: %32
so: %32
(
*
pfa
[
]
): %32
is: %32
a: %32
direct
-
dcl
.: %32
Then: %13
(
*
pfa
[
]
)
(
): %32
is: %32
a: %32
direct
-
dcl: %32
and: %32
thus: %32
a: %32
dcl
.: %32
We: %32
can: %32
also: %32
illustrate: %32
the: %32
parse: %32
with: %32
a: %32
tree: %32
like: %32
this: %32
(
where: %32
direct
-
dcl: %32
has: %32
been: %32
abbreviated: %32
to: %32
dir
-
dcl
)
:: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
The: %32
heart: %32
of: %32
the: %32
dcl: %32
program: %32
is: %32
a: %32
pair: %32
of: %32
functions
,: %32
dcl: %32
and: %32
dirdcl
,: %32
that: %32
parse: %32
a: %32
declaration: %32
according: %32
to: %32
this: %32
grammar
.: %32
Because: %32
the: %32
grammar: %32
is: %32
recursively: %32
defined
,: %13
the: %32
functions: %32
call: %32
each: %32
other: %32
recursively: %32
as: %32
they: %32
recognize: %32
pieces: %32
of: %32
a: %32
declaration
;: %32
the: %32
program: %32
is: %32
called: %32
a: %32
recursive
-
descent: %32
parser
.: %13
/
*: %32
dcl
:: %32
parse: %32
a: %32
declarator: %32
*
/: %13
void: %32
dcl
(
void
): %13
{: %13
int: %32
ns
;: %13
for: %32
(
ns: %32
=: %32
0
;: %32
gettoken
(
): %32
=
=: %32
'
*
'
;: %32
): %32
/
*: %32
count: %32
*
'
s: %32
*
/: %13
ns
+
+
;: %13
dirdcl
(
)
;: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
while: %32
(
ns
-
-: %32
>: %32
0
): %13
strcat
(
out
,: %32
": %32
pointer: %32
to
"
)
;: %13
}: %13
/
*: %32
dirdcl
:: %32
parse: %32
a: %32
direct: %32
declarator: %32
*
/: %13
void: %32
dirdcl
(
void
): %13
{: %13
int: %32
type
;: %13
if: %32
(
tokentype: %32
=
=: %32
'
(
'
): %32
{: %13
/
*: %32
(: %32
dcl: %32
): %32
*
/: %13
dcl
(
)
;: %13
if: %32
(
tokentype: %32
!
=: %32
'
)
'
): %13
printf
(
"
error
:: %32
missing: %32
)
\
n
"
)
;: %13
}: %32
else: %32
if: %32
(
tokentype: %32
=
=: %32
NAME
): %32
/
*: %32
variable: %32
name: %32
*
/: %13
strcpy
(
name
,: %32
token
)
;: %13
else: %13
printf
(
"
error
:: %32
expected: %32
name: %32
or: %32
(
dcl
)
\
n
"
)
;: %13
while: %32
(
(
type
=
gettoken
(
)
): %32
=
=: %32
PARENS: %32
|
|: %32
type: %32
=
=: %32
BRACKETS
): %13
if: %32
(
type: %32
=
=: %32
PARENS
): %13
strcat
(
out
,: %32
": %32
function: %32
returning
"
)
;: %13
else: %32
{: %13
strcat
(
out
,: %32
": %32
array
"
)
;: %13
strcat
(
out
,: %32
token
)
;: %13
strcat
(
out
,: %32
": %32
of
"
)
;: %13
}: %13
}: %13
Since: %32
the: %32
programs: %32
are: %32
intended: %32
to: %32
be: %32
illustrative
,: %32
not: %32
bullet
-
proof
,: %32
there: %32
are: %32
significant: %32
restrictions: %32
on: %32
dcl
.: %32
It: %32
can: %32
only: %32
handle: %32
a: %32
simple: %32
data: %32
type: %32
line: %32
char: %32
or: %32
int
.: %32
It: %13
does: %32
not: %32
handle: %32
argument: %32
types: %32
in: %32
functions
,: %32
or: %32
qualifiers: %32
like: %32
const
.: %32
Spurious: %32
blanks: %32
confuse: %32
it
.: %32
It: %32
doesn
'
t: %32
do: %32
much: %32
error: %32
recovery
,: %32
so: %32
invalid: %32
declarations: %32
will: %32
also: %13
confuse: %32
it
.: %32
These: %32
improvements: %32
are: %32
left: %32
as: %32
exercises
.: %13
Here: %32
are: %32
the: %32
global: %32
variables: %32
and: %32
the: %32
main: %32
routine
:: %13
#
include: %32
<
stdio
.
h
>: %13
#
include: %32
<
string
.
h
>: %13
#
include: %32
<
ctype
.
h
>: %13
#
define: %32
MAXTOKEN: %13
1
0
0: %13
enum: %32
{: %32
NAME
,: %32
PARENS
,: %32
BRACKETS: %32
}
;: %13
void: %32
dcl
(
void
)
;: %13
void: %32
dirdcl
(
void
)
;: %13
int: %32
gettoken
(
void
)
;: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
int: %32
tokentype
;: %13
char: %32
token
[
MAXTOKEN
]
;: %13
char: %32
name
[
MAXTOKEN
]
;: %13
char: %32
datatype
[
MAXTOKEN
]
;: %13
char: %32
out
[
1
0
0
0
]
;: %13
/
*: %13
/
*: %13
/
*: %13
/
*: %13
type: %32
of: %32
last: %32
token: %32
*
/: %13
last: %32
token: %32
string: %32
*
/: %13
identifier: %32
name: %32
*
/: %13
data: %32
type: %32
=: %32
char
,: %32
int
,: %32
etc
.: %32
*
/: %13
main
(
): %32
/
*: %32
convert: %32
declaration: %32
to: %32
words: %32
*
/: %13
{: %13
while: %32
(
gettoken
(
): %32
!
=: %32
EOF
): %32
{: %13
/
*: %32
1
st: %32
token: %32
on: %32
line: %32
*
/: %13
strcpy
(
datatype
,: %32
token
)
;: %32
/
*: %32
is: %32
the: %32
datatype: %32
*
/: %13
out
[
0
]: %32
=: %32
'
\
0
'
;: %13
dcl
(
)
;: %13
/
*: %32
parse: %32
rest: %32
of: %32
line: %32
*
/: %13
if: %32
(
tokentype: %32
!
=: %32
'
\
n
'
): %13
printf
(
"
syntax: %32
error
\
n
"
)
;: %13
printf
(
"
%:
s
:: %32
%:
s: %32
%:
s
\
n
"
,: %32
name
,: %32
out
,: %32
datatype
)
;: %13
}: %13
return: %32
0
;: %13
}: %13
The: %32
function: %32
gettoken: %32
skips: %32
blanks: %32
and: %32
tabs
,: %32
then: %32
finds: %32
the: %32
next: %32
token: %32
in: %32
the: %32
input
;: %32
a: %32
`
`
token
'
': %32
is: %32
a: %32
name
,: %32
a: %32
pair: %32
of: %32
parentheses
,: %32
a: %32
pair: %32
of: %32
brackets: %32
perhaps: %32
including: %32
a: %13
number
,: %32
or: %32
any: %32
other: %32
single: %32
character
.: %13
int: %32
gettoken
(
void
): %32
/
*: %32
return: %32
next: %32
token: %32
*
/: %13
{: %13
int: %32
c
,: %32
getch
(
void
)
;: %13
void: %32
ungetch
(
int
)
;: %13
char: %32
*
p: %32
=: %32
token
;: %13
while: %32
(
(
c: %32
=: %32
getch
(
)
): %32
=
=: %32
': %32
': %32
|
|: %32
c: %32
=
=: %32
'
\
t
'
): %13
;: %13
if: %32
(
c: %32
=
=: %32
'
(
'
): %32
{: %13
if: %32
(
(
c: %32
=: %32
getch
(
)
): %32
=
=: %32
'
)
'
): %32
{: %13
strcpy
(
token
,: %32
"
(
)
"
)
;: %13
return: %32
tokentype: %32
=: %32
PARENS
;: %13
}: %32
else: %32
{: %13
ungetch
(
c
)
;: %13
return: %32
tokentype: %32
=: %32
'
(
'
;: %13
}: %13
}: %32
else: %32
if: %32
(
c: %32
=
=: %32
'
[
'
): %32
{: %13
for: %32
(
*
p
+
+: %32
=: %32
c
;: %32
(
*
p
+
+: %32
=: %32
getch
(
)
): %32
!
=: %32
'
]
'
;: %32
): %13
;: %13
*
p: %32
=: %32
'
\
0
'
;: %13
return: %32
tokentype: %32
=: %32
BRACKETS
;: %13
}: %32
else: %32
if: %32
(
isalpha
(
c
)
): %32
{: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
for: %32
(
*
p
+
+: %32
=: %32
c
;: %32
isalnum
(
c: %32
=: %32
getch
(
)
)
;: %32
): %13
*
p
+
+: %32
=: %32
c
;: %13
*
p: %32
=: %32
'
\
0
'
;: %13
ungetch
(
c
)
;: %13
return: %32
tokentype: %32
=: %32
NAME
;: %13
}: %32
else: %13
return: %32
tokentype: %32
=: %32
c
;: %13
}: %13
getch: %32
and: %32
ungetch: %32
are: %32
discussed: %32
in: %32
Chapter: %32
4
.: %13
Going: %32
in: %32
the: %32
other: %32
direction: %32
is: %32
easier
,: %32
especially: %32
if: %32
we: %32
do: %32
not: %32
worry: %32
about: %32
generating: %32
redundant: %32
parentheses
.: %32
The: %32
program: %32
undcl: %32
converts: %32
a: %32
word: %32
description: %32
like: %32
`
`
x: %32
is: %32
a: %13
function: %32
returning: %32
a: %32
pointer: %32
to: %32
an: %32
array: %32
of: %32
pointers: %32
to: %32
functions: %32
returning: %32
char
,
'
': %32
which: %32
we: %32
will: %32
express: %32
as: %13
x: %32
(
): %32
*: %32
[
]: %32
*: %32
(
): %32
char: %13
to: %13
char: %32
(
*
(
*
x
(
)
)
[
]
)
(
): %13
The: %32
abbreviated: %32
input: %32
syntax: %32
lets: %32
us: %32
reuse: %32
the: %32
gettoken: %32
function
.: %32
undcl: %32
also: %32
uses: %32
the: %32
same: %32
external: %32
variables: %32
as: %32
dcl: %32
does
.: %13
/
*: %32
undcl
:: %32
convert: %32
word: %32
descriptions: %32
to: %32
declarations: %32
*
/: %13
main
(
): %13
{: %13
int: %32
type
;: %13
char: %32
temp
[
MAXTOKEN
]
;: %13
while: %32
(
gettoken
(
): %32
!
=: %32
EOF
): %32
{: %13
strcpy
(
out
,: %32
token
)
;: %13
while: %32
(
(
type: %32
=: %32
gettoken
(
)
): %32
!
=: %32
'
\
n
'
): %13
if: %32
(
type: %32
=
=: %32
PARENS: %32
|
|: %32
type: %32
=
=: %32
BRACKETS
): %13
strcat
(
out
,: %32
token
)
;: %13
else: %32
if: %32
(
type: %32
=
=: %32
'
*
'
): %32
{: %13
sprintf
(
temp
,: %32
"
(
*
%:
s
)
"
,: %32
out
)
;: %13
strcpy
(
out
,: %32
temp
)
;: %13
}: %32
else: %32
if: %32
(
type: %32
=
=: %32
NAME
): %32
{: %13
sprintf
(
temp
,: %32
"
%:
s: %32
%:
s
"
,: %32
token
,: %32
out
)
;: %13
strcpy
(
out
,: %32
temp
)
;: %13
}: %32
else: %13
printf
(
"
invalid: %32
input: %32
at: %32
%:
s
\
n
"
,: %32
token
)
;: %13
}: %13
Chapter: %32
5: %32
-: %32
Pointers: %32
and: %32
Arrays: %13
return: %32
0
;: %13
}: %13
Exercise: %32
5
-
1
8
.: %32
Make: %32
dcl: %32
recover: %32
from: %32
input: %32
errors
.: %13
Exercise: %32
5
-
1
9
.: %32
Modify: %32
undcl: %32
so: %32
that: %32
it: %32
does: %32
not: %32
add: %32
redundant: %32
parentheses: %32
to: %32
declarations
.: %13
Exercise: %32
5
-
2
0
.: %32
Expand: %32
dcl: %32
to: %32
handle: %32
declarations: %32
with: %32
function: %32
argument: %32
types
,: %32
qualifiers: %32
like: %32
const
,: %32
and: %32
so: %32
on
.: %13
Back: %32
to: %32
Chapter: %32
4: %32
-
-: %32
Index: %32
-
-: %32
Chapter: %32
6: %13
Chapter: %32
6: %32
-: %32
Structures: %13
Back: %32
to: %32
Chapter: %32
5: %32
-
-: %32
Index: %32
-
-: %32
Chapter: %32
7: %13
Chapter: %32
6: %32
-: %32
Structures: %13
A: %32
structure: %32
is: %32
a: %32
collection: %32
of: %32
one: %32
or: %32
more: %32
variables
,: %32
possibly: %32
of: %32
different: %32
types
,: %32
grouped: %32
together: %32
under: %32
a: %13
single: %32
name: %32
for: %32
convenient: %32
handling
.: %32
(
Structures: %32
are: %32
called: %32
`
`
records
'
': %32
in: %32
some: %32
languages
,: %32
notably: %13
Pascal
.
): %32
Structures: %32
help: %32
to: %32
organize: %32
complicated: %32
data
,: %32
particularly: %32
in: %32
large: %32
programs
,: %32
because: %32
they: %32
permit: %13
a: %32
group: %32
of: %32
related: %32
variables: %32
to: %32
be: %32
treated: %32
as: %32
a: %32
unit: %32
instead: %32
of: %32
as: %32
separate: %32
entities
.: %13
One: %32
traditional: %32
example: %32
of: %32
a: %32
structure: %32
is: %32
the: %32
payroll: %32
record
:: %32
an: %32
employee: %32
is: %32
described: %32
by: %32
a: %32
set: %32
of: %13
attributes: %32
such: %32
as: %32
name
,: %32
address
,: %32
social: %32
security: %32
number
,: %32
salary
,: %32
etc
.: %32
Some: %32
of: %32
these: %32
in: %32
turn: %32
could: %32
be: %13
structures
:: %32
a: %32
name: %32
has: %32
several: %32
components
,: %32
as: %32
does: %32
an: %32
address: %32
and: %32
even: %32
a: %32
salary
.: %32
Another: %32
example
,: %32
more: %13
typical: %32
for: %32
C
,: %32
comes: %32
from: %32
graphics
:: %32
a: %32
point: %32
is: %32
a: %32
pair: %32
of: %32
coordinate
,: %32
a: %32
rectangle: %32
is: %32
a: %32
pair: %32
of: %32
points
,: %32
and: %32
so: %13
on
.: %13
The: %32
main: %32
change: %32
made: %32
by: %32
the: %32
ANSI: %32
standard: %32
is: %32
to: %32
define: %32
structure: %32
assignment: %32
-: %32
structures: %32
may: %32
be: %32
copied: %13
and: %32
assigned: %32
to
,: %32
passed: %32
to: %32
functions
,: %32
and: %32
returned: %32
by: %32
functions
.: %32
This: %32
has: %32
been: %32
supported: %32
by: %32
most: %13
compilers: %32
for: %32
many: %32
years
,: %32
but: %32
the: %32
properties: %32
are: %32
now: %32
precisely: %32
defined
.: %32
Automatic: %32
structures: %32
and: %32
arrays: %13
may: %32
now: %32
also: %32
be: %32
initialized
.: %13
6
.
1: %32
Basics: %32
of: %32
Structures: %13
Let: %32
us: %32
create: %32
a: %32
few: %32
structures: %32
suitable: %32
for: %32
graphics
.: %32
The: %32
basic: %32
object: %32
is: %32
a: %32
point
,: %32
which: %32
we: %32
will: %32
assume: %32
has: %13
an: %32
x: %32
coordinate: %32
and: %32
a: %32
y: %32
coordinate
,: %32
both: %32
integers
.: %13
Chapter: %32
6: %32
-: %32
Structures: %13
The: %32
two: %32
components: %32
can: %32
be: %32
placed: %32
in: %32
a: %32
structure: %32
declared: %32
like: %32
this
:: %13
struct: %32
point: %32
{: %13
int: %32
x
;: %13
int: %32
y
;: %13
}
;: %13
The: %32
keyword: %32
struct: %32
introduces: %32
a: %32
structure: %32
declaration
,: %32
which: %32
is: %32
a: %32
list: %32
of: %32
declarations: %32
enclosed: %32
in: %13
braces
.: %32
An: %32
optional: %32
name: %32
called: %32
a: %32
structure: %32
tag: %32
may: %32
follow: %32
the: %32
word: %32
struct: %32
(
as: %32
with: %32
point: %32
here
)
.: %13
The: %32
tag: %32
names: %32
this: %32
kind: %32
of: %32
structure
,: %32
and: %32
can: %32
be: %32
used: %32
subsequently: %32
as: %32
a: %32
shorthand: %32
for: %32
the: %32
part: %32
of: %32
the: %13
declaration: %32
in: %32
braces
.: %13
The: %32
variables: %32
named: %32
in: %32
a: %32
structure: %32
are: %32
called: %32
members
.: %32
A: %32
structure: %32
member: %32
or: %32
tag: %32
and: %32
an: %32
ordinary: %32
(
i
.
e
.
,: %13
non
-
member
): %32
variable: %32
can: %32
have: %32
the: %32
same: %32
name: %32
without: %32
conflict
,: %32
since: %32
they: %32
can: %32
always: %32
be: %32
distinguished: %13
by: %32
context
.: %32
Furthermore
,: %32
the: %32
same: %32
member: %32
names: %32
may: %32
occur: %32
in: %32
different: %32
structures
,: %32
although: %32
as: %32
a: %32
matter: %13
of: %32
style: %32
one: %32
would: %32
normally: %32
use: %32
the: %32
same: %32
names: %32
only: %32
for: %32
closely: %32
related: %32
objects
.: %13
A: %32
struct: %32
declaration: %32
defines: %32
a: %32
type
.: %32
The: %32
right: %32
brace: %32
that: %32
terminates: %32
the: %32
list: %32
of: %32
members: %32
may: %32
be: %13
followed: %32
by: %32
a: %32
list: %32
of: %32
variables
,: %32
just: %32
as: %32
for: %32
any: %32
basic: %32
type
.: %32
That: %32
is
,: %13
struct: %32
{: %32
.
.
.: %32
}: %32
x
,: %32
y
,: %32
z
;: %13
is: %32
syntactically: %32
analogous: %32
to: %13
int: %32
x
,: %32
y
,: %32
z
;: %13
in: %32
the: %32
sense: %32
that: %32
each: %32
statement: %32
declares: %32
x
,: %32
y: %32
and: %32
z: %32
to: %32
be: %32
variables: %32
of: %32
the: %32
named: %32
type: %32
and: %32
causes: %32
space: %32
to: %13
be: %32
set: %32
aside: %32
for: %32
them
.: %13
Chapter: %32
6: %32
-: %32
Structures: %13
A: %32
structure: %32
declaration: %32
that: %32
is: %32
not: %32
followed: %32
by: %32
a: %32
list: %32
of: %32
variables: %32
reserves: %32
no: %32
storage
;: %32
it: %32
merely: %32
describes: %32
a: %13
template: %32
or: %32
shape: %32
of: %32
a: %32
structure
.: %32
If: %32
the: %32
declaration: %32
is: %32
tagged
,: %32
however
,: %32
the: %32
tag: %32
can: %32
be: %32
used: %32
later: %32
in: %13
definitions: %32
of: %32
instances: %32
of: %32
the: %32
structure
.: %32
For: %32
example
,: %32
given: %32
the: %32
declaration: %32
of: %32
point: %32
above
,: %13
struct: %32
point: %32
pt
;: %13
defines: %32
a: %32
variable: %32
pt: %32
which: %32
is: %32
a: %32
structure: %32
of: %32
type: %32
struct: %32
point
.: %32
A: %32
structure: %32
can: %32
be: %32
initialized: %32
by: %13
following: %32
its: %32
definition: %32
with: %32
a: %32
list: %32
of: %32
initializers
,: %32
each: %32
a: %32
constant: %32
expression
,: %32
for: %32
the: %32
members
:: %13
struct: %32
maxpt: %32
=: %32
{: %32
3
2
0
,: %32
2
0
0: %32
}
;: %13
An: %32
automatic: %32
structure: %32
may: %32
also: %32
be: %32
initialized: %32
by: %32
assignment: %32
or: %32
by: %32
calling: %32
a: %32
function: %32
that: %32
returns: %32
a: %13
structure: %32
of: %32
the: %32
right: %32
type
.: %13
A: %32
member: %32
of: %32
a: %32
particular: %32
structure: %32
is: %32
referred: %32
to: %32
in: %32
an: %32
expression: %32
by: %32
a: %32
construction: %32
of: %32
the: %32
form: %13
structure
-
name
.
member: %13
The: %32
structure: %32
member: %32
operator: %32
`
`
.
'
': %32
connects: %32
the: %32
structure: %32
name: %32
and: %32
the: %32
member: %32
name
.: %32
To: %32
print: %32
the: %13
coordinates: %32
of: %32
the: %32
point: %32
pt
,: %32
for: %32
instance
,: %13
printf
(
"
%:
d
,
%:
d
"
,: %32
pt
.
x
,: %32
pt
.
y
)
;: %13
or: %32
to: %32
compute: %32
the: %32
distance: %32
from: %32
the: %32
origin: %32
(
0
,
0
): %32
to: %32
pt
,: %13
double: %32
dist
,: %32
sqrt
(
double
)
;: %13
dist: %32
=: %32
sqrt
(
(
double
)
pt
.
x: %32
*: %32
pt
.
x: %32
+: %32
(
double
)
pt
.
y: %32
*: %32
pt
.
y
)
;: %13
Structures: %32
can: %32
be: %32
nested
.: %32
One: %32
representation: %32
of: %32
a: %32
rectangle: %32
is: %32
a: %32
pair: %32
of: %32
points: %32
that: %32
denote: %32
the: %32
diagonally: %13
opposite: %32
corners
:: %13
Chapter: %32
6: %32
-: %32
Structures: %13
struct: %32
rect: %32
{: %13
struct: %32
point: %32
pt
1
;: %13
struct: %32
point: %32
pt
2
;: %13
}
;: %13
The: %32
rect: %32
structure: %32
contains: %32
two: %32
point: %32
structures
.: %32
If: %32
we: %32
declare: %32
screen: %32
as: %13
struct: %32
rect: %32
screen
;: %13
then: %13
screen
.
pt
1
.
x: %13
refers: %32
to: %32
the: %32
x: %32
coordinate: %32
of: %32
the: %32
pt
1: %32
member: %32
of: %32
screen
.: %13
6
.
2: %32
Structures: %32
and: %32
Functions: %13
The: %32
only: %32
legal: %32
operations: %32
on: %32
a: %32
structure: %32
are: %32
copying: %32
it: %32
or: %32
assigning: %32
to: %32
it: %32
as: %32
a: %32
unit
,: %32
taking: %32
its: %32
address: %32
with: %13
&
,: %32
and: %32
accessing: %32
its: %32
members
.: %32
Copy: %32
and: %32
assignment: %32
include: %32
passing: %32
arguments: %32
to: %32
functions: %32
and: %13
returning: %32
values: %32
from: %32
functions: %32
as: %32
well
.: %32
Structures: %32
may: %32
not: %32
be: %32
compared
.: %32
A: %32
structure: %32
may: %32
be: %32
initialized: %13
by: %32
a: %32
list: %32
of: %32
constant: %32
member: %32
values
;: %32
an: %32
automatic: %32
structure: %32
may: %32
also: %32
be: %32
initialized: %32
by: %32
an: %32
assignment
.: %13
Let: %32
us: %32
investigate: %32
structures: %32
by: %32
writing: %32
some: %32
functions: %32
to: %32
manipulate: %32
points: %32
and: %32
rectangles
.: %32
There: %32
are: %32
at: %13
least: %32
three: %32
possible: %32
approaches
:: %32
pass: %32
components: %32
separately
,: %32
pass: %32
an: %32
entire: %32
structure
,: %32
or: %32
pass: %32
a: %32
pointer: %32
to: %13
it
.: %32
Each: %32
has: %32
its: %32
good: %32
points: %32
and: %32
bad: %32
points
.: %13
The: %32
first: %32
function
,: %32
makepoint
,: %32
will: %32
take: %32
two: %32
integers: %32
and: %32
return: %32
a: %32
point: %32
structure
:: %13
/
*: %32
makepoint
:: %13
make: %32
a: %32
point: %32
from: %32
x: %32
and: %32
y: %32
components: %32
*
/: %13
Chapter: %32
6: %32
-: %32
Structures: %13
struct: %32
point: %32
makepoint
(
int: %32
x
,: %32
int: %32
y
): %13
{: %13
struct: %32
point: %32
temp
;: %13
temp
.
x: %32
=: %32
x
;: %13
temp
.
y: %32
=: %32
y
;: %13
return: %32
temp
;: %13
}: %13
Notice: %32
that: %32
there: %32
is: %32
no: %32
conflict: %32
between: %32
the: %32
argument: %32
name: %32
and: %32
the: %32
member: %32
with: %32
the: %32
same: %32
name
;: %32
indeed: %13
the: %32
re
-
use: %32
of: %32
the: %32
names: %32
stresses: %32
the: %32
relationship
.: %13
makepoint: %32
can: %32
now: %32
be: %32
used: %32
to: %32
initialize: %32
any: %32
structure: %32
dynamically
,: %32
or: %32
to: %32
provide: %32
structure: %32
arguments: %13
to: %32
a: %32
function
:: %13
struct: %32
rect: %32
screen
;: %13
struct: %32
point: %32
middle
;: %13
struct: %32
point: %32
makepoint
(
int
,: %32
int
)
;: %13
screen
.
pt
1: %32
=: %32
makepoint
(
0
,
0
)
;: %13
screen
.
pt
2: %32
=: %32
makepoint
(
XMAX
,: %32
YMAX
)
;: %13
middle: %32
=: %32
makepoint
(
(
screen
.
pt
1
.
x: %32
+: %32
screen
.
pt
2
.
x
)
/
2
,: %13
(
screen
.
pt
1
.
y: %32
+: %32
screen
.
pt
2
.
y
)
/
2
)
;: %13
The: %32
next: %32
step: %32
is: %32
a: %32
set: %32
of: %32
functions: %32
to: %32
do: %32
arithmetic: %32
on: %32
points
.: %32
For: %32
instance
,: %13
/
*: %32
addpoints
:: %32
add: %32
two: %32
points: %32
*
/: %13
struct: %32
addpoint
(
struct: %32
point: %32
p
1
,: %32
struct: %32
point: %32
p
2
): %13
{: %13
p
1
.
x: %32
+
=: %32
p
2
.
x
;: %13
p
1
.
y: %32
+
=: %32
p
2
.
y
;: %13
return: %32
p
1
;: %13
}: %13
Here: %32
both: %32
the: %32
arguments: %32
and: %32
the: %32
return: %32
value: %32
are: %32
structures
.: %32
We: %32
incremented: %32
the: %32
components: %32
in: %32
p
1: %13
rather: %32
than: %32
using: %32
an: %32
explicit: %32
temporary: %32
variable: %32
to: %32
emphasize: %32
that: %32
structure: %32
parameters: %32
are: %32
passed: %32
by: %13
value: %32
like: %32
any: %32
others
.: %13
As: %32
another: %32
example
,: %32
the: %32
function: %32
ptinrect: %32
tests: %32
whether: %32
a: %32
point: %32
is: %32
inside: %32
a: %32
rectangle
,: %32
where: %32
we: %32
have: %13
adopted: %32
the: %32
convention: %32
that: %32
a: %32
rectangle: %32
includes: %32
its: %32
left: %32
and: %32
bottom: %32
sides: %32
but: %32
not: %32
its: %32
top: %32
and: %32
right: %32
sides
:: %13
/
*: %32
ptinrect
:: %13
return: %32
1: %32
if: %32
p: %32
in: %32
r
,: %32
0: %32
if: %32
not: %32
*
/: %13
Chapter: %32
6: %32
-: %32
Structures: %13
int: %32
ptinrect
(
struct: %32
point: %32
p
,: %32
struct: %32
rect: %32
r
): %13
{: %13
return: %32
p
.
x: %32
>
=: %32
r
.
pt
1
.
x: %32
&
&: %32
p
.
x: %32
<: %32
r
.
pt
2
.
x: %13
&
&: %32
p
.
y: %32
>
=: %32
r
.
pt
1
.
y: %32
&
&: %32
p
.
y: %32
<: %32
r
.
pt
2
.
y
;: %13
}: %13
This: %32
assumes: %32
that: %32
the: %32
rectangle: %32
is: %32
presented: %32
in: %32
a: %32
standard: %32
form: %32
where: %32
the: %32
pt
1: %32
coordinates: %32
are: %32
less: %32
than: %13
the: %32
pt
2: %32
coordinates
.: %32
The: %32
following: %32
function: %32
returns: %32
a: %32
rectangle: %32
guaranteed: %32
to: %32
be: %32
in: %32
canonical: %32
form
:: %13
#
define: %32
min
(
a
,: %32
b
): %32
(
(
a
): %32
<: %32
(
b
): %32
?: %32
(
a
): %32
:: %32
(
b
)
): %13
#
define: %32
max
(
a
,: %32
b
): %32
(
(
a
): %32
>: %32
(
b
): %32
?: %32
(
a
): %32
:: %32
(
b
)
): %13
/
*: %32
canonrect
:: %32
canonicalize: %32
coordinates: %32
of: %32
rectangle: %32
*
/: %13
struct: %32
rect: %32
canonrect
(
struct: %32
rect: %32
r
): %13
{: %13
struct: %32
rect: %32
temp
;: %13
temp
.
pt
1
.
x: %32
=: %13
temp
.
pt
1
.
y: %32
=: %13
temp
.
pt
2
.
x: %32
=: %13
temp
.
pt
2
.
y: %32
=: %13
return: %32
temp
;: %13
min
(
r
.
pt
1
.
x
,: %13
min
(
r
.
pt
1
.
y
,: %13
max
(
r
.
pt
1
.
x
,: %13
max
(
r
.
pt
1
.
y
,: %13
r
.
pt
2
.
x
)
;: %13
r
.
pt
2
.
y
)
;: %13
r
.
pt
2
.
x
)
;: %13
r
.
pt
2
.
y
)
;: %13
}: %13
If: %32
a: %32
large: %32
structure: %32
is: %32
to: %32
be: %32
passed: %32
to: %32
a: %32
function
,: %32
it: %32
is: %32
generally: %32
more: %32
efficient: %32
to: %32
pass: %32
a: %32
pointer: %32
than: %32
to: %13
copy: %32
the: %32
whole: %32
structure
.: %32
Structure: %32
pointers: %32
are: %32
just: %32
like: %32
pointers: %32
to: %32
ordinary: %32
variables
.: %32
The: %32
declaration: %13
struct: %32
point: %32
*
pp
;: %13
says: %32
that: %32
pp: %32
is: %32
a: %32
pointer: %32
to: %32
a: %32
structure: %32
of: %32
type: %32
struct: %32
point
.: %32
If: %32
pp: %32
points: %32
to: %32
a: %32
point: %32
structure
,: %32
*
pp: %13
is: %32
the: %32
structure
,: %32
and: %32
(
*
pp
)
.
x: %32
and: %32
(
*
pp
)
.
y: %32
are: %32
the: %32
members
.: %32
To: %32
use: %32
pp
,: %32
we: %32
might: %32
write
,: %32
for: %32
example
,: %13
struct: %32
point: %32
origin
,: %32
*
pp
;: %13
pp: %32
=: %32
&
origin
;: %13
printf
(
"
origin: %32
is: %32
(
%:
d
,
%:
d
)
\
n
"
,: %32
(
*
pp
)
.
x
,: %32
(
*
pp
)
.
y
)
;: %13
The: %32
parentheses: %32
are: %32
necessary: %32
in: %32
(
*
pp
)
.
x: %32
because: %32
the: %32
precedence: %32
of: %32
the: %32
structure: %32
member: %32
operator: %32
.: %13
is: %32
higher: %32
then: %32
*
.: %32
The: %32
expression: %32
*
pp
.
x: %32
means: %32
*
(
pp
.
x
)
,: %32
which: %32
is: %32
illegal: %32
here: %32
because: %32
x: %32
is: %32
not: %32
a: %13
pointer
.: %13
Pointers: %32
to: %32
structures: %32
are: %32
so: %32
frequently: %32
used: %32
that: %32
an: %32
alternative: %32
notation: %32
is: %32
provided: %32
as: %32
a: %32
shorthand
.: %32
If: %32
p: %32
is: %13
a: %32
pointer: %32
to: %32
a: %32
structure
,: %32
then: %13
Chapter: %32
6: %32
-: %32
Structures: %13
p
-
>
member
-
of
-
structure: %13
refers: %32
to: %32
the: %32
particular: %32
member
.: %32
So: %32
we: %32
could: %32
write: %32
instead: %13
printf
(
"
origin: %32
is: %32
(
%:
d
,
%:
d
)
\
n
"
,: %32
pp
-
>
x
,: %32
pp
-
>
y
)
;: %13
Both: %32
.: %32
and: %32
-
>: %32
associate: %32
from: %32
left: %32
to: %32
right
,: %32
so: %32
if: %32
we: %32
have: %13
struct: %32
rect: %32
r
,: %32
*
rp: %32
=: %32
&
r
;: %13
then: %32
these: %32
four: %32
expressions: %32
are: %32
equivalent
:: %13
r
.
pt
1
.
x: %13
rp
-
>
pt
1
.
x: %13
(
r
.
pt
1
)
.
x: %13
(
rp
-
>
pt
1
)
.
x: %13
The: %32
structure: %32
operators: %32
.: %32
and: %32
-
>
,: %32
together: %32
with: %32
(
): %32
for: %32
function: %32
calls: %32
and: %32
[
]: %32
for: %32
subscripts
,: %32
are: %32
at: %32
the: %32
top: %13
of: %32
the: %32
precedence: %32
hierarchy: %32
and: %32
thus: %32
bind: %32
very: %32
tightly
.: %32
For: %32
example
,: %32
given: %32
the: %32
declaration: %13
struct: %32
{: %13
int: %32
len
;: %13
char: %32
*
str
;: %13
}: %32
*
p
;: %13
then: %13
+
+
p
-
>
len: %13
increments: %32
len
,: %32
not: %32
p
,: %32
because: %32
the: %32
implied: %32
parenthesization: %32
is: %32
+
+
(
p
-
>
len
)
.: %32
Parentheses: %32
can: %32
be: %32
used: %13
to: %32
alter: %32
binding
:: %32
(
+
+
p
)
-
>
len: %32
increments: %32
p: %32
before: %32
accessing: %32
len
,: %32
and: %32
(
p
+
+
)
-
>
len: %32
increments: %32
p: %13
afterward
.: %32
(
This: %32
last: %32
set: %32
of: %32
parentheses: %32
is: %32
unnecessary
.
): %13
In: %32
the: %32
same: %32
way
,: %32
*
p
-
>
str: %32
fetches: %32
whatever: %32
str: %32
points: %32
to
;: %32
*
p
-
>
str
+
+: %32
increments: %32
str: %32
after: %13
accessing: %32
whatever: %32
it: %32
points: %32
to: %32
(
just: %32
like: %32
*
s
+
+
)
;: %32
(
*
p
-
>
str
)
+
+: %32
increments: %32
whatever: %32
str: %32
points: %32
to
;: %13
and: %32
*
p
+
+
-
>
str: %32
increments: %32
p: %32
after: %32
accessing: %32
whatever: %32
str: %32
points: %32
to
.: %13
6
.
3: %32
Arrays: %32
of: %32
Structures: %13
Chapter: %32
6: %32
-: %32
Structures: %13
Consider: %32
writing: %32
a: %32
program: %32
to: %32
count: %32
the: %32
occurrences: %32
of: %32
each: %32
C: %32
keyword
.: %32
We: %32
need: %32
an: %32
array: %32
of: %32
character: %13
strings: %32
to: %32
hold: %32
the: %32
names
,: %32
and: %32
an: %32
array: %32
of: %32
integers: %32
for: %32
the: %32
counts
.: %32
One: %32
possibility: %32
is: %32
to: %32
use: %32
two: %32
parallel: %13
arrays
,: %32
keyword: %32
and: %32
keycount
,: %32
as: %32
in: %13
char: %32
*
keyword
[
NKEYS
]
;: %13
int: %32
keycount
[
NKEYS
]
;: %13
But: %32
the: %32
very: %32
fact: %32
that: %32
the: %32
arrays: %32
are: %32
parallel: %32
suggests: %32
a: %32
different: %32
organization
,: %32
an: %32
array: %32
of: %32
structures
.: %32
Each: %13
keyword: %32
is: %32
a: %32
pair
:: %13
char: %32
*
word
;: %13
int: %32
cout
;: %13
and: %32
there: %32
is: %32
an: %32
array: %32
of: %32
pairs
.: %32
The: %32
structure: %32
declaration: %13
struct: %32
key: %32
{: %13
char: %32
*
word
;: %13
int: %32
count
;: %13
}: %32
keytab
[
NKEYS
]
;: %13
declares: %32
a: %32
structure: %32
type: %32
key
,: %32
defines: %32
an: %32
array: %32
keytab: %32
of: %32
structures: %32
of: %32
this: %32
type
,: %32
and: %32
sets: %32
aside: %32
storage: %13
for: %32
them
.: %32
Each: %32
element: %32
of: %32
the: %32
array: %32
is: %32
a: %32
structure
.: %32
This: %32
could: %32
also: %32
be: %32
written: %13
struct: %32
key: %32
{: %13
char: %32
*
word
;: %13
int: %32
count
;: %13
}
;: %13
struct: %32
key: %32
keytab
[
NKEYS
]
;: %13
Since: %32
the: %32
structure: %32
keytab: %32
contains: %32
a: %32
constant: %32
set: %32
of: %32
names
,: %32
it: %32
is: %32
easiest: %32
to: %32
make: %32
it: %32
an: %32
external: %32
variable: %13
and: %32
initialize: %32
it: %32
once: %32
and: %32
for: %32
all: %32
when: %32
it: %32
is: %32
defined
.: %32
The: %32
structure: %32
initialization: %32
is: %32
analogous: %32
to: %32
earlier: %32
ones: %13
-: %32
the: %32
definition: %32
is: %32
followed: %32
by: %32
a: %32
list: %32
of: %32
initializers: %32
enclosed: %32
in: %32
braces
:: %13
struct: %32
key: %32
{: %13
char: %32
*
word
;: %13
int: %32
count
;: %13
}: %32
keytab
[
]: %32
=: %32
{: %13
"
auto
"
,: %32
0
,: %13
"
break
"
,: %32
0
,: %13
"
case
"
,: %32
0
,: %13
"
char
"
,: %32
0
,: %13
Chapter: %32
6: %32
-: %32
Structures: %13
"
const
"
,: %32
0
,: %13
"
continue
"
,: %32
0
,: %13
"
default
"
,: %32
0
,: %13
/
*: %32
.
.
.: %32
*
/: %13
"
unsigned
"
,: %32
0
,: %13
"
void
"
,: %32
0
,: %13
"
volatile
"
,: %32
0
,: %13
"
while
"
,: %32
0: %13
}
;: %13
The: %32
initializers: %32
are: %32
listed: %32
in: %32
pairs: %32
corresponding: %32
to: %32
the: %32
structure: %32
members
.: %32
It: %32
would: %32
be: %32
more: %32
precise: %32
to: %13
enclose: %32
the: %32
initializers: %32
for: %32
each: %32
"
row
": %32
or: %32
structure: %32
in: %32
braces
,: %32
as: %32
in: %13
{: %32
"
auto
"
,: %32
0: %32
}
,: %13
{: %32
"
break
"
,: %32
0: %32
}
,: %13
{: %32
"
case
"
,: %32
0: %32
}
,: %13
.
.
.: %13
but: %32
inner: %32
braces: %32
are: %32
not: %32
necessary: %32
when: %32
the: %32
initializers: %32
are: %32
simple: %32
variables: %32
or: %32
character: %32
strings
,: %32
and: %13
when: %32
all: %32
are: %32
present
.: %32
As: %32
usual
,: %32
the: %32
number: %32
of: %32
entries: %32
in: %32
the: %32
array: %32
keytab: %32
will: %32
be: %32
computed: %32
if: %32
the: %13
initializers: %32
are: %32
present: %32
and: %32
the: %32
[
]: %32
is: %32
left: %32
empty
.: %13
The: %32
keyword: %32
counting: %32
program: %32
begins: %32
with: %32
the: %32
definition: %32
of: %32
keytab
.: %32
The: %32
main: %32
routine: %32
reads: %32
the: %32
input: %13
by: %32
repeatedly: %32
calling: %32
a: %32
function: %32
getword: %32
that: %32
fetches: %32
one: %32
word: %32
at: %32
a: %32
time
.: %32
Each: %32
word: %32
is: %32
looked: %32
up: %32
in: %13
keytab: %32
with: %32
a: %32
version: %32
of: %32
the: %32
binary: %32
search: %32
function: %32
that: %32
we: %32
wrote: %32
in: %32
Chapter: %32
3
.: %32
The: %32
list: %32
of: %32
keywords: %13
must: %32
be: %32
sorted: %32
in: %32
increasing: %32
order: %32
in: %32
the: %32
table
.: %13
#
include: %32
<
stdio
.
h
>: %13
#
include: %32
<
ctype
.
h
>: %13
#
include: %32
<
string
.
h
>: %13
#
define: %32
MAXWORD: %32
1
0
0: %13
int: %32
getword
(
char: %32
*
,: %32
int
)
;: %13
int: %32
binsearch
(
char: %32
*
,: %32
struct: %32
key: %32
*
,: %32
int
)
;: %13
/
*: %32
count: %32
C: %32
keywords: %32
*
/: %13
main
(
): %13
{: %13
int: %32
n
;: %13
char: %32
word
[
MAXWORD
]
;: %13
while: %32
(
getword
(
word
,: %32
MAXWORD
): %32
!
=: %32
EOF
): %13
Chapter: %32
6: %32
-: %32
Structures: %13
if: %32
(
isalpha
(
word
[
0
]
)
): %13
if: %32
(
(
n: %32
=: %32
binsearch
(
word
,: %32
keytab
,: %32
NKEYS
)
): %32
>
=: %32
0
): %13
keytab
[
n
]
.
count
+
+
;: %13
for: %32
(
n: %32
=: %32
0
;: %32
n: %32
<: %32
NKEYS
;: %32
n
+
+
): %13
if: %32
(
keytab
[
n
]
.
count: %32
>: %32
0
): %13
printf
(
"
%:
4
d: %32
%:
s
\
n
"
,: %13
keytab
[
n
]
.
count
,: %32
keytab
[
n
]
.
word
)
;: %13
return: %32
0
;: %13
}: %13
/
*: %32
binsearch
:: %32
find: %32
word: %32
in: %32
tab
[
0
]
.
.
.
tab
[
n
-
1
]: %32
*
/: %13
int: %32
binsearch
(
char: %32
*
word
,: %32
struct: %32
key: %32
tab
[
]
,: %32
int: %32
n
): %13
{: %13
int: %32
cond
;: %13
int: %32
low
,: %32
high
,: %32
mid
;: %13
low: %32
=: %32
0
;: %13
high: %32
=: %32
n: %32
-: %32
1
;: %13
while: %32
(
low: %32
<
=: %32
high
): %32
{: %13
mid: %32
=: %32
(
low
+
high
): %32
/: %32
2
;: %13
if: %32
(
(
cond: %32
=: %32
strcmp
(
word
,: %32
tab
[
mid
]
.
word
)
): %32
<: %32
0
): %13
high: %32
=: %32
mid: %32
-: %32
1
;: %13
else: %32
if: %32
(
cond: %32
>: %32
0
): %13
low: %32
=: %32
mid: %32
+: %32
1
;: %13
else: %13
return: %32
mid
;: %13
}: %13
return: %32
-
1
;: %13
}: %13
We: %32
will: %32
show: %32
the: %32
function: %32
getword: %32
in: %32
a: %32
moment
;: %32
for: %32
now: %32
it: %32
suffices: %32
to: %32
say: %32
that: %32
each: %32
call: %32
to: %32
getword: %13
finds: %32
a: %32
word
,: %32
which: %32
is: %32
copied: %32
into: %32
the: %32
array: %32
named: %32
as: %32
its: %32
first: %32
argument
.: %13
The: %32
quantity: %32
NKEYS: %32
is: %32
the: %32
number: %32
of: %32
keywords: %32
in: %32
keytab
.: %32
Although: %32
we: %32
could: %32
count: %32
this: %32
by: %32
hand
,: %32
it
'
s: %32
a: %13
lot: %32
easier: %32
and: %32
safer: %32
to: %32
do: %32
it: %32
by: %32
machine
,: %32
especially: %32
if: %32
the: %32
list: %32
is: %32
subject: %32
to: %32
change
.: %32
One: %32
possibility: %32
would: %13
be: %32
to: %32
terminate: %32
the: %32
list: %32
of: %32
initializers: %32
with: %32
a: %32
null: %32
pointer
,: %32
then: %32
loop: %32
along: %32
keytab: %32
until: %32
the: %32
end: %32
is: %32
found
.: %13
But: %32
this: %32
is: %32
more: %32
than: %32
is: %32
needed
,: %32
since: %32
the: %32
size: %32
of: %32
the: %32
array: %32
is: %32
completely: %32
determined: %32
at: %32
compile: %32
time
.: %32
The: %13
size: %32
of: %32
the: %32
array: %32
is: %32
the: %32
size: %32
of: %32
one: %32
entry: %32
times: %32
the: %32
number: %32
of: %32
entries
,: %32
so: %32
the: %32
number: %32
of: %32
entries: %32
is: %32
just: %13
size: %32
of: %32
keytab: %32
/: %32
size: %32
of: %32
struct: %32
key: %13
C: %32
provides: %32
a: %32
compile
-
time: %32
unary: %32
operator: %32
called: %32
sizeof: %32
that: %32
can: %32
be: %32
used: %32
to: %32
compute: %32
the: %32
size: %32
of: %32
any: %13
Chapter: %32
6: %32
-: %32
Structures: %13
object
.: %32
The: %32
expressions: %13
sizeof: %32
object: %13
and: %13
sizeof: %32
(
type: %32
name
): %13
yield: %32
an: %32
integer: %32
equal: %32
to: %32
the: %32
size: %32
of: %32
the: %32
specified: %32
object: %32
or: %32
type: %32
in: %32
bytes
.: %32
(
Strictly
,: %32
sizeof: %32
produces: %32
an: %13
unsigned: %32
integer: %32
value: %32
whose: %32
type
,: %32
size
_
t
,: %32
is: %32
defined: %32
in: %32
the: %32
header: %32
<
stddef
.
h
>
.
): %32
An: %32
object: %32
can: %32
be: %13
a: %32
variable: %32
or: %32
array: %32
or: %32
structure
.: %32
A: %32
type: %32
name: %32
can: %32
be: %32
the: %32
name: %32
of: %32
a: %32
basic: %32
type: %32
like: %32
int: %32
or: %32
double
,: %32
or: %32
a: %13
derived: %32
type: %32
like: %32
a: %32
structure: %32
or: %32
a: %32
pointer
.: %13
In: %32
our: %32
case
,: %32
the: %32
number: %32
of: %32
keywords: %32
is: %32
the: %32
size: %32
of: %32
the: %32
array: %32
divided: %32
by: %32
the: %32
size: %32
of: %32
one: %32
element
.: %32
This: %13
computation: %32
is: %32
used: %32
in: %32
a: %32
#
define: %32
statement: %32
to: %32
set: %32
the: %32
value: %32
of: %32
NKEYS
:: %13
#
define: %32
NKEYS: %32
(
sizeof: %32
keytab: %32
/: %32
sizeof
(
struct: %32
key
)
): %13
Another: %32
way: %32
to: %32
write: %32
this: %32
is: %32
to: %32
divide: %32
the: %32
array: %32
size: %32
by: %32
the: %32
size: %32
of: %32
a: %32
specific: %32
element
:: %13
#
define: %32
NKEYS: %32
(
sizeof: %32
keytab: %32
/: %32
sizeof
(
keytab
[
0
]
)
): %13
This: %32
has: %32
the: %32
advantage: %32
that: %32
it: %32
does: %32
not: %32
need: %32
to: %32
be: %32
changed: %32
if: %32
the: %32
type: %32
changes
.: %13
A: %32
sizeof: %32
can: %32
not: %32
be: %32
used: %32
in: %32
a: %32
#
if: %32
line
,: %32
because: %32
the: %32
preprocessor: %32
does: %32
not: %32
parse: %32
type: %32
names
.: %32
But: %32
the: %13
expression: %32
in: %32
the: %32
#
define: %32
is: %32
not: %32
evaluated: %32
by: %32
the: %32
preprocessor
,: %32
so: %32
the: %32
code: %32
here: %32
is: %32
legal
.: %13
Now: %32
for: %32
the: %32
function: %32
getword
.: %32
We: %32
have: %32
written: %32
a: %32
more: %32
general: %32
getword: %32
than: %32
is: %32
necessary: %32
for: %32
this: %13
program
,: %32
but: %32
it: %32
is: %32
not: %32
complicated
.: %32
getword: %32
fetches: %32
the: %32
next: %32
`
`
word
'
': %32
from: %32
the: %32
input
,: %32
where: %32
a: %32
word: %32
is: %13
either: %32
a: %32
string: %32
of: %32
letters: %32
and: %32
digits: %32
beginning: %32
with: %32
a: %32
letter
,: %32
or: %32
a: %32
single: %32
non
-
white: %32
space: %32
character
.: %32
The: %13
function: %32
value: %32
is: %32
the: %32
first: %32
character: %32
of: %32
the: %32
word
,: %32
or: %32
EOF: %32
for: %32
end: %32
of: %32
file
,: %32
or: %32
the: %32
character: %32
itself: %32
if: %32
it: %32
is: %32
not: %13
alphabetic
.: %13
/
*: %32
getword
:: %32
get: %32
next: %32
word: %32
or: %32
character: %32
from: %32
input: %32
*
/: %13
int: %32
getword
(
char: %32
*
word
,: %32
int: %32
lim
): %13
{: %13
int: %32
c
,: %32
getch
(
void
)
;: %13
void: %32
ungetch
(
int
)
;: %13
char: %32
*
w: %32
=: %32
word
;: %13
while: %32
(
isspace
(
c: %32
=: %32
getch
(
)
)
): %13
;: %13
Chapter: %32
6: %32
-: %32
Structures: %13
if: %32
(
c: %32
!
=: %32
EOF
): %13
*
w
+
+: %32
=: %32
c
;: %13
if: %32
(
!
isalpha
(
c
)
): %32
{: %13
*
w: %32
=: %32
'
\
0
'
;: %13
return: %32
c
;: %13
}: %13
for: %32
(: %32
;: %32
-
-
lim: %32
>: %32
0
;: %32
w
+
+
): %13
if: %32
(
!
isalnum
(
*
w: %32
=: %32
getch
(
)
)
): %32
{: %13
ungetch
(
*
w
)
;: %13
break
;: %13
}: %13
*
w: %32
=: %32
'
\
0
'
;: %13
return: %32
word
[
0
]
;: %13
}: %13
getword: %32
uses: %32
the: %32
getch: %32
and: %32
ungetch: %32
that: %32
we: %32
wrote: %32
in: %32
Chapter: %32
4
.: %32
When: %32
the: %32
collection: %32
of: %32
an: %13
alphanumeric: %32
token: %32
stops
,: %32
getword: %32
has: %32
gone: %32
one: %32
character: %32
too: %32
far
.: %32
The: %32
call: %32
to: %32
ungetch: %32
pushes: %32
that: %13
character: %32
back: %32
on: %32
the: %32
input: %32
for: %32
the: %32
next: %32
call
.: %32
getword: %32
also: %32
uses: %32
isspace: %32
to: %32
skip: %32
whitespace
,: %13
isalpha: %32
to: %32
identify: %32
letters
,: %32
and: %32
isalnum: %32
to: %32
identify: %32
letters: %32
and: %32
digits
;: %32
all: %32
are: %32
from: %32
the: %32
standard: %32
header: %13
<
ctype
.
h
>
.: %13
Exercise: %32
6
-
1
.: %32
Our: %32
version: %32
of: %32
getword: %32
does: %32
not: %32
properly: %32
handle: %32
underscores
,: %32
string: %32
constants
,: %13
comments
,: %32
or: %32
preprocessor: %32
control: %32
lines
.: %32
Write: %32
a: %32
better: %32
version
.: %13
6
.
4: %32
Pointers: %32
to: %32
Structures: %13
To: %32
illustrate: %32
some: %32
of: %32
the: %32
considerations: %32
involved: %32
with: %32
pointers: %32
to: %32
and: %32
arrays: %32
of: %32
structures
,: %32
let: %32
us: %32
write: %32
the: %13
keyword
-
counting: %32
program: %32
again
,: %32
this: %32
time: %32
using: %32
pointers: %32
instead: %32
of: %32
array: %32
indices
.: %13
The: %32
external: %32
declaration: %32
of: %32
keytab: %32
need: %32
not: %32
change
,: %32
but: %32
main: %32
and: %32
binsearch: %32
do: %32
need: %32
modification
.: %13
#
include: %32
<
stdio
.
h
>: %13
#
include: %32
<
ctype
.
h
>: %13
#
include: %32
<
string
.
h
>: %13
#
define: %32
MAXWORD: %32
1
0
0: %13
int: %32
getword
(
char: %32
*
,: %32
int
)
;: %13
struct: %32
key: %32
*
binsearch
(
char: %32
*
,: %32
struct: %32
key: %32
*
,: %32
int
)
;: %13
/
*: %32
count: %32
C: %32
keywords
;: %32
pointer: %32
version: %32
*
/: %13
main
(
): %13
{: %13
Chapter: %32
6: %32
-: %32
Structures: %13
char: %32
word
[
MAXWORD
]
;: %13
struct: %32
key: %32
*
p
;: %13
while: %32
(
getword
(
word
,: %32
MAXWORD
): %32
!
=: %32
EOF
): %13
if: %32
(
isalpha
(
word
[
0
]
)
): %13
if: %32
(
(
p
=
binsearch
(
word
,: %32
keytab
,: %32
NKEYS
)
): %32
!
=: %32
NULL
): %13
p
-
>
count
+
+
;: %13
for: %32
(
p: %32
=: %32
keytab
;: %32
p: %32
<: %32
keytab: %32
+: %32
NKEYS
;: %32
p
+
+
): %13
if: %32
(
p
-
>
count: %32
>: %32
0
): %13
printf
(
"
%:
4
d: %32
%:
s
\
n
"
,: %32
p
-
>
count
,: %32
p
-
>
word
)
;: %13
return: %32
0
;: %13
}: %13
/
*: %32
binsearch
:: %32
find: %32
word: %32
in: %32
tab
[
0
]
.
.
.
tab
[
n
-
1
]: %32
*
/: %13
struct: %32
key: %32
*
binsearch
(
char: %32
*
word
,: %32
struck: %32
key: %32
*
tab
,: %32
int: %32
n
): %13
{: %13
int: %32
cond
;: %13
struct: %32
key: %32
*
low: %32
=: %32
&
tab
[
0
]
;: %13
struct: %32
key: %32
*
high: %32
=: %32
&
tab
[
n
]
;: %13
struct: %32
key: %32
*
mid
;: %13
while: %32
(
low: %32
<: %32
high
): %32
{: %13
mid: %32
=: %32
low: %32
+: %32
(
high
-
low
): %32
/: %32
2
;: %13
if: %32
(
(
cond: %32
=: %32
strcmp
(
word
,: %32
mid
-
>
word
)
): %32
<: %32
0
): %13
high: %32
=: %32
mid
;: %13
else: %32
if: %32
(
cond: %32
>: %32
0
): %13
low: %32
=: %32
mid: %32
+: %32
1
;: %13
else: %13
return: %32
mid
;: %13
}: %13
return: %32
NULL
;: %13
}: %13
There: %32
are: %32
several: %32
things: %32
worthy: %32
of: %32
note: %32
here
.: %32
First
,: %32
the: %32
declaration: %32
of: %32
binsearch: %32
must: %32
indicate: %32
that: %32
it: %13
returns: %32
a: %32
pointer: %32
to: %32
struct: %32
key: %32
instead: %32
of: %32
an: %32
integer
;: %32
this: %32
is: %32
declared: %32
both: %32
in: %32
the: %32
function: %32
prototype: %13
and: %32
in: %32
binsearch
.: %32
If: %32
binsearch: %32
finds: %32
the: %32
word
,: %32
it: %32
returns: %32
a: %32
pointer: %32
to: %32
it
;: %32
if: %32
it: %32
fails
,: %32
it: %32
returns: %32
NULL
.: %13
Second
,: %32
the: %32
elements: %32
of: %32
keytab: %32
are: %32
now: %32
accessed: %32
by: %32
pointers
.: %32
This: %32
requires: %32
significant: %32
changes: %32
in: %13
binsearch
.: %13
The: %32
initializers: %32
for: %32
low: %32
and: %32
high: %32
are: %32
now: %32
pointers: %32
to: %32
the: %32
beginning: %32
and: %32
just: %32
past: %32
the: %32
end: %32
of: %32
the: %32
table
.: %13
The: %32
computation: %32
of: %32
the: %32
middle: %32
element: %32
can: %32
no: %32
longer: %32
be: %32
simply: %13
Chapter: %32
6: %32
-: %32
Structures: %13
mid: %32
=: %32
(
low
+
high
): %32
/: %32
2: %13
/
*: %32
WRONG: %32
*
/: %13
because: %32
the: %32
addition: %32
of: %32
pointers: %32
is: %32
illegal
.: %32
Subtraction: %32
is: %32
legal
,: %32
however
,: %32
so: %32
high
-
low: %32
is: %32
the: %32
number: %32
of: %13
elements
,: %32
and: %32
thus: %13
mid: %32
=: %32
low: %32
+: %32
(
high
-
low
): %32
/: %32
2: %13
sets: %32
mid: %32
to: %32
the: %32
element: %32
halfway: %32
between: %32
low: %32
and: %32
high
.: %13
The: %32
most: %32
important: %32
change: %32
is: %32
to: %32
adjust: %32
the: %32
algorithm: %32
to: %32
make: %32
sure: %32
that: %32
it: %32
does: %32
not: %32
generate: %32
an: %32
illegal: %13
pointer: %32
or: %32
attempt: %32
to: %32
access: %32
an: %32
element: %32
outside: %32
the: %32
array
.: %32
The: %32
problem: %32
is: %32
that: %32
&
tab
[
-
1
]: %32
and: %32
&
tab
[
n
]: %13
are: %32
both: %32
outside: %32
the: %32
limits: %32
of: %32
the: %32
array: %32
tab
.: %32
The: %32
former: %32
is: %32
strictly: %32
illegal
,: %32
and: %32
it: %32
is: %32
illegal: %32
to: %32
dereference: %13
the: %32
latter
.: %32
The: %32
language: %32
definition: %32
does: %32
guarantee
,: %32
however
,: %32
that: %32
pointer: %32
arithmetic: %32
that: %32
involves: %32
the: %32
first: %13
element: %32
beyond: %32
the: %32
end: %32
of: %32
an: %32
array: %32
(
that: %32
is
,: %32
&
tab
[
n
]
): %32
will: %32
work: %32
correctly
.: %13
In: %32
main: %32
we: %32
wrote: %13
for: %32
(
p: %32
=: %32
keytab
;: %32
p: %32
<: %32
keytab: %32
+: %32
NKEYS
;: %32
p
+
+
): %13
If: %32
p: %32
is: %32
a: %32
pointer: %32
to: %32
a: %32
structure
,: %32
arithmetic: %32
on: %32
p: %32
takes: %32
into: %32
account: %32
the: %32
size: %32
of: %32
the: %32
structure
,: %32
so: %32
p
+
+: %13
increments: %32
p: %32
by: %32
the: %32
correct: %32
amount: %32
to: %32
get: %32
the: %32
next: %32
element: %32
of: %32
the: %32
array: %32
of: %32
structures
,: %32
and: %32
the: %32
test: %32
stops: %13
the: %32
loop: %32
at: %32
the: %32
right: %32
time
.: %13
Don
'
t: %32
assume
,: %32
however
,: %32
that: %32
the: %32
size: %32
of: %32
a: %32
structure: %32
is: %32
the: %32
sum: %32
of: %32
the: %32
sizes: %32
of: %32
its: %32
members
.: %32
Because: %32
of: %13
alignment: %32
requirements: %32
for: %32
different: %32
objects
,: %32
there: %32
may: %32
be: %32
unnamed: %32
`
`
holes
'
': %32
in: %32
a: %32
structure
.: %32
Thus
,: %32
for: %13
instance
,: %32
if: %32
a: %32
char: %32
is: %32
one: %32
byte: %32
and: %32
an: %32
int: %32
four: %32
bytes
,: %32
the: %32
structure: %13
struct: %32
{: %13
char: %32
c
;: %13
int: %32
i
;: %13
}
;: %13
might: %32
well: %32
require: %32
eight: %32
bytes
,: %32
not: %32
five
.: %32
The: %32
sizeof: %32
operator: %32
returns: %32
the: %32
proper: %32
value
.: %13
Finally
,: %32
an: %32
aside: %32
on: %32
program: %32
format
:: %32
when: %32
a: %32
function: %32
returns: %32
a: %32
complicated: %32
type: %32
like: %32
a: %32
structure: %32
pointer
,: %13
as: %32
in: %13
struct: %32
key: %32
*
binsearch
(
char: %32
*
word
,: %32
struct: %32
key: %32
*
tab
,: %32
int: %32
n
): %13
the: %32
function: %32
name: %32
can: %32
be: %32
hard: %32
to: %32
see
,: %32
and: %32
to: %32
find: %32
with: %32
a: %32
text: %32
editor
.: %32
Accordingly: %32
an: %32
alternate: %32
style: %32
is: %13
sometimes: %32
used
:: %13
Chapter: %32
6: %32
-: %32
Structures: %13
struct: %32
key: %32
*: %13
binsearch
(
char: %32
*
word
,: %32
struct: %32
key: %32
*
tab
,: %32
int: %32
n
): %13
This: %32
is: %32
a: %32
matter: %32
of: %32
personal: %32
taste
;: %32
pick: %32
the: %32
form: %32
you: %32
like: %32
and: %32
hold: %32
to: %32
it
.: %13
6
.
5: %32
Self
-
referential: %32
Structures: %13
Suppose: %32
we: %32
want: %32
to: %32
handle: %32
the: %32
more: %32
general: %32
problem: %32
of: %32
counting: %32
the: %32
occurrences: %32
of: %32
all: %32
the: %32
words: %32
in: %13
some: %32
input
.: %32
Since: %32
the: %32
list: %32
of: %32
words: %32
isn
'
t: %32
known: %32
in: %32
advance
,: %32
we: %32
can
'
t: %32
conveniently: %32
sort: %32
it: %32
and: %32
use: %32
a: %32
binary: %13
search
.: %32
Yet: %32
we: %32
can
'
t: %32
do: %32
a: %32
linear: %32
search: %32
for: %32
each: %32
word: %32
as: %32
it: %32
arrives
,: %32
to: %32
see: %32
if: %32
it
'
s: %32
already: %32
been: %32
seen
;: %32
the: %13
program: %32
would: %32
take: %32
too: %32
long
.: %32
(
More: %32
precisely
,: %32
its: %32
running: %32
time: %32
is: %32
likely: %32
to: %32
grow: %32
quadratically: %32
with: %32
the: %13
number: %32
of: %32
input: %32
words
.
): %32
How: %32
can: %32
we: %32
organize: %32
the: %32
data: %32
to: %32
copy: %32
efficiently: %32
with: %32
a: %32
list: %32
or: %32
arbitrary: %32
words
?: %13
One: %32
solution: %32
is: %32
to: %32
keep: %32
the: %32
set: %32
of: %32
words: %32
seen: %32
so: %32
far: %32
sorted: %32
at: %32
all: %32
times
,: %32
by: %32
placing: %32
each: %32
word: %32
into: %32
its: %13
proper: %32
position: %32
in: %32
the: %32
order: %32
as: %32
it: %32
arrives
.: %32
This: %32
shouldn
'
t: %32
be: %32
done: %32
by: %32
shifting: %32
words: %32
in: %32
a: %32
linear: %32
array
,: %13
though: %32
-: %32
that: %32
also: %32
takes: %32
too: %32
long
.: %32
Instead: %32
we: %32
will: %32
use: %32
a: %32
data: %32
structure: %32
called: %32
a: %32
binary: %32
tree
.: %13
The: %32
tree: %32
contains: %32
one: %32
`
`
node
'
': %32
per: %32
distinct: %32
word
;: %32
each: %32
node: %32
contains: %13
q: %13
q: %13
q: %13
q: %13
A: %32
pointer: %32
to: %32
the: %32
text: %32
of: %32
the: %32
word
,: %13
A: %32
count: %32
of: %32
the: %32
number: %32
of: %32
occurrences
,: %13
A: %32
pointer: %32
to: %32
the: %32
left: %32
child: %32
node
,: %13
A: %32
pointer: %32
to: %32
the: %32
right: %32
child: %32
node
.: %13
No: %32
node: %32
may: %32
have: %32
more: %32
than: %32
two: %32
children
;: %32
it: %32
might: %32
have: %32
only: %32
zero: %32
or: %32
one
.: %13
The: %32
nodes: %32
are: %32
maintained: %32
so: %32
that: %32
at: %32
any: %32
node: %32
the: %32
left: %32
subtree: %32
contains: %32
only: %32
words: %32
that: %32
are: %13
lexicographically: %32
less: %32
than: %32
the: %32
word: %32
at: %32
the: %32
node
,: %32
and: %32
the: %32
right: %32
subtree: %32
contains: %32
only: %32
words: %32
that: %32
are: %13
greater
.: %32
This: %32
is: %32
the: %32
tree: %32
for: %32
the: %32
sentence: %32
`
`
now: %32
is: %32
the: %32
time: %32
for: %32
all: %32
good: %32
men: %32
to: %32
come: %32
to: %32
the: %32
aid: %32
of: %32
their: %13
party
'
'
,: %32
as: %32
built: %32
by: %32
inserting: %32
each: %32
word: %32
as: %32
it: %32
is: %32
encountered
:: %13
Chapter: %32
6: %32
-: %32
Structures: %13
To: %32
find: %32
out: %32
whether: %32
a: %32
new: %32
word: %32
is: %32
already: %32
in: %32
the: %32
tree
,: %32
start: %32
at: %32
the: %32
root: %32
and: %32
compare: %32
the: %32
new: %32
word: %32
to: %32
the: %13
word: %32
stored: %32
at: %32
that: %32
node
.: %32
If: %32
they: %32
match
,: %32
the: %32
question: %32
is: %32
answered: %32
affirmatively
.: %32
If: %32
the: %32
new: %32
record: %32
is: %32
less: %13
than: %32
the: %32
tree: %32
word
,: %32
continue: %32
searching: %32
at: %32
the: %32
left: %32
child
,: %32
otherwise: %32
at: %32
the: %32
right: %32
child
.: %32
If: %32
there: %32
is: %32
no: %32
child: %32
in: %13
the: %32
required: %32
direction
,: %32
the: %32
new: %32
word: %32
is: %32
not: %32
in: %32
the: %32
tree
,: %32
and: %32
in: %32
fact: %32
the: %32
empty: %32
slot: %32
is: %32
the: %32
proper: %32
place: %32
to: %32
add: %13
the: %32
new: %32
word
.: %32
This: %32
process: %32
is: %32
recursive
,: %32
since: %32
the: %32
search: %32
from: %32
any: %32
node: %32
uses: %32
a: %32
search: %32
from: %32
one: %32
of: %32
its: %13
children
.: %32
Accordingly
,: %32
recursive: %32
routines: %32
for: %32
insertion: %32
and: %32
printing: %32
will: %32
be: %32
most: %32
natural
.: %13
Going: %32
back: %32
to: %32
the: %32
description: %32
of: %32
a: %32
node
,: %32
it: %32
is: %32
most: %32
conveniently: %32
represented: %32
as: %32
a: %32
structure: %32
with: %32
four: %13
components
:: %13
struct: %32
tnode: %32
{: %13
/
*: %32
the: %13
char: %32
*
word
;: %13
int: %32
count
;: %13
struct: %32
tnode: %32
*
left
;: %13
struct: %32
tnode: %32
*
right
;: %13
}
;: %13
tree: %32
node
:: %32
*
/: %13
/
*: %32
points: %32
to: %32
the: %32
text: %32
*
/: %13
/
*: %32
number: %32
of: %32
occurrences: %32
*
/: %13
/
*: %32
left: %32
child: %32
*
/: %13
/
*: %32
right: %32
child: %32
*
/: %13
This: %32
recursive: %32
declaration: %32
of: %32
a: %32
node: %32
might: %32
look: %32
chancy
,: %32
but: %32
it
'
s: %32
correct
.: %32
It: %32
is: %32
illegal: %32
for: %32
a: %32
structure: %32
to: %13
contain: %32
an: %32
instance: %32
of: %32
itself
,: %32
but: %13
struct: %32
tnode: %32
*
left
;: %13
declares: %32
left: %32
to: %32
be: %32
a: %32
pointer: %32
to: %32
a: %32
tnode
,: %32
not: %32
a: %32
tnode: %32
itself
.: %13
Occasionally
,: %32
one: %32
needs: %32
a: %32
variation: %32
of: %32
self
-
referential: %32
structures
:: %32
two: %32
structures: %32
that: %32
refer: %32
to: %32
each: %32
other
.: %13
The: %32
way: %32
to: %32
handle: %32
this: %32
is
:: %13
Chapter: %32
6: %32
-: %32
Structures: %13
struct: %32
t: %32
{: %13
.
.
.: %13
struct: %32
s: %32
*
p
;: %13
}
;: %13
struct: %32
s: %32
{: %13
.
.
.: %13
struct: %32
t: %32
*
q
;: %13
}
;: %13
/
*: %32
p: %32
points: %32
to: %32
an: %32
s: %32
*
/: %13
/
*: %32
q: %32
points: %32
to: %32
a: %32
t: %32
*
/: %13
The: %32
code: %32
for: %32
the: %32
whole: %32
program: %32
is: %32
surprisingly: %32
small
,: %32
given: %32
a: %32
handful: %32
of: %32
supporting: %32
routines: %32
like: %13
getword: %32
that: %32
we: %32
have: %32
already: %32
written
.: %32
The: %32
main: %32
routine: %32
reads: %32
words: %32
with: %32
getword: %32
and: %32
installs: %32
them: %13
in: %32
the: %32
tree: %32
with: %32
addtree
.: %13
#
include: %32
<
stdio
.
h
>: %13
#
include: %32
<
ctype
.
h
>: %13
#
include: %32
<
string
.
h
>: %13
#
define: %32
MAXWORD: %32
1
0
0: %13
struct: %32
tnode: %32
*
addtree
(
struct: %32
tnode: %32
*
,: %32
char: %32
*
)
;: %13
void: %32
treeprint
(
struct: %32
tnode: %32
*
)
;: %13
int: %32
getword
(
char: %32
*
,: %32
int
)
;: %13
/
*: %32
word: %32
frequency: %32
count: %32
*
/: %13
main
(
): %13
{: %13
struct: %32
tnode: %32
*
root
;: %13
char: %32
word
[
MAXWORD
]
;: %13
root: %32
=: %32
NULL
;: %13
while: %32
(
getword
(
word
,: %32
MAXWORD
): %32
!
=: %32
EOF
): %13
if: %32
(
isalpha
(
word
[
0
]
)
): %13
root: %32
=: %32
addtree
(
root
,: %32
word
)
;: %13
treeprint
(
root
)
;: %13
return: %32
0
;: %13
}: %13
The: %32
function: %32
addtree: %32
is: %32
recursive
.: %32
A: %32
word: %32
is: %32
presented: %32
by: %32
main: %32
to: %32
the: %32
top: %32
level: %32
(
the: %32
root
): %32
of: %32
the: %32
tree
.: %13
At: %32
each: %32
stage
,: %32
that: %32
word: %32
is: %32
compared: %32
to: %32
the: %32
word: %32
already: %32
stored: %32
at: %32
the: %32
node
,: %32
and: %32
is: %32
percolated: %32
down: %32
to: %13
either: %32
the: %32
left: %32
or: %32
right: %32
subtree: %32
by: %32
a: %32
recursive: %32
call: %32
to: %32
adtree
.: %32
Eventually
,: %32
the: %32
word: %32
either: %32
matches: %13
something: %32
already: %32
in: %32
the: %32
tree: %32
(
in: %32
which: %32
case: %32
the: %32
count: %32
is: %32
incremented
)
,: %32
or: %32
a: %32
null: %32
pointer: %32
is: %32
encountered
,: %13
indicating: %32
that: %32
a: %32
node: %32
must: %32
be: %32
created: %32
and: %32
added: %32
to: %32
the: %32
tree
.: %32
If: %32
a: %32
new: %32
node: %32
is: %32
created
,: %32
addtree: %32
returns: %32
a: %13
pointer: %32
to: %32
it
,: %32
which: %32
is: %32
installed: %32
in: %32
the: %32
parent: %32
node
.: %13
Chapter: %32
6: %32
-: %32
Structures: %13
struct: %32
tnode: %32
*
talloc
(
void
)
;: %13
char: %32
*
strdup
(
char: %32
*
)
;: %13
/
*: %32
addtree
:: %32
add: %32
a: %32
node: %32
with: %32
w
,: %32
at: %32
or: %32
below: %32
p: %32
*
/: %13
struct: %32
treenode: %32
*
addtree
(
struct: %32
tnode: %32
*
p
,: %32
char: %32
*
w
): %13
{: %13
int: %32
cond
;: %13
if: %32
(
p: %32
=
=: %32
NULL
): %32
{: %13
/
*: %32
a: %32
new: %32
word: %32
has: %32
arrived: %32
*
/: %13
p: %32
=: %32
talloc
(
)
;: %13
/
*: %32
make: %32
a: %32
new: %32
node: %32
*
/: %13
p
-
>
word: %32
=: %32
strdup
(
w
)
;: %13
p
-
>
count: %32
=: %32
1
;: %13
p
-
>
left: %32
=: %32
p
-
>
right: %32
=: %32
NULL
;: %13
}: %32
else: %32
if: %32
(
(
cond: %32
=: %32
strcmp
(
w
,: %32
p
-
>
word
)
): %32
=
=: %32
0
): %13
p
-
>
count
+
+
;: %13
/
*: %32
repeated: %32
word: %32
*
/: %13
else: %32
if: %32
(
cond: %32
<: %32
0
): %13
/
*: %32
less: %32
than: %32
into: %32
left: %32
subtree: %32
*
/: %13
p
-
>
left: %32
=: %32
addtree
(
p
-
>
left
,: %32
w
)
;: %13
else: %13
/
*: %32
greater: %32
than: %32
into: %32
right: %32
subtree: %32
*
/: %13
p
-
>
right: %32
=: %32
addtree
(
p
-
>
right
,: %32
w
)
;: %13
return: %32
p
;: %13
}: %13
Storage: %32
for: %32
the: %32
new: %32
node: %32
is: %32
fetched: %32
by: %32
a: %32
routine: %32
talloc
,: %32
which: %32
returns: %32
a: %32
pointer: %32
to: %32
a: %32
free: %32
space: %32
suitable: %13
for: %32
holding: %32
a: %32
tree: %32
node
,: %32
and: %32
the: %32
new: %32
word: %32
is: %32
copied: %32
into: %32
a: %32
hidden: %32
space: %32
by: %32
strdup
.: %32
(
We: %32
will: %32
discuss: %13
these: %32
routines: %32
in: %32
a: %32
moment
.
): %32
The: %32
count: %32
is: %32
initialized
,: %32
and: %32
the: %32
two: %32
children: %32
are: %32
made: %32
null
.: %32
This: %32
part: %32
of: %32
the: %13
code: %32
is: %32
executed: %32
only: %32
at: %32
the: %32
leaves: %32
of: %32
the: %32
tree
,: %32
when: %32
a: %32
new: %32
node: %32
is: %32
being: %32
added
.: %32
We: %32
have: %32
(
unwisely
): %13
omitted: %32
error: %32
checking: %32
on: %32
the: %32
values: %32
returned: %32
by: %32
strdup: %32
and: %32
talloc
.: %13
treeprint: %32
prints: %32
the: %32
tree: %32
in: %32
sorted: %32
order
;: %32
at: %32
each: %32
node
,: %32
it: %32
prints: %32
the: %32
left: %32
subtree: %32
(
all: %32
the: %32
words: %32
less: %32
than: %13
this: %32
word
)
,: %32
then: %32
the: %32
word: %32
itself
,: %32
then: %32
the: %32
right: %32
subtree: %32
(
all: %32
the: %32
words: %32
greater
)
.: %32
If: %32
you: %32
feel: %32
shaky: %32
about: %32
how: %13
recursion: %32
works
,: %32
simulate: %32
treeprint: %32
as: %32
it: %32
operates: %32
on: %32
the: %32
tree: %32
shown: %32
above
.: %13
/
*: %32
treeprint
:: %32
in
-
order: %32
print: %32
of: %32
tree: %32
p: %32
*
/: %13
void: %32
treeprint
(
struct: %32
tnode: %32
*
p
): %13
{: %13
if: %32
(
p: %32
!
=: %32
NULL
): %32
{: %13
treeprint
(
p
-
>
left
)
;: %13
printf
(
"
%:
4
d: %32
%:
s
\
n
"
,: %32
p
-
>
count
,: %32
p
-
>
word
)
;: %13
treeprint
(
p
-
>
right
)
;: %13
}: %13
}: %13
A: %32
practical: %32
note
:: %32
if: %32
the: %32
tree: %32
becomes: %32
`
`
unbalanced
'
': %32
because: %32
the: %32
words: %32
don
'
t: %32
arrive: %32
in: %32
random: %32
order
,: %32
the: %13
Chapter: %32
6: %32
-: %32
Structures: %13
running: %32
time: %32
of: %32
the: %32
program: %32
can: %32
grow: %32
too: %32
much
.: %32
As: %32
a: %32
worst: %32
case
,: %32
if: %32
the: %32
words: %32
are: %32
already: %32
in: %32
order
,: %32
this: %13
program: %32
does: %32
an: %32
expensive: %32
simulation: %32
of: %32
linear: %32
search
.: %32
There: %32
are: %32
generalizations: %32
of: %32
the: %32
binary: %32
tree: %32
that: %13
do: %32
not: %32
suffer: %32
from: %32
this: %32
worst
-
case: %32
behavior
,: %32
but: %32
we: %32
will: %32
not: %32
describe: %32
them: %32
here
.: %13
Before: %32
leaving: %32
this: %32
example
,: %32
it: %32
is: %32
also: %32
worth: %32
a: %32
brief: %32
digression: %32
on: %32
a: %32
problem: %32
related: %32
to: %32
storage: %32
allocators
.: %13
Clearly: %32
it
'
s: %32
desirable: %32
that: %32
there: %32
be: %32
only: %32
one: %32
storage: %32
allocator: %32
in: %32
a: %32
program
,: %32
even: %32
though: %32
it: %32
allocates: %13
different: %32
kinds: %32
of: %32
objects
.: %32
But: %32
if: %32
one: %32
allocator: %32
is: %32
to: %32
process: %32
requests: %32
for
,: %32
say
,: %32
pointers: %32
to: %32
chars: %32
and: %13
pointers: %32
to: %32
struct: %32
tnodes
,: %32
two: %32
questions: %32
arise
.: %32
First
,: %32
how: %32
does: %32
it: %32
meet: %32
the: %32
requirement: %32
of: %32
most: %32
real: %13
machines: %32
that: %32
objects: %32
of: %32
certain: %32
types: %32
must: %32
satisfy: %32
alignment: %32
restrictions: %32
(
for: %32
example
,: %32
integers: %32
often: %13
must: %32
be: %32
located: %32
at: %32
even: %32
addresses
)
?: %32
Second
,: %32
what: %32
declarations: %32
can: %32
cope: %32
with: %32
the: %32
fact: %32
that: %32
an: %32
allocator: %13
must: %32
necessarily: %32
return: %32
different: %32
kinds: %32
of: %32
pointers
?: %13
Alignment: %32
requirements: %32
can: %32
generally: %32
be: %32
satisfied: %32
easily
,: %32
at: %32
the: %32
cost: %32
of: %32
some: %32
wasted: %32
space
,: %32
by: %32
ensuring: %13
that: %32
the: %32
allocator: %32
always: %32
returns: %32
a: %32
pointer: %32
that: %32
meets: %32
all: %32
alignment: %32
restrictions
.: %32
The: %32
alloc: %32
of: %32
Chapter: %32
5: %13
does: %32
not: %32
guarantee: %32
any: %32
particular: %32
alignment
,: %32
so: %32
we: %32
will: %32
use: %32
the: %32
standard: %32
library: %32
function: %32
malloc
,: %32
which: %13
does
.: %32
In: %32
Chapter: %32
8: %32
we: %32
will: %32
show: %32
one: %32
way: %32
to: %32
implement: %32
malloc
.: %13
The: %32
question: %32
of: %32
the: %32
type: %32
declaration: %32
for: %32
a: %32
function: %32
like: %32
malloc: %32
is: %32
a: %32
vexing: %32
one: %32
for: %32
any: %32
language: %32
that: %13
takes: %32
its: %32
type
-
checking: %32
seriously
.: %32
In: %32
C
,: %32
the: %32
proper: %32
method: %32
is: %32
to: %32
declare: %32
that: %32
malloc: %32
returns: %32
a: %32
pointer: %32
to: %13
void
,: %32
then: %32
explicitly: %32
coerce: %32
the: %32
pointer: %32
into: %32
the: %32
desired: %32
type: %32
with: %32
a: %32
cast
.: %32
malloc: %32
and: %32
related: %32
routines: %13
are: %32
declared: %32
in: %32
the: %32
standard: %32
header: %32
<
stdlib
.
h
>
.: %32
Thus: %32
talloc: %32
can: %32
be: %32
written: %32
as: %13
#
include: %32
<
stdlib
.
h
>: %13
/
*: %32
talloc
:: %32
make: %32
a: %32
tnode: %32
*
/: %13
struct: %32
tnode: %32
*
talloc
(
void
): %13
{: %13
return: %32
(
struct: %32
tnode: %32
*
): %32
malloc
(
sizeof
(
struct: %32
tnode
)
)
;: %13
}: %13
strdup: %32
merely: %32
copies: %32
the: %32
string: %32
given: %32
by: %32
its: %32
argument: %32
into: %32
a: %32
safe: %32
place
,: %32
obtained: %32
by: %32
a: %32
call: %32
on: %32
malloc
:: %13
char: %32
*
strdup
(
char: %32
*
s
): %13
{: %13
char: %32
*
p
;: %13
/
*: %32
make: %32
a: %32
duplicate: %32
of: %32
s: %32
*
/: %13
p: %32
=: %32
(
char: %32
*
): %32
malloc
(
strlen
(
s
)
+
1
)
;: %32
/
*: %32
+
1: %32
for: %32
'
\
0
': %32
*
/: %13
if: %32
(
p: %32
!
=: %32
NULL
): %13
strcpy
(
p
,: %32
s
)
;: %13
return: %32
p
;: %13
}: %13
Chapter: %32
6: %32
-: %32
Structures: %13
malloc: %32
returns: %32
NULL: %32
if: %32
no: %32
space: %32
is: %32
available
;: %32
strdup: %32
passes: %32
that: %32
value: %32
on
,: %32
leaving: %32
error
-
handling: %32
to: %13
its: %32
caller
.: %13
Storage: %32
obtained: %32
by: %32
calling: %32
malloc: %32
may: %32
be: %32
freed: %32
for: %32
re
-
use: %32
by: %32
calling: %32
free
;: %32
see: %32
Chapters: %32
8: %32
and: %32
7
.: %13
Exercise: %32
6
-
2
.: %32
Write: %32
a: %32
program: %32
that: %32
reads: %32
a: %32
C: %32
program: %32
and: %32
prints: %32
in: %32
alphabetical: %32
order: %32
each: %32
group: %32
of: %13
variable: %32
names: %32
that: %32
are: %32
identical: %32
in: %32
the: %32
first: %32
6: %32
characters
,: %32
but: %32
different: %32
somewhere: %32
thereafter
.: %32
Don
'
t: %32
count: %13
words: %32
within: %32
strings: %32
and: %32
comments
.: %32
Make: %32
6: %32
a: %32
parameter: %32
that: %32
can: %32
be: %32
set: %32
from: %32
the: %32
command: %32
line
.: %13
Exercise: %32
6
-
3
.: %32
Write: %32
a: %32
cross
-
referencer: %32
that: %32
prints: %32
a: %32
list: %32
of: %32
all: %32
words: %32
in: %32
a: %32
document
,: %32
and: %32
for: %32
each: %32
word
,: %32
a: %13
list: %32
of: %32
the: %32
line: %32
numbers: %32
on: %32
which: %32
it: %32
occurs
.: %32
Remove: %32
noise: %32
words: %32
like: %32
`
`
the
,
'
': %32
`
`
and
,
'
': %32
and: %32
so: %32
on
.: %13
Exercise: %32
6
-
4
.: %32
Write: %32
a: %32
program: %32
that: %32
prints: %32
the: %32
distinct: %32
words: %32
in: %32
its: %32
input: %32
sorted: %32
into: %32
decreasing: %32
order: %32
of: %13
frequency: %32
of: %32
occurrence
.: %32
Precede: %32
each: %32
word: %32
by: %32
its: %32
count
.: %13
6
.
6: %32
Table: %32
Lookup: %13
In: %32
this: %32
section: %32
we: %32
will: %32
write: %32
the: %32
innards: %32
of: %32
a: %32
table
-
lookup: %32
package
,: %32
to: %32
illustrate: %32
more: %32
aspects: %32
of: %13
structures
.: %32
This: %32
code: %32
is: %32
typical: %32
of: %32
what: %32
might: %32
be: %32
found: %32
in: %32
the: %32
symbol: %32
table: %32
management: %32
routines: %32
of: %32
a: %13
macro: %32
processor: %32
or: %32
a: %32
compiler
.: %32
For: %32
example
,: %32
consider: %32
the: %32
#
define: %32
statement
.: %32
When: %32
a: %32
line: %32
like: %13
#
define: %13
IN: %13
1: %13
is: %32
encountered
,: %32
the: %32
name: %32
IN: %32
and: %32
the: %32
replacement: %32
text: %32
1: %32
are: %32
stored: %32
in: %32
a: %32
table
.: %32
Later
,: %32
when: %32
the: %32
name: %32
IN: %13
appears: %32
in: %32
a: %32
statement: %32
like: %13
state: %32
=: %32
IN
;: %13
it: %32
must: %32
be: %32
replaced: %32
by: %32
1
.: %13
There: %32
are: %32
two: %32
routines: %32
that: %32
manipulate: %32
the: %32
names: %32
and: %32
replacement: %32
texts
.: %32
install
(
s
,
t
): %32
records: %32
the: %13
name: %32
s: %32
and: %32
the: %32
replacement: %32
text: %32
t: %32
in: %32
a: %32
table
;: %32
s: %32
and: %32
t: %32
are: %32
just: %32
character: %32
strings
.: %32
lookup
(
s
): %32
searches: %13
for: %32
s: %32
in: %32
the: %32
table
,: %32
and: %32
returns: %32
a: %32
pointer: %32
to: %32
the: %32
place: %32
where: %32
it: %32
was: %32
found
,: %32
or: %32
NULL: %32
if: %32
it: %32
wasn
'
t: %32
there
.: %13
The: %32
algorithm: %32
is: %32
a: %32
hash
-
search: %32
-: %32
the: %32
incoming: %32
name: %32
is: %32
converted: %32
into: %32
a: %32
small: %32
non
-
negative: %32
integer
,: %32
which: %13
is: %32
then: %32
used: %32
to: %32
index: %32
into: %32
an: %32
array: %32
of: %32
pointers
.: %32
An: %32
array: %32
element: %32
points: %32
to: %32
the: %32
beginning: %32
of: %32
a: %32
linked: %32
list: %32
of: %13
blocks: %32
describing: %32
names: %32
that: %32
have: %32
that: %32
hash: %32
value
.: %32
It: %32
is: %32
NULL: %32
if: %32
no: %32
names: %32
have: %32
hashed: %32
to: %32
that: %32
value
.: %13
Chapter: %32
6: %32
-: %32
Structures: %13
A: %32
block: %32
in: %32
the: %32
list: %32
is: %32
a: %32
structure: %32
containing: %32
pointers: %32
to: %32
the: %32
name
,: %32
the: %32
replacement: %32
text
,: %32
and: %32
the: %32
next: %32
block: %13
in: %32
the: %32
list
.: %32
A: %32
null: %32
next
-
pointer: %32
marks: %32
the: %32
end: %32
of: %32
the: %32
list
.: %13
struct: %32
nlist: %32
{: %13
/
*: %32
table: %32
entry
:: %32
*
/: %13
struct: %32
nlist: %32
*
next
;: %13
/
*: %32
next: %32
entry: %32
in: %32
chain: %32
*
/: %13
char: %32
*
name
;: %13
/
*: %32
defined: %32
name: %32
*
/: %13
char: %32
*
defn
;: %13
/
*: %32
replacement: %32
text: %32
*
/: %13
}
;: %13
The: %32
pointer: %32
array: %32
is: %32
just: %13
#
define: %32
HASHSIZE: %32
1
0
1: %13
static: %32
struct: %32
nlist: %32
*
hashtab
[
HASHSIZE
]
;: %13
/
*: %32
pointer: %32
table: %32
*
/: %13
The: %32
hashing: %32
function
,: %32
which: %32
is: %32
used: %32
by: %32
both: %32
lookup: %32
and: %32
install
,: %32
adds: %32
each: %32
character: %32
value: %32
in: %32
the: %13
string: %32
to: %32
a: %32
scrambled: %32
combination: %32
of: %32
the: %32
previous: %32
ones: %32
and: %32
returns: %32
the: %32
remainder: %32
modulo: %32
the: %32
array: %32
size
.: %13
This: %32
is: %32
not: %32
the: %32
best: %32
possible: %32
hash: %32
function
,: %32
but: %32
it: %32
is: %32
short: %32
and: %32
effective
.: %13
/
*: %32
hash
:: %32
form: %32
hash: %32
value: %32
for: %32
string: %32
s: %32
*
/: %13
unsigned: %32
hash
(
char: %32
*
s
): %13
{: %13
unsigned: %32
hashval
;: %13
for: %32
(
hashval: %32
=: %32
0
;: %32
*
s: %32
!
=: %32
'
\
0
'
;: %32
s
+
+
): %13
hashval: %32
=: %32
*
s: %32
+: %32
3
1: %32
*: %32
hashval
;: %13
return: %32
hashval: %32
%: %32
HASHSIZE
;: %13
}: %13
Unsigned: %32
arithmetic: %32
ensures: %32
that: %32
the: %32
hash: %32
value: %32
is: %32
non
-
negative
.: %13
Chapter: %32
6: %32
-: %32
Structures: %13
The: %32
hashing: %32
process: %32
produces: %32
a: %32
starting: %32
index: %32
in: %32
the: %32
array: %32
hashtab
;: %32
if: %32
the: %32
string: %32
is: %32
to: %32
be: %32
found: %13
anywhere
,: %32
it: %32
will: %32
be: %32
in: %32
the: %32
list: %32
of: %32
blocks: %32
beginning: %32
there
.: %32
The: %32
search: %32
is: %32
performed: %32
by: %32
lookup
.: %32
If: %13
lookup: %32
finds: %32
the: %32
entry: %32
already: %32
present
,: %32
it: %32
returns: %32
a: %32
pointer: %32
to: %32
it
;: %32
if: %32
not
,: %32
it: %32
returns: %32
NULL
.: %13
/
*: %32
lookup
:: %32
look: %32
for: %32
s: %32
in: %32
hashtab: %32
*
/: %13
struct: %32
nlist: %32
*
lookup
(
char: %32
*
s
): %13
{: %13
struct: %32
nlist: %32
*
np
;: %13
for: %32
(
np: %32
=: %32
hashtab
[
hash
(
s
)
]
;: %32
np: %32
!
=: %32
NULL
;: %32
np: %32
=: %32
np
-
>
next
): %13
if: %32
(
strcmp
(
s
,: %32
np
-
>
name
): %32
=
=: %32
0
): %13
return: %32
np
;: %13
/
*: %32
found: %32
*
/: %13
return: %32
NULL
;: %13
/
*: %32
not: %32
found: %32
*
/: %13
}: %13
The: %32
for: %32
loop: %32
in: %32
lookup: %32
is: %32
the: %32
standard: %32
idiom: %32
for: %32
walking: %32
along: %32
a: %32
linked: %32
list
:: %13
for: %32
(
ptr: %32
=: %32
head
;: %32
ptr: %32
!
=: %32
NULL
;: %32
ptr: %32
=: %32
ptr
-
>
next
): %13
.
.
.: %13
install: %32
uses: %32
lookup: %32
to: %32
determine: %32
whether: %32
the: %32
name: %32
being: %32
installed: %32
is: %32
already: %32
present
;: %32
if: %32
so
,: %32
the: %32
new: %13
definition: %32
will: %32
supersede: %32
the: %32
old: %32
one
.: %32
Otherwise
,: %32
a: %32
new: %32
entry: %32
is: %32
created
.: %32
install: %32
returns: %32
NULL: %32
if: %32
for: %13
any: %32
reason: %32
there: %32
is: %32
no: %32
room: %32
for: %32
a: %32
new: %32
entry
.: %13
struct: %32
nlist: %32
*
lookup
(
char: %32
*
)
;: %13
char: %32
*
strdup
(
char: %32
*
)
;: %13
/
*: %32
install
:: %32
put: %32
(
name
,: %32
defn
): %32
in: %32
hashtab: %32
*
/: %13
struct: %32
nlist: %32
*
install
(
char: %32
*
name
,: %32
char: %32
*
defn
): %13
{: %13
struct: %32
nlist: %32
*
np
;: %13
unsigned: %32
hashval
;: %13
if: %32
(
(
np: %32
=: %32
lookup
(
name
)
): %32
=
=: %32
NULL
): %32
{: %32
/
*: %32
not: %32
found: %32
*
/: %13
np: %32
=: %32
(
struct: %32
nlist: %32
*
): %32
malloc
(
sizeof
(
*
np
)
)
;: %13
if: %32
(
np: %32
=
=: %32
NULL: %32
|
|: %32
(
np
-
>
name: %32
=: %32
strdup
(
name
)
): %32
=
=: %32
NULL
): %13
return: %32
NULL
;: %13
hashval: %32
=: %32
hash
(
name
)
;: %13
np
-
>
next: %32
=: %32
hashtab
[
hashval
]
;: %13
hashtab
[
hashval
]: %32
=: %32
np
;: %13
}: %32
else: %13
/
*: %32
already: %32
there: %32
*
/: %13
free
(
(
void: %32
*
): %32
np
-
>
defn
)
;: %13
/
*
free: %32
previous: %32
defn: %32
*
/: %13
Chapter: %32
6: %32
-: %32
Structures: %13
if: %32
(
(
np
-
>
defn: %32
=: %32
strdup
(
defn
)
): %32
=
=: %32
NULL
): %13
return: %32
NULL
;: %13
return: %32
np
;: %13
}: %13
Exercise: %32
6
-
5
.: %32
Write: %32
a: %32
function: %32
undef: %32
that: %32
will: %32
remove: %32
a: %32
name: %32
and: %32
definition: %32
from: %32
the: %32
table: %32
maintained: %13
by: %32
lookup: %32
and: %32
install
.: %13
Exercise: %32
6
-
6
.: %32
Implement: %32
a: %32
simple: %32
version: %32
of: %32
the: %32
#
define: %32
processor: %32
(
i
.
e
.
,: %32
no: %32
arguments
): %32
suitable: %32
for: %13
use: %32
with: %32
C: %32
programs
,: %32
based: %32
on: %32
the: %32
routines: %32
of: %32
this: %32
section
.: %32
You: %32
may: %32
also: %32
find: %32
getch: %32
and: %32
ungetch: %13
helpful
.: %13
6
.
7: %32
Typedef: %13
C: %32
provides: %32
a: %32
facility: %32
called: %32
typedef: %32
for: %32
creating: %32
new: %32
data: %32
type: %32
names
.: %32
For: %32
example
,: %32
the: %32
declaration: %13
typedef: %32
int: %32
Length
;: %13
makes: %32
the: %32
name: %32
Length: %32
a: %32
synonym: %32
for: %32
int
.: %32
The: %32
type: %32
Length: %32
can: %32
be: %32
used: %32
in: %32
declarations
,: %32
casts
,: %32
etc
.
,: %13
in: %32
exactly: %32
the: %32
same: %32
ways: %32
that: %32
the: %32
int: %32
type: %32
can: %32
be
:: %13
Length: %32
len
,: %32
maxlen
;: %13
Length: %32
*
lengths
[
]
;: %13
Similarly
,: %32
the: %32
declaration: %13
typedef: %32
char: %32
*
String
;: %13
makes: %32
String: %32
a: %32
synonym: %32
for: %32
char: %32
*: %32
or: %32
character: %32
pointer
,: %32
which: %32
may: %32
then: %32
be: %32
used: %32
in: %32
declarations: %13
and: %32
casts
:: %13
String: %32
p
,: %32
lineptr
[
MAXLINES
]
,: %32
alloc
(
int
)
;: %13
int: %32
strcmp
(
String
,: %32
String
)
;: %13
p: %32
=: %32
(
String
): %32
malloc
(
1
0
0
)
;: %13
Notice: %32
that: %32
the: %32
type: %32
being: %32
declared: %32
in: %32
a: %32
typedef: %32
appears: %32
in: %32
the: %32
position: %32
of: %32
a: %32
variable: %32
name
,: %32
not: %32
right: %13
after: %32
the: %32
word: %32
typedef
.: %32
Syntactically
,: %32
typedef: %32
is: %32
like: %32
the: %32
storage: %32
classes: %32
extern
,: %32
static
,: %32
etc
.: %13
We: %32
have: %32
used: %32
capitalized: %32
names: %32
for: %32
typedefs
,: %32
to: %32
make: %32
them: %32
stand: %32
out
.: %13
As: %32
a: %32
more: %32
complicated: %32
example
,: %32
we: %32
could: %32
make: %32
typedefs: %32
for: %32
the: %32
tree: %32
nodes: %32
shown: %32
earlier: %32
in: %32
this: %13
chapter
:: %13
Chapter: %32
6: %32
-: %32
Structures: %13
typedef: %32
struct: %32
tnode: %32
*
Treeptr
;: %13
typedef: %32
struct: %32
tnode: %32
{: %32
/
*: %13
char: %32
*
word
;: %13
int: %32
count
;: %13
struct: %32
tnode: %32
*
left
;: %13
struct: %32
tnode: %32
*
right
;: %13
}: %32
Treenode
;: %13
the: %32
tree: %32
node
:: %32
*
/: %13
/
*: %32
points: %32
to: %32
the: %32
text: %32
*
/: %13
/
*: %32
number: %32
of: %32
occurrences: %32
*
/: %13
/
*: %32
left: %32
child: %32
*
/: %13
/
*: %32
right: %32
child: %32
*
/: %13
This: %32
creates: %32
two: %32
new: %32
type: %32
keywords: %32
called: %32
Treenode: %32
(
a: %32
structure
): %32
and: %32
Treeptr: %32
(
a: %32
pointer: %32
to: %32
the: %13
structure
)
.: %32
Then: %32
the: %32
routine: %32
talloc: %32
could: %32
become: %13
Treeptr: %32
talloc
(
void
): %13
{: %13
return: %32
(
Treeptr
): %32
malloc
(
sizeof
(
Treenode
)
)
;: %13
}: %13
It: %32
must: %32
be: %32
emphasized: %32
that: %32
a: %32
typedef: %32
declaration: %32
does: %32
not: %32
create: %32
a: %32
new: %32
type: %32
in: %32
any: %32
sense
;: %32
it: %32
merely: %13
adds: %32
a: %32
new: %32
name: %32
for: %32
some: %32
existing: %32
type
.: %32
Nor: %32
are: %32
there: %32
any: %32
new: %32
semantics
:: %32
variables: %32
declared: %32
this: %32
way: %13
have: %32
exactly: %32
the: %32
same: %32
properties: %32
as: %32
variables: %32
whose: %32
declarations: %32
are: %32
spelled: %32
out: %32
explicitly
.: %32
In: %32
effect
,: %13
typedef: %32
is: %32
like: %32
#
define
,: %32
except: %32
that: %32
since: %32
it: %32
is: %32
interpreted: %32
by: %32
the: %32
compiler
,: %32
it: %32
can: %32
cope: %32
with: %32
textual: %13
substitutions: %32
that: %32
are: %32
beyond: %32
the: %32
capabilities: %32
of: %32
the: %32
preprocessor
.: %32
For: %32
example
,: %13
typedef: %32
int: %32
(
*
PFI
)
(
char: %32
*
,: %32
char: %32
*
)
;: %13
creates: %32
the: %32
type: %32
PFI
,: %32
for: %32
`
`
pointer: %32
to: %32
function: %32
(
of: %32
two: %32
char: %32
*: %32
arguments
): %32
returning: %32
int
,
'
': %32
which: %32
can: %32
be: %13
used: %32
in: %32
contexts: %32
like: %13
PFI: %32
strcmp
,: %32
numcmp
;: %13
in: %32
the: %32
sort: %32
program: %32
of: %32
Chapter: %32
5
.: %13
Besides: %32
purely: %32
aesthetic: %32
issues
,: %32
there: %32
are: %32
two: %32
main: %32
reasons: %32
for: %32
using: %32
typedefs
.: %32
The: %32
first: %32
is: %32
to: %13
parameterize: %32
a: %32
program: %32
against: %32
portability: %32
problems
.: %32
If: %32
typedefs: %32
are: %32
used: %32
for: %32
data: %32
types: %32
that: %32
may: %32
be: %13
machine
-
dependent
,: %32
only: %32
the: %32
typedefs: %32
need: %32
change: %32
when: %32
the: %32
program: %32
is: %32
moved
.: %32
One: %32
common: %13
situation: %32
is: %32
to: %32
use: %32
typedef: %32
names: %32
for: %32
various: %32
integer: %32
quantities
,: %32
then: %32
make: %32
an: %32
appropriate: %32
set: %32
of: %13
choices: %32
of: %32
short
,: %32
int
,: %32
and: %32
long: %32
for: %32
each: %32
host: %32
machine
.: %32
Types: %32
like: %32
size
_
t: %32
and: %32
ptrdiff
_
t: %32
from: %13
the: %32
standard: %32
library: %32
are: %32
examples
.: %13
The: %32
second: %32
purpose: %32
of: %32
typedefs: %32
is: %32
to: %32
provide: %32
better: %32
documentation: %32
for: %32
a: %32
program: %32
-: %32
a: %32
type: %32
called: %13
Treeptr: %32
may: %32
be: %32
easier: %32
to: %32
understand: %32
than: %32
one: %32
declared: %32
only: %32
as: %32
a: %32
pointer: %32
to: %32
a: %32
complicated: %32
structure
.: %13
Chapter: %32
6: %32
-: %32
Structures: %13
6
.
8: %32
Unions: %13
A: %32
union: %32
is: %32
a: %32
variable: %32
that: %32
may: %32
hold: %32
(
at: %32
different: %32
times
): %32
objects: %32
of: %32
different: %32
types: %32
and: %32
sizes
,: %32
with: %32
the: %13
compiler: %32
keeping: %32
track: %32
of: %32
size: %32
and: %32
alignment: %32
requirements
.: %32
Unions: %32
provide: %32
a: %32
way: %32
to: %32
manipulate: %32
different: %13
kinds: %32
of: %32
data: %32
in: %32
a: %32
single: %32
area: %32
of: %32
storage
,: %32
without: %32
embedding: %32
any: %32
machine
-
dependent: %32
information: %32
in: %32
the: %13
program
.: %32
They: %32
are: %32
analogous: %32
to: %32
variant: %32
records: %32
in: %32
pascal
.: %13
As: %32
an: %32
example: %32
such: %32
as: %32
might: %32
be: %32
found: %32
in: %32
a: %32
compiler: %32
symbol: %32
table: %32
manager
,: %32
suppose: %32
that: %32
a: %32
constant: %32
may: %13
be: %32
an: %32
int
,: %32
a: %32
float
,: %32
or: %32
a: %32
character: %32
pointer
.: %32
The: %32
value: %32
of: %32
a: %32
particular: %32
constant: %32
must: %32
be: %32
stored: %32
in: %32
a: %13
variable: %32
of: %32
the: %32
proper: %32
type
,: %32
yet: %32
it: %32
is: %32
most: %32
convenient: %32
for: %32
table: %32
management: %32
if: %32
the: %32
value: %32
occupies: %32
the: %32
same: %13
amount: %32
of: %32
storage: %32
and: %32
is: %32
stored: %32
in: %32
the: %32
same: %32
place: %32
regardless: %32
of: %32
its: %32
type
.: %32
This: %32
is: %32
the: %32
purpose: %32
of: %32
a: %32
union: %32
-: %32
a: %13
single: %32
variable: %32
that: %32
can: %32
legitimately: %32
hold: %32
any: %32
of: %32
one: %32
of: %32
several: %32
types
.: %32
The: %32
syntax: %32
is: %32
based: %32
on: %32
structures
:: %13
union: %32
u
_
tag: %32
{: %13
int: %32
ival
;: %13
float: %32
fval
;: %13
char: %32
*
sval
;: %13
}: %32
u
;: %13
The: %32
variable: %32
u: %32
will: %32
be: %32
large: %32
enough: %32
to: %32
hold: %32
the: %32
largest: %32
of: %32
the: %32
three: %32
types
;: %32
the: %32
specific: %32
size: %32
is: %13
implementation
-
dependent
.: %32
Any: %32
of: %32
these: %32
types: %32
may: %32
be: %32
assigned: %32
to: %32
u: %32
and: %32
then: %32
used: %32
in: %32
expressions
,: %32
so: %13
long: %32
as: %32
the: %32
usage: %32
is: %32
consistent
:: %32
the: %32
type: %32
retrieved: %32
must: %32
be: %32
the: %32
type: %32
most: %32
recently: %32
stored
.: %32
It: %32
is: %32
the: %13
programmer
'
s: %32
responsibility: %32
to: %32
keep: %32
track: %32
of: %32
which: %32
type: %32
is: %32
currently: %32
stored: %32
in: %32
a: %32
union
;: %32
the: %32
results: %32
are: %13
implementation
-
dependent: %32
if: %32
something: %32
is: %32
stored: %32
as: %32
one: %32
type: %32
and: %32
extracted: %32
as: %32
another
.: %13
Syntactically
,: %32
members: %32
of: %32
a: %32
union: %32
are: %32
accessed: %32
as: %13
union
-
name
.
member: %13
or: %13
union
-
pointer
-
>
member: %13
just: %32
as: %32
for: %32
structures
.: %32
If: %32
the: %32
variable: %32
utype: %32
is: %32
used: %32
to: %32
keep: %32
track: %32
of: %32
the: %32
current: %32
type: %32
stored: %32
in: %32
u
,: %32
then: %32
one: %13
might: %32
see: %32
code: %32
such: %32
as: %13
if: %32
(
utype: %32
=
=: %32
INT
): %13
printf
(
"
%:
d
\
n
"
,: %32
u
.
ival
)
;: %13
if: %32
(
utype: %32
=
=: %32
FLOAT
): %13
printf
(
"
%:
f
\
n
"
,: %32
u
.
fval
)
;: %13
Chapter: %32
6: %32
-: %32
Structures: %13
if: %32
(
utype: %32
=
=: %32
STRING
): %13
printf
(
"
%:
s
\
n
"
,: %32
u
.
sval
)
;: %13
else: %13
printf
(
"
bad: %32
type: %32
%:
d: %32
in: %32
utype
\
n
"
,: %32
utype
)
;: %13
Unions: %32
may: %32
occur: %32
within: %32
structures: %32
and: %32
arrays
,: %32
and: %32
vice: %32
versa
.: %32
The: %32
notation: %32
for: %32
accessing: %32
a: %32
member: %32
of: %32
a: %13
union: %32
in: %32
a: %32
structure: %32
(
or: %32
vice: %32
versa
): %32
is: %32
identical: %32
to: %32
that: %32
for: %32
nested: %32
structures
.: %32
For: %32
example
,: %32
in: %32
the: %32
structure: %13
array: %32
defined: %32
by: %13
struct: %32
{: %13
char: %32
*
name
;: %13
int: %32
flags
;: %13
int: %32
utype
;: %13
union: %32
{: %13
int: %32
ival
;: %13
float: %32
fval
;: %13
char: %32
*
sval
;: %13
}: %32
u
;: %13
}: %32
symtab
[
NSYM
]
;: %13
the: %32
member: %32
ival: %32
is: %32
referred: %32
to: %32
as: %13
symtab
[
i
]
.
u
.
ival: %13
and: %32
the: %32
first: %32
character: %32
of: %32
the: %32
string: %32
sval: %32
by: %32
either: %32
of: %13
*
symtab
[
i
]
.
u
.
sval: %13
symtab
[
i
]
.
u
.
sval
[
0
]: %13
In: %32
effect
,: %32
a: %32
union: %32
is: %32
a: %32
structure: %32
in: %32
which: %32
all: %32
members: %32
have: %32
offset: %32
zero: %32
from: %32
the: %32
base
,: %32
the: %32
structure: %32
is: %32
big: %13
enough: %32
to: %32
hold: %32
the: %32
`
`
widest
'
': %32
member
,: %32
and: %32
the: %32
alignment: %32
is: %32
appropriate: %32
for: %32
all: %32
of: %32
the: %32
types: %32
in: %32
the: %32
union
.: %13
The: %32
same: %32
operations: %32
are: %32
permitted: %32
on: %32
unions: %32
as: %32
on: %32
structures
:: %32
assignment: %32
to: %32
or: %32
copying: %32
as: %32
a: %32
unit
,: %32
taking: %13
the: %32
address
,: %32
and: %32
accessing: %32
a: %32
member
.: %13
A: %32
union: %32
may: %32
only: %32
be: %32
initialized: %32
with: %32
a: %32
value: %32
of: %32
the: %32
type: %32
of: %32
its: %32
first: %32
member
;: %32
thus: %32
union: %32
u: %32
described: %13
above: %32
can: %32
only: %32
be: %32
initialized: %32
with: %32
an: %32
integer: %32
value
.: %13
The: %32
storage: %32
allocator: %32
in: %32
Chapter: %32
8: %32
shows: %32
how: %32
a: %32
union: %32
can: %32
be: %32
used: %32
to: %32
force: %32
a: %32
variable: %32
to: %32
be: %32
aligned: %32
on: %32
a: %13
particular: %32
kind: %32
of: %32
storage: %32
boundary
.: %13
Chapter: %32
6: %32
-: %32
Structures: %13
6
.
9: %32
Bit
-
fields: %13
When: %32
storage: %32
space: %32
is: %32
at: %32
a: %32
premium
,: %32
it: %32
may: %32
be: %32
necessary: %32
to: %32
pack: %32
several: %32
objects: %32
into: %32
a: %32
single: %32
machine: %13
word
;: %32
one: %32
common: %32
use: %32
is: %32
a: %32
set: %32
of: %32
single
-
bit: %32
flags: %32
in: %32
applications: %32
like: %32
compiler: %32
symbol: %32
tables
.: %32
Externally
-: %13
imposed: %32
data: %32
formats
,: %32
such: %32
as: %32
interfaces: %32
to: %32
hardware: %32
devices
,: %32
also: %32
often: %32
require: %32
the: %32
ability: %32
to: %32
get: %32
at: %13
pieces: %32
of: %32
a: %32
word
.: %13
Imagine: %32
a: %32
fragment: %32
of: %32
a: %32
compiler: %32
that: %32
manipulates: %32
a: %32
symbol: %32
table
.: %32
Each: %32
identifier: %32
in: %32
a: %32
program: %32
has: %13
certain: %32
information: %32
associated: %32
with: %32
it
,: %32
for: %32
example
,: %32
whether: %32
or: %32
not: %32
it: %32
is: %32
a: %32
keyword
,: %32
whether: %32
or: %32
not: %32
it: %32
is: %13
external: %32
and
/
or: %32
static
,: %32
and: %32
so: %32
on
.: %32
The: %32
most: %32
compact: %32
way: %32
to: %32
encode: %32
such: %32
information: %32
is: %32
a: %32
set: %32
of: %32
one
-
bit: %13
flags: %32
in: %32
a: %32
single: %32
char: %32
or: %32
int
.: %13
The: %32
usual: %32
way: %32
this: %32
is: %32
done: %32
is: %32
to: %32
define: %32
a: %32
set: %32
of: %32
`
`
masks
'
': %32
corresponding: %32
to: %32
the: %32
relevant: %32
bit: %32
positions
,: %32
as: %32
in: %13
#
define: %32
KEYWORD: %32
0
1: %13
#
define: %32
EXTRENAL: %32
0
2: %13
#
define: %32
STATIC: %13
0
4: %13
or: %13
enum: %32
{: %32
KEYWORD: %32
=: %32
0
1
,: %32
EXTERNAL: %32
=: %32
0
2
,: %32
STATIC: %32
=: %32
0
4: %32
}
;: %13
The: %32
numbers: %32
must: %32
be: %32
powers: %32
of: %32
two
.: %32
Then: %32
accessing: %32
the: %32
bits: %32
becomes: %32
a: %32
matter: %32
of: %32
`
`
bit
-
fiddling
'
': %32
with: %32
the: %13
shifting
,: %32
masking
,: %32
and: %32
complementing: %32
operators: %32
that: %32
were: %32
described: %32
in: %32
Chapter: %32
2
.: %13
Certain: %32
idioms: %32
appear: %32
frequently
:: %13
flags: %32
|
=: %32
EXTERNAL: %32
|: %32
STATIC
;: %13
turns: %32
on: %32
the: %32
EXTERNAL: %32
and: %32
STATIC: %32
bits: %32
in: %32
flags
,: %32
while: %13
flags: %32
&
=: %32
~
(
EXTERNAL: %32
|: %32
STATIC
)
;: %13
turns: %32
them: %32
off
,: %32
and: %13
if: %32
(
(
flags: %32
&: %32
(
EXTERNAL: %32
|: %32
STATIC
)
): %32
=
=: %32
0
): %32
.
.
.: %13
is: %32
true: %32
if: %32
both: %32
bits: %32
are: %32
off
.: %13
Although: %32
these: %32
idioms: %32
are: %32
readily: %32
mastered
,: %32
as: %32
an: %32
alternative: %32
C: %32
offers: %32
the: %32
capability: %32
of: %32
defining: %32
and: %13
Chapter: %32
6: %32
-: %32
Structures: %13
accessing: %32
fields: %32
within: %32
a: %32
word: %32
directly: %32
rather: %32
than: %32
by: %32
bitwise: %32
logical: %32
operators
.: %32
A: %32
bit
-
field
,: %32
or: %32
field: %32
for: %13
short
,: %32
is: %32
a: %32
set: %32
of: %32
adjacent: %32
bits: %32
within: %32
a: %32
single: %32
implementation
-
defined: %32
storage: %32
unit: %32
that: %32
we: %32
will: %32
call: %32
a: %13
`
`
word
.
'
': %32
For: %32
example
,: %32
the: %32
symbol: %32
table: %32
#
defines: %32
above: %32
could: %32
be: %32
replaced: %32
by: %32
the: %32
definition: %32
of: %32
three: %13
fields
:: %13
struct: %32
{: %13
unsigned: %32
int: %32
is
_
keyword: %32
:: %32
1
;: %13
unsigned: %32
int: %32
is
_
extern: %32
:: %32
1
;: %13
unsigned: %32
int: %32
is
_
static: %32
:: %32
1
;: %13
}: %32
flags
;: %13
This: %32
defines: %32
a: %32
variable: %32
table: %32
called: %32
flags: %32
that: %32
contains: %32
three: %32
1
-
bit: %32
fields
.: %32
The: %32
number: %32
following: %32
the: %13
colon: %32
represents: %32
the: %32
field: %32
width: %32
in: %32
bits
.: %32
The: %32
fields: %32
are: %32
declared: %32
unsigned: %32
int: %32
to: %32
ensure: %32
that: %32
they: %32
are: %13
unsigned: %32
quantities
.: %13
Individual: %32
fields: %32
are: %32
referenced: %32
in: %32
the: %32
same: %32
way: %32
as: %32
other: %32
structure: %32
members
:: %32
flags
.
is
_
keyword
,: %13
flags
.
is
_
extern
,: %32
etc
.: %32
Fields: %32
behave: %32
like: %32
small: %32
integers
,: %32
and: %32
may: %32
participate: %32
in: %32
arithmetic: %13
expressions: %32
just: %32
like: %32
other: %32
integers
.: %32
Thus: %32
the: %32
previous: %32
examples: %32
may: %32
be: %32
written: %32
more: %32
naturally: %32
as: %13
flags
.
is
_
extern: %32
=: %32
flags
.
is
_
static: %32
=: %32
1
;: %13
to: %32
turn: %32
the: %32
bits: %32
on
;: %13
flags
.
is
_
extern: %32
=: %32
flags
.
is
_
static: %32
=: %32
0
;: %13
to: %32
turn: %32
them: %32
off
;: %32
and: %13
if: %32
(
flags
.
is
_
extern: %32
=
=: %32
0: %32
&
&: %32
flags
.
is
_
static: %32
=
=: %32
0
): %13
.
.
.: %13
to: %32
test: %32
them
.: %13
Almost: %32
everything: %32
about: %32
fields: %32
is: %32
implementation
-
dependent
.: %32
Whether: %32
a: %32
field: %32
may: %32
overlap: %32
a: %32
word: %13
boundary: %32
is: %32
implementation
-
defined
.: %32
Fields: %32
need: %32
not: %32
be: %32
names
;: %32
unnamed: %32
fields: %32
(
a: %32
colon: %32
and: %32
width: %32
only
): %13
are: %32
used: %32
for: %32
padding
.: %32
The: %32
special: %32
width: %32
0: %32
may: %32
be: %32
used: %32
to: %32
force: %32
alignment: %32
at: %32
the: %32
next: %32
word: %32
boundary
.: %13
Fields: %32
are: %32
assigned: %32
left: %32
to: %32
right: %32
on: %32
some: %32
machines: %32
and: %32
right: %32
to: %32
left: %32
on: %32
others
.: %32
This: %32
means: %32
that: %32
although: %13
fields: %32
are: %32
useful: %32
for: %32
maintaining: %32
internally
-
defined: %32
data: %32
structures
,: %32
the: %32
question: %32
of: %32
which: %32
end: %32
comes: %32
first: %13
has: %32
to: %32
be: %32
carefully: %32
considered: %32
when: %32
picking: %32
apart: %32
externally
-
defined: %32
data
;: %32
programs: %32
that: %32
depend: %32
on: %32
such: %13
things: %32
are: %32
not: %32
portable
.: %32
Fields: %32
may: %32
be: %32
declared: %32
only: %32
as: %32
ints
;: %32
for: %32
portability
,: %32
specify: %32
signed: %32
or: %13
unsigned: %32
explicitly
.: %32
They: %32
are: %32
not: %32
arrays: %32
and: %32
they: %32
do: %32
not: %32
have: %32
addresses
,: %32
so: %32
the: %32
&: %32
operator: %32
cannot: %32
be: %13
applied: %32
on: %32
them
.: %13
Chapter: %32
6: %32
-: %32
Structures: %13
Back: %32
to: %32
Chapter: %32
5: %32
-
-: %32
Index: %32
-
-: %32
Chapter: %32
7: %13
Chapter: %32
7: %32
-: %32
Input: %32
and: %32
Output: %13
Back: %32
to: %32
Chapter: %32
6: %32
-
-: %32
Index: %32
-
-: %32
Chapter: %32
8: %13
Chapter: %32
7: %32
-: %32
Input: %32
and: %32
Output: %13
Input: %32
and: %32
output: %32
are: %32
not: %32
part: %32
of: %32
the: %32
C: %32
language: %32
itself
,: %32
so: %32
we: %32
have: %32
not: %32
emphasized: %32
them: %32
in: %32
our: %13
presentation: %32
thus: %32
far
.: %32
Nonetheless
,: %32
programs: %32
interact: %32
with: %32
their: %32
environment: %32
in: %32
much: %32
more: %32
complicated: %13
ways: %32
than: %32
those: %32
we: %32
have: %32
shown: %32
before
.: %32
In: %32
this: %32
chapter: %32
we: %32
will: %32
describe: %32
the: %32
standard: %32
library
,: %32
a: %32
set: %32
of: %13
functions: %32
that: %32
provide: %32
input: %32
and: %32
output
,: %32
string: %32
handling
,: %32
storage: %32
management
,: %32
mathematical: %32
routines
,: %32
and: %13
a: %32
variety: %32
of: %32
other: %32
services: %32
for: %32
C: %32
programs
.: %32
We: %32
will: %32
concentrate: %32
on: %32
input: %32
and: %32
output: %13
The: %32
ANSI: %32
standard: %32
defines: %32
these: %32
library: %32
functions: %32
precisely
,: %32
so: %32
that: %32
they: %32
can: %32
exist: %32
in: %32
compatible: %32
form: %32
on: %13
any: %32
system: %32
where: %32
C: %32
exists
.: %32
Programs: %32
that: %32
confine: %32
their: %32
system: %32
interactions: %32
to: %32
facilities: %32
provided: %32
by: %32
the: %13
standard: %32
library: %32
can: %32
be: %32
moved: %32
from: %32
one: %32
system: %32
to: %32
another: %32
without: %32
change
.: %13
The: %32
properties: %32
of: %32
library: %32
functions: %32
are: %32
specified: %32
in: %32
more: %32
than: %32
a: %32
dozen: %32
headers
;: %32
we: %32
have: %32
already: %32
seen: %13
several: %32
of: %32
these
,: %32
including: %32
<
stdio
.
h
>
,: %32
<
string
.
h
>
,: %32
and: %32
<
ctype
.
h
>
.: %32
We: %32
will: %32
not: %32
present: %32
the: %13
entire: %32
library: %32
here
,: %32
since: %32
we: %32
are: %32
more: %32
interested: %32
in: %32
writing: %32
C: %32
programs: %32
that: %32
use: %32
it
.: %32
The: %32
library: %32
is: %32
described: %13
in: %32
detail: %32
in: %32
Appendix: %32
B
.: %13
7
.
1: %32
Standard: %32
Input: %32
and: %32
Output: %13
As: %32
we: %32
said: %32
in: %32
Chapter: %32
1
,: %32
the: %32
library: %32
implements: %32
a: %32
simple: %32
model: %32
of: %32
text: %32
input: %32
and: %32
output
.: %32
A: %32
text: %32
stream: %13
consists: %32
of: %32
a: %32
sequence: %32
of: %32
lines
;: %32
each: %32
line: %32
ends: %32
with: %32
a: %32
newline: %32
character
.: %32
If: %32
the: %32
system: %32
doesn
'
t: %32
operate: %32
that: %13
way
,: %32
the: %32
library: %32
does: %32
whatever: %32
necessary: %32
to: %32
make: %32
it: %32
appear: %32
as: %32
if: %32
it: %32
does
.: %32
For: %32
instance
,: %32
the: %32
library: %32
might: %13
convert: %32
carriage: %32
return: %32
and: %32
linefeed: %32
to: %32
newline: %32
on: %32
input: %32
and: %32
back: %32
again: %32
on: %32
output
.: %13
The: %32
simplest: %32
input: %32
mechanism: %32
is: %32
to: %32
read: %32
one: %32
character: %32
at: %32
a: %32
time: %32
from: %32
the: %32
standard: %32
input
,: %32
normally: %32
the: %13
keyboard
,: %32
with: %32
getchar
:: %13
int: %32
getchar
(
void
): %13
getchar: %32
returns: %32
the: %32
next: %32
input: %32
character: %32
each: %32
time: %32
it: %32
is: %32
called
,: %32
or: %32
EOF: %32
when: %32
it: %32
encounters: %32
end: %32
of: %32
file
.: %13
The: %32
symbolic: %32
constant: %32
EOF: %32
is: %32
defined: %32
in: %32
<
stdio
.
h
>
.: %32
The: %32
value: %32
is: %32
typically: %32
-
1
,: %32
bus: %32
tests: %32
should: %32
be: %13
written: %32
in: %32
terms: %32
of: %32
EOF: %32
so: %32
as: %32
to: %32
be: %32
independent: %32
of: %32
the: %32
specific: %32
value
.: %13
Chapter: %32
7: %32
-: %32
Input: %32
and: %32
Output: %13
In: %32
many: %32
environments
,: %32
a: %32
file: %32
may: %32
be: %32
substituted: %32
for: %32
the: %32
keyboard: %32
by: %32
using: %32
the: %32
<: %32
convention: %32
for: %32
input: %13
redirection
:: %32
if: %32
a: %32
program: %32
prog: %32
uses: %32
getchar
,: %32
then: %32
the: %32
command: %32
line: %13
prog: %32
<
infile: %13
causes: %32
prog: %32
to: %32
read: %32
characters: %32
from: %32
infile: %32
instead
.: %32
The: %32
switching: %32
of: %32
the: %32
input: %32
is: %32
done: %32
in: %32
such: %32
a: %32
way: %13
that: %32
prog: %32
itself: %32
is: %32
oblivious: %32
to: %32
the: %32
change
;: %32
in: %32
particular
,: %32
the: %32
string: %32
`
`
<
infile
'
': %32
is: %32
not: %32
included: %32
in: %32
the: %13
command
-
line: %32
arguments: %32
in: %32
argv
.: %32
Input: %32
switching: %32
is: %32
also: %32
invisible: %32
if: %32
the: %32
input: %32
comes: %32
from: %32
another: %13
program: %32
via: %32
a: %32
pipe: %32
mechanism
:: %32
on: %32
some: %32
systems
,: %32
the: %32
command: %32
line: %13
otherprog: %32
|: %32
prog: %13
runs: %32
the: %32
two: %32
programs: %32
otherprog: %32
and: %32
prog
,: %32
and: %32
pipes: %32
the: %32
standard: %32
output: %32
of: %32
otherprog: %32
into: %32
the: %13
standard: %32
input: %32
for: %32
prog
.: %13
The: %32
function: %13
int: %32
putchar
(
int
): %13
is: %32
used: %32
for: %32
output
:: %32
putchar
(
c
): %32
puts: %32
the: %32
character: %32
c: %32
on: %32
the: %32
standard: %32
output
,: %32
which: %32
is: %32
by: %32
default: %13
the: %32
screen
.: %32
putchar: %32
returns: %32
the: %32
character: %32
written
,: %32
or: %32
EOF: %32
is: %32
an: %32
error: %32
occurs
.: %32
Again
,: %32
output: %32
can: %32
usually: %13
be: %32
directed: %32
to: %32
a: %32
file: %32
with: %32
>
filename
:: %32
if: %32
prog: %32
uses: %32
putchar
,: %13
prog: %32
>
outfile: %13
will: %32
write: %32
the: %32
standard: %32
output: %32
to: %32
outfile: %32
instead
.: %32
If: %32
pipes: %32
are: %32
supported
,: %13
prog: %32
|: %32
anotherprog: %13
puts: %32
the: %32
standard: %32
output: %32
of: %32
prog: %32
into: %32
the: %32
standard: %32
input: %32
of: %32
anotherprog
.: %13
Output: %32
produced: %32
by: %32
printf: %32
also: %32
finds: %32
its: %32
way: %32
to: %32
the: %32
standard: %32
output
.: %32
Calls: %32
to: %32
putchar: %32
and: %32
printf: %13
may: %32
be: %32
interleaved: %32
-: %32
output: %32
happens: %32
in: %32
the: %32
order: %32
in: %32
which: %32
the: %32
calls: %32
are: %32
made
.: %13
Each: %32
source: %32
file: %32
that: %32
refers: %32
to: %32
an: %32
input
/
output: %32
library: %32
function: %32
must: %32
contain: %32
the: %32
line: %13
#
include: %32
<
stdio
.
h
>: %13
before: %32
the: %32
first: %32
reference
.: %32
When: %32
the: %32
name: %32
is: %32
bracketed: %32
by: %32
<: %32
and: %32
>: %32
a: %32
search: %32
is: %32
made: %32
for: %32
the: %32
header: %32
in: %32
a: %13
standard: %32
set: %32
of: %32
places: %32
(
for: %32
example
,: %32
on: %32
UNIX: %32
systems
,: %32
typically: %32
in: %32
the: %32
directory: %32
/
usr
/
include
)
.: %13
Chapter: %32
7: %32
-: %32
Input: %32
and: %32
Output: %13
Many: %32
programs: %32
read: %32
only: %32
one: %32
input: %32
stream: %32
and: %32
write: %32
only: %32
one: %32
output: %32
stream
;: %32
for: %32
such: %32
programs
,: %32
input: %13
and: %32
output: %32
with: %32
getchar
,: %32
putchar
,: %32
and: %32
printf: %32
may: %32
be: %32
entirely: %32
adequate
,: %32
and: %32
is: %32
certainly: %32
enough: %13
to: %32
get: %32
started
.: %32
This: %32
is: %32
particularly: %32
true: %32
if: %32
redirection: %32
is: %32
used: %32
to: %32
connect: %32
the: %32
output: %32
of: %32
one: %32
program: %32
to: %32
the: %13
input: %32
of: %32
the: %32
next
.: %32
For: %32
example
,: %32
consider: %32
the: %32
program: %32
lower
,: %32
which: %32
converts: %32
its: %32
input: %32
to: %32
lower: %32
case
:: %13
#
include: %32
<
stdio
.
h
>: %13
#
include: %32
<
ctype
.
h
>: %13
main
(
): %32
/
*: %32
lower
:: %32
convert: %32
input: %32
to: %32
lower: %32
case
*
/: %13
{: %13
int: %32
c: %13
while: %32
(
(
c: %32
=: %32
getchar
(
)
): %32
!
=: %32
EOF
): %13
putchar
(
tolower
(
c
)
)
;: %13
return: %32
0
;: %13
}: %13
The: %32
function: %32
tolower: %32
is: %32
defined: %32
in: %32
<
ctype
.
h
>
;: %32
it: %32
converts: %32
an: %32
upper: %32
case: %32
letter: %32
to: %32
lower: %32
case
,: %32
and: %13
returns: %32
other: %32
characters: %32
untouched
.: %32
As: %32
we: %32
mentioned: %32
earlier
,: %32
`
`
functions
'
': %32
like: %32
getchar: %32
and: %32
putchar: %13
in: %32
<
stdio
.
h
>: %32
and: %32
tolower: %32
in: %32
<
ctype
.
h
>: %32
are: %32
often: %32
macros
,: %32
thus: %32
avoiding: %32
the: %32
overhead: %32
of: %32
a: %13
function: %32
call: %32
per: %32
character
.: %32
We: %32
will: %32
show: %32
how: %32
this: %32
is: %32
done: %32
in: %32
Section: %32
8
.
5
.: %32
Regardless: %32
of: %32
how: %32
the: %13
<
ctype
.
h
>: %32
functions: %32
are: %32
implemented: %32
on: %32
a: %32
given: %32
machine
,: %32
programs: %32
that: %32
use: %32
them: %32
are: %32
shielded: %32
from: %13
knowledge: %32
of: %32
the: %32
character: %32
set
.: %13
Exercise: %32
7
-
1
.: %32
Write: %32
a: %32
program: %32
that: %32
converts: %32
upper: %32
case: %32
to: %32
lower: %32
or: %32
lower: %32
case: %32
to: %32
upper
,: %32
depending: %32
on: %32
the: %13
name: %32
it: %32
is: %32
invoked: %32
with
,: %32
as: %32
found: %32
in: %32
argv
[
0
]
.: %13
7
.
2: %32
Formatted: %32
Output: %32
-: %32
printf: %13
The: %32
output: %32
function: %32
printf: %32
translates: %32
internal: %32
values: %32
to: %32
characters
.: %32
We: %32
have: %32
used: %32
printf: %32
informally: %13
in: %32
previous: %32
chapters
.: %32
The: %32
description: %32
here: %32
covers: %32
most: %32
typical: %32
uses: %32
but: %32
is: %32
not: %32
complete
;: %32
for: %32
the: %32
full: %32
story
,: %13
see: %32
Appendix: %32
B
.: %13
int: %32
printf
(
char: %32
*
format
,: %32
arg
1
,: %32
arg
2
,: %32
.
.
.
)
;: %13
printf: %32
converts
,: %32
formats
,: %32
and: %32
prints: %32
its: %32
arguments: %32
on: %32
the: %32
standard: %32
output: %32
under: %32
control: %32
of: %32
the: %13
format
.: %32
It: %32
returns: %32
the: %32
number: %32
of: %32
characters: %32
printed
.: %13
The: %32
format: %32
string: %32
contains: %32
two: %32
types: %32
of: %32
objects
:: %32
ordinary: %32
characters
,: %32
which: %32
are: %32
copied: %32
to: %32
the: %32
output: %13
stream
,: %32
and: %32
conversion: %32
specifications
,: %32
each: %32
of: %32
which: %32
causes: %32
conversion: %32
and: %32
printing: %32
of: %32
the: %32
next: %13
successive: %32
argument: %32
to: %32
printf
.: %32
Each: %32
conversion: %32
specification: %32
begins: %32
with: %32
a: %32
%: %32
and: %32
ends: %32
with: %32
a: %13
Chapter: %32
7: %32
-: %32
Input: %32
and: %32
Output: %13
conversion: %32
character
.: %32
Between: %32
the: %32
%: %32
and: %32
the: %32
conversion: %32
character: %32
there: %32
may: %32
be
,: %32
in: %32
order
:: %13
q: %13
q: %13
q: %13
q: %13
q: %13
A: %32
minus: %32
sign
,: %32
which: %32
specifies: %32
left: %32
adjustment: %32
of: %32
the: %32
converted: %32
argument
.: %13
A: %32
number: %32
that: %32
specifies: %32
the: %32
minimum: %32
field: %32
width
.: %32
The: %32
converted: %32
argument: %32
will: %32
be: %32
printed: %32
in: %32
a: %13
field: %32
at: %32
least: %32
this: %32
wide
.: %32
If: %32
necessary: %32
it: %32
will: %32
be: %32
padded: %32
on: %32
the: %32
left: %32
(
or: %32
right
,: %32
if: %32
left: %32
adjustment: %32
is: %13
called: %32
for
): %32
to: %32
make: %32
up: %32
the: %32
field: %32
width
.: %13
A: %32
period
,: %32
which: %32
separates: %32
the: %32
field: %32
width: %32
from: %32
the: %32
precision
.: %13
A: %32
number
,: %32
the: %32
precision
,: %32
that: %32
specifies: %32
the: %32
maximum: %32
number: %32
of: %32
characters: %32
to: %32
be: %32
printed: %32
from: %32
a: %13
string
,: %32
or: %32
the: %32
number: %32
of: %32
digits: %32
after: %32
the: %32
decimal: %32
point: %32
of: %32
a: %32
floating
-
point: %32
value
,: %32
or: %32
the: %32
minimum: %13
number: %32
of: %32
digits: %32
for: %32
an: %32
integer
.: %13
An: %32
h: %32
if: %32
the: %32
integer: %32
is: %32
to: %32
be: %32
printed: %32
as: %32
a: %32
short
,: %32
or: %32
l: %32
(
letter: %32
ell
): %32
if: %32
as: %32
a: %32
long
.: %13
Conversion: %32
characters: %32
are: %32
shown: %32
in: %32
Table: %32
7
.
1
.: %32
If: %32
the: %32
character: %32
after: %32
the: %32
%: %32
is: %32
not: %32
a: %32
conversion: %13
specification
,: %32
the: %32
behavior: %32
is: %32
undefined
.: %13
Table: %32
7
.
1: %32
Basic: %32
Printf: %32
Conversions: %13
Character: %13
Argument: %32
type
;: %32
Printed: %32
As: %13
d
,
i: %32
int
;: %32
decimal: %32
number: %13
o: %32
int
;: %32
unsigned: %32
octal: %32
number: %32
(
without: %32
a: %32
leading: %32
zero
): %13
x
,
X: %32
int
;: %32
unsigned: %32
hexadecimal: %32
number: %32
(
without: %32
a: %32
leading: %32
0
x: %32
or: %32
0
X
)
,: %32
using: %32
abcdef: %32
or: %13
: %32%32%32
ABCDEF: %32
for: %32
1
0
,: %32
.
.
.
,
1
5
.: %13
u: %32
int
;: %32
unsigned: %32
decimal: %32
number: %13
c: %32
int
;: %32
single: %32
character: %13
s: %32
char: %32
*
;: %32
print: %32
characters: %32
from: %32
the: %32
string: %32
until: %32
a: %32
'
\
0
': %32
or: %32
the: %32
number: %32
of: %32
characters: %32
given: %13
: %32
by: %32
the: %32
precision
.: %13
f: %32
double
;: %32
[
-
]
m
.
dddddd
,: %32
where: %32
the: %32
number: %32
of: %32
d
'
s: %32
is: %32
given: %32
by: %32
the: %32
precision: %32
(
default: %32
6
)
.: %13
e
,
E: %32
double
;: %32
[
-
]
m
.
dddddde
+
/
-
xx: %32
or: %32
[
-
]
m
.
ddddddE
+
/
-
xx
,: %32
where: %32
the: %32
number: %32
of: %32
d
'
s: %32
is: %13
: %32%32%32
given: %32
by: %32
the: %32
precision: %32
(
default: %32
6
)
.: %13
g
,
G: %32
double
;: %32
use: %32
%:
e: %32
or: %32
%:
E: %32
if: %32
the: %32
exponent: %32
is: %32
less: %32
than: %32
-
4: %32
or: %32
greater: %32
than: %32
or: %32
equal: %32
to: %32
the: %13
: %32%32%32
precision
;: %32
otherwise: %32
use: %32
%:
f
.: %32
Trailing: %32
zeros: %32
and: %32
a: %32
trailing: %32
decimal: %32
point: %32
are: %32
not: %32
printed
.: %13
p: %32
void: %32
*
;: %32
pointer: %32
(
implementation
-
dependent: %32
representation
)
.: %13
%: %32
no: %32
argument: %32
is: %32
converted
;: %32
print: %32
a: %32
%: %13
A: %32
width: %32
or: %32
precision: %32
may: %32
be: %32
specified: %32
as: %32
*
,: %32
in: %32
which: %32
case: %32
the: %32
value: %32
is: %32
computed: %32
by: %32
converting: %32
the: %32
next: %13
argument: %32
(
which: %32
must: %32
be: %32
an: %32
int
)
.: %32
For: %32
example
,: %32
to: %32
print: %32
at: %32
most: %32
max: %32
characters: %32
from: %32
a: %32
string: %32
s
,: %13
printf
(
"
%:
.
*
s
"
,: %32
max
,: %32
s
)
;: %13
Chapter: %32
7: %32
-: %32
Input: %32
and: %32
Output: %13
Most: %32
of: %32
the: %32
format: %32
conversions: %32
have: %32
been: %32
illustrated: %32
in: %32
earlier: %32
chapters
.: %32
One: %32
exception: %32
is: %32
the: %32
precision: %32
as: %13
it: %32
relates: %32
to: %32
strings
.: %32
The: %32
following: %32
table: %32
shows: %32
the: %32
effect: %32
of: %32
a: %32
variety: %32
of: %32
specifications: %32
in: %32
printing: %32
`
`
hello
,: %13
world
'
': %32
(
1
2: %32
characters
)
.: %32
We: %32
have: %32
put: %32
colons: %32
around: %32
each: %32
field: %32
so: %32
you: %32
can: %32
see: %32
it: %32
extent
.: %13
::
%:
s
:: %13
::
%:
1
0
s
:: %13
::
%:
.
1
0
s
:: %13
::
%:
-
1
0
s
:: %13
::
%:
.
1
5
s
:: %13
::
%:
-
1
5
s
:: %13
::
%:
1
5
.
1
0
s
:: %13
::
%:
-
1
5
.
1
0
s
:: %13
::
hello
,: %32
world
:: %13
::
hello
,: %32
world
:: %13
::
hello
,: %32
wor
:: %13
::
hello
,: %32
world
:: %13
::
hello
,: %32
world
:: %13
::
hello
,: %32
world: %13
:: %13
:: %13
hello
,: %32
wor
:: %13
::
hello
,: %32
wor: %13
:: %13
A: %32
warning
:: %32
printf: %32
uses: %32
its: %32
first: %32
argument: %32
to: %32
decide: %32
how: %32
many: %32
arguments: %32
follow: %32
and: %32
what: %32
their: %32
type: %32
is
.: %13
It: %32
will: %32
get: %32
confused
,: %32
and: %32
you: %32
will: %32
get: %32
wrong: %32
answers
,: %32
if: %32
there: %32
are: %32
not: %32
enough: %32
arguments: %32
of: %32
if: %32
they: %32
are: %32
the: %13
wrong: %32
type
.: %32
You: %32
should: %32
also: %32
be: %32
aware: %32
of: %32
the: %32
difference: %32
between: %32
these: %32
two: %32
calls
:: %13
printf
(
s
)
;: %13
printf
(
"
%:
s
"
,: %32
s
)
;: %13
/
*: %32
FAILS: %32
if: %32
s: %32
contains: %32
%: %32
*
/: %13
/
*: %32
SAFE: %32
*
/: %13
The: %32
function: %32
sprintf: %32
does: %32
the: %32
same: %32
conversions: %32
as: %32
printf: %32
does
,: %32
but: %32
stores: %32
the: %32
output: %32
in: %32
a: %32
string
:: %13
int: %32
sprintf
(
char: %32
*
string
,: %32
char: %32
*
format
,: %32
arg
1
,: %32
arg
2
,: %32
.
.
.
)
;: %13
sprintf: %32
formats: %32
the: %32
arguments: %32
in: %32
arg
1
,: %32
arg
2
,: %32
etc
.
,: %32
according: %32
to: %32
format: %32
as: %32
before
,: %32
but: %32
places: %32
the: %13
result: %32
in: %32
string: %32
instead: %32
of: %32
the: %32
standard: %32
output
;: %32
string: %32
must: %32
be: %32
big: %32
enough: %32
to: %32
receive: %32
the: %32
result
.: %13
Exercise: %32
7
-
2
.: %32
Write: %32
a: %32
program: %32
that: %32
will: %32
print: %32
arbitrary: %32
input: %32
in: %32
a: %32
sensible: %32
way
.: %32
As: %32
a: %32
minimum
,: %32
it: %32
should: %13
print: %32
non
-
graphic: %32
characters: %32
in: %32
octal: %32
or: %32
hexadecimal: %32
according: %32
to: %32
local: %32
custom
,: %32
and: %32
break: %32
long: %32
text: %32
lines
.: %13
7
.
3: %32
Variable
-
length: %32
Argument: %32
Lists: %13
This: %32
section: %32
contains: %32
an: %32
implementation: %32
of: %32
a: %32
minimal: %32
version: %32
of: %32
printf
,: %32
to: %32
show: %32
how: %32
to: %32
write: %32
a: %13
function: %32
that: %32
processes: %32
a: %32
variable
-
length: %32
argument: %32
list: %32
in: %32
a: %32
portable: %32
way
.: %32
Since: %32
we: %32
are: %32
mainly: %32
interested: %13
in: %32
the: %32
argument: %32
processing
,: %32
minprintf: %32
will: %32
process: %32
the: %32
format: %32
string: %32
and: %32
arguments: %32
but: %32
will: %32
call: %32
the: %13
real: %32
printf: %32
to: %32
do: %32
the: %32
format: %32
conversions
.: %13
The: %32
proper: %32
declaration: %32
for: %32
printf: %32
is: %13
int: %32
printf
(
char: %32
*
fmt
,: %32
.
.
.
): %13
Chapter: %32
7: %32
-: %32
Input: %32
and: %32
Output: %13
where: %32
the: %32
declaration: %32
.
.
.: %32
means: %32
that: %32
the: %32
number: %32
and: %32
types: %32
of: %32
these: %32
arguments: %32
may: %32
vary
.: %32
The: %13
declaration: %32
.
.
.: %32
can: %32
only: %32
appear: %32
at: %32
the: %32
end: %32
of: %32
an: %32
argument: %32
list
.: %32
Our: %32
minprintf: %32
is: %32
declared: %32
as: %13
void: %32
minprintf
(
char: %32
*
fmt
,: %32
.
.
.
): %13
since: %32
we: %32
will: %32
not: %32
return: %32
the: %32
character: %32
count: %32
that: %32
printf: %32
does
.: %13
The: %32
tricky: %32
bit: %32
is: %32
how: %32
minprintf: %32
walks: %32
along: %32
the: %32
argument: %32
list: %32
when: %32
the: %32
list: %32
doesn
'
t: %32
even: %32
have: %32
a: %32
name
.: %13
The: %32
standard: %32
header: %32
<
stdarg
.
h
>: %32
contains: %32
a: %32
set: %32
of: %32
macro: %32
definitions: %32
that: %32
define: %32
how: %32
to: %32
step: %32
through: %32
an: %13
argument: %32
list
.: %32
The: %32
implementation: %32
of: %32
this: %32
header: %32
will: %32
vary: %32
from: %32
machine: %32
to: %32
machine
,: %32
but: %32
the: %32
interface: %32
it: %13
presents: %32
is: %32
uniform
.: %13
The: %32
type: %32
va
_
list: %32
is: %32
used: %32
to: %32
declare: %32
a: %32
variable: %32
that: %32
will: %32
refer: %32
to: %32
each: %32
argument: %32
in: %32
turn
;: %32
in: %32
minprintf
,: %13
this: %32
variable: %32
is: %32
called: %32
ap
,: %32
for: %32
`
`
argument: %32
pointer
.
'
': %32
The: %32
macro: %32
va
_
start: %32
initializes: %32
ap: %32
to: %32
point: %32
to: %32
the: %13
first: %32
unnamed: %32
argument
.: %32
It: %32
must: %32
be: %32
called: %32
once: %32
before: %32
ap: %32
is: %32
used
.: %32
There: %32
must: %32
be: %32
at: %32
least: %32
one: %32
named: %13
argument
;: %32
the: %32
final: %32
named: %32
argument: %32
is: %32
used: %32
by: %32
va
_
start: %32
to: %32
get: %32
started
.: %13
Each: %32
call: %32
of: %32
va
_
arg: %32
returns: %32
one: %32
argument: %32
and: %32
steps: %32
ap: %32
to: %32
the: %32
next
;: %32
va
_
arg: %32
uses: %32
a: %32
type: %32
name: %32
to: %13
determine: %32
what: %32
type: %32
to: %32
return: %32
and: %32
how: %32
big: %32
a: %32
step: %32
to: %32
take
.: %32
Finally
,: %32
va
_
end: %32
does: %32
whatever: %32
cleanup: %32
is: %13
necessary
.: %32
It: %32
must: %32
be: %32
called: %32
before: %32
the: %32
program: %32
returns
.: %13
These: %32
properties: %32
form: %32
the: %32
basis: %32
of: %32
our: %32
simplified: %32
printf
:: %13
#
include: %32
<
stdarg
.
h
>: %13
/
*: %32
minprintf
:: %32
minimal: %32
printf: %32
with: %32
variable: %32
argument: %32
list: %32
*
/: %13
void: %32
minprintf
(
char: %32
*
fmt
,: %32
.
.
.
): %13
{: %13
va
_
list: %32
ap
;: %32
/
*: %32
points: %32
to: %32
each: %32
unnamed: %32
arg: %32
in: %32
turn: %32
*
/: %13
char: %32
*
p
,: %32
*
sval
;: %13
int: %32
ival
;: %13
double: %32
dval
;: %13
va
_
start
(
ap
,: %32
fmt
)
;: %32
/
*: %32
make: %32
ap: %32
point: %32
to: %32
1
st: %32
unnamed: %32
arg: %32
*
/: %13
for: %32
(
p: %32
=: %32
fmt
;: %32
*
p
;: %32
p
+
+
): %32
{: %13
if: %32
(
*
p: %32
!
=: %32
'
%:
'
): %32
{: %13
putchar
(
*
p
)
;: %13
continue
;: %13
}: %13
switch: %32
(
*
+
+
p
): %32
{: %13
case: %32
'
d
'
:: %13
ival: %32
=: %32
va
_
arg
(
ap
,: %32
int
)
;: %13
Chapter: %32
7: %32
-: %32
Input: %32
and: %32
Output: %13
printf
(
"
%:
d
"
,: %32
ival
)
;: %13
break
;: %13
case: %32
'
f
'
:: %13
dval: %32
=: %32
va
_
arg
(
ap
,: %32
double
)
;: %13
printf
(
"
%:
f
"
,: %32
dval
)
;: %13
break
;: %13
case: %32
'
s
'
:: %13
for: %32
(
sval: %32
=: %32
va
_
arg
(
ap
,: %32
char: %32
*
)
;: %32
*
sval
;: %32
sval
+
+
): %13
putchar
(
*
sval
)
;: %13
break
;: %13
default
:: %13
putchar
(
*
p
)
;: %13
break
;: %13
}: %13
}: %13
va
_
end
(
ap
)
;: %32
/
*: %32
clean: %32
up: %32
when: %32
done: %32
*
/: %13
}: %13
Exercise: %32
7
-
3
.: %32
Revise: %32
minprintf: %32
to: %32
handle: %32
more: %32
of: %32
the: %32
other: %32
facilities: %32
of: %32
printf
.: %13
7
.
4: %32
Formatted: %32
Input: %32
-: %32
Scanf: %13
The: %32
function: %32
scanf: %32
is: %32
the: %32
input: %32
analog: %32
of: %32
printf
,: %32
providing: %32
many: %32
of: %32
the: %32
same: %32
conversion: %32
facilities: %32
in: %13
the: %32
opposite: %32
direction
.: %13
int: %32
scanf
(
char: %32
*
format
,: %32
.
.
.
): %13
scanf: %32
reads: %32
characters: %32
from: %32
the: %32
standard: %32
input
,: %32
interprets: %32
them: %32
according: %32
to: %32
the: %32
specification: %32
in: %13
format
,: %32
and: %32
stores: %32
the: %32
results: %32
through: %32
the: %32
remaining: %32
arguments
.: %32
The: %32
format: %32
argument: %32
is: %32
described: %13
below
;: %32
the: %32
other: %32
arguments
,: %32
each: %32
of: %32
which: %32
must: %32
be: %32
a: %32
pointer
,: %32
indicate: %32
where: %32
the: %32
corresponding: %32
converted: %13
input: %32
should: %32
be: %32
stored
.: %32
As: %32
with: %32
printf
,: %32
this: %32
section: %32
is: %32
a: %32
summary: %32
of: %32
the: %32
most: %32
useful: %32
features
,: %32
not: %32
an: %13
exhaustive: %32
list
.: %13
scanf: %32
stops: %32
when: %32
it: %32
exhausts: %32
its: %32
format: %32
string
,: %32
or: %32
when: %32
some: %32
input: %32
fails: %32
to: %32
match: %32
the: %32
control: %13
specification
.: %32
It: %32
returns: %32
as: %32
its: %32
value: %32
the: %32
number: %32
of: %32
successfully: %32
matched: %32
and: %32
assigned: %32
input: %32
items
.: %32
This: %13
can: %32
be: %32
used: %32
to: %32
decide: %32
how: %32
many: %32
items: %32
were: %32
found
.: %32
On: %32
the: %32
end: %32
of: %32
file
,: %32
EOF: %32
is: %32
returned
;: %32
note: %32
that: %32
this: %32
is: %13
different: %32
from: %32
0
,: %32
which: %32
means: %32
that: %32
the: %32
next: %32
input: %32
character: %32
does: %32
not: %32
match: %32
the: %32
first: %32
specification: %32
in: %32
the: %13
format: %32
string
.: %32
The: %32
next: %32
call: %32
to: %32
scanf: %32
resumes: %32
searching: %32
immediately: %32
after: %32
the: %32
last: %32
character: %32
already: %13
converted
.: %13
There: %32
is: %32
also: %32
a: %32
function: %32
sscanf: %32
that: %32
reads: %32
from: %32
a: %32
string: %32
instead: %32
of: %32
the: %32
standard: %32
input
:: %13
Chapter: %32
7: %32
-: %32
Input: %32
and: %32
Output: %13
int: %32
sscanf
(
char: %32
*
string
,: %32
char: %32
*
format
,: %32
arg
1
,: %32
arg
2
,: %32
.
.
.
): %13
It: %32
scans: %32
the: %32
string: %32
according: %32
to: %32
the: %32
format: %32
in: %32
format: %32
and: %32
stores: %32
the: %32
resulting: %32
values: %32
through: %32
arg
1
,: %13
arg
2
,: %32
etc
.: %32
These: %32
arguments: %32
must: %32
be: %32
pointers
.: %13
The: %32
format: %32
string: %32
usually: %32
contains: %32
conversion: %32
specifications
,: %32
which: %32
are: %32
used: %32
to: %32
control: %32
conversion: %32
of: %13
input
.: %32
The: %32
format: %32
string: %32
may: %32
contain
:: %13
q: %13
q: %13
q: %13
Blanks: %32
or: %32
tabs
,: %32
which: %32
are: %32
not: %32
ignored
.: %13
Ordinary: %32
characters: %32
(
not: %32
%:
)
,: %32
which: %32
are: %32
expected: %32
to: %32
match: %32
the: %32
next: %32
non
-
white: %32
space: %32
character: %32
of: %13
the: %32
input: %32
stream
.: %13
Conversion: %32
specifications
,: %32
consisting: %32
of: %32
the: %32
character: %32
%:
,: %32
an: %32
optional: %32
assignment: %32
suppression: %13
character: %32
*
,: %32
an: %32
optional: %32
number: %32
specifying: %32
a: %32
maximum: %32
field: %32
width
,: %32
an: %32
optional: %32
h
,: %32
l: %32
or: %32
L: %13
indicating: %32
the: %32
width: %32
of: %32
the: %32
target
,: %32
and: %32
a: %32
conversion: %32
character
.: %13
A: %32
conversion: %32
specification: %32
directs: %32
the: %32
conversion: %32
of: %32
the: %32
next: %32
input: %32
field
.: %32
Normally: %32
the: %32
result: %32
is: %32
places: %32
in: %13
the: %32
variable: %32
pointed: %32
to: %32
by: %32
the: %32
corresponding: %32
argument
.: %32
If: %32
assignment: %32
suppression: %32
is: %32
indicated: %32
by: %32
the: %32
*: %13
character
,: %32
however
,: %32
the: %32
input: %32
field: %32
is: %32
skipped
;: %32
no: %32
assignment: %32
is: %32
made
.: %32
An: %32
input: %32
field: %32
is: %32
defined: %32
as: %32
a: %32
string: %13
of: %32
non
-
white: %32
space: %32
characters
;: %32
it: %32
extends: %32
either: %32
to: %32
the: %32
next: %32
white: %32
space: %32
character: %32
or: %32
until: %32
the: %32
field: %32
width
,: %13
is: %32
specified
,: %32
is: %32
exhausted
.: %32
This: %32
implies: %32
that: %32
scanf: %32
will: %32
read: %32
across: %32
boundaries: %32
to: %32
find: %32
its: %32
input
,: %32
since: %13
newlines: %32
are: %32
white: %32
space
.: %32
(
White: %32
space: %32
characters: %32
are: %32
blank
,: %32
tab
,: %32
newline
,: %32
carriage: %32
return
,: %32
vertical: %32
tab
,: %13
and: %32
formfeed
.
): %13
The: %32
conversion: %32
character: %32
indicates: %32
the: %32
interpretation: %32
of: %32
the: %32
input: %32
field
.: %32
The: %32
corresponding: %32
argument: %32
must: %13
be: %32
a: %32
pointer
,: %32
as: %32
required: %32
by: %32
the: %32
call
-
by
-
value: %32
semantics: %32
of: %32
C
.: %32
Conversion: %32
characters: %32
are: %32
shown: %32
in: %32
Table: %13
7
.
2
.: %13
Table: %32
7
.
2
:: %32
Basic: %32
Scanf: %32
Conversions: %13
Character: %13
Input: %32
Data
;: %32
Argument: %32
type: %13
d: %32
decimal: %32
integer
;: %32
int: %32
*: %13
i: %32
integer
;: %32
int: %32
*
.: %32
The: %32
integer: %32
may: %32
be: %32
in: %32
octal: %32
(
leading: %32
0
): %32
or: %32
hexadecimal: %32
(
leading: %32
0
x: %32
or: %13
: %32
0
X
)
.: %13
o: %32
octal: %32
integer: %32
(
with: %32
or: %32
without: %32
leading: %32
zero
)
;: %32
int: %32
*: %13
u: %32
unsigned: %32
decimal: %32
integer
;: %32
unsigned: %32
int: %32
*: %13
x: %32
hexadecimal: %32
integer: %32
(
with: %32
or: %32
without: %32
leading: %32
0
x: %32
or: %32
0
X
)
;: %32
int: %32
*: %13
c: %32
characters
;: %32
char: %32
*
.: %32
The: %32
next: %32
input: %32
characters: %32
(
default: %32
1
): %32
are: %32
placed: %32
at: %32
the: %32
indicated: %32
spot
.: %13
: %32
The: %32
normal: %32
skip
-
over: %32
white: %32
space: %32
is: %32
suppressed
;: %32
to: %32
read: %32
the: %32
next: %32
non
-
white: %32
space: %13
character
,: %32
use: %32
%:
1
s: %13
Chapter: %32
7: %32
-: %32
Input: %32
and: %32
Output: %13
s: %32
character: %32
string: %32
(
not: %32
quoted
)
;: %32
char: %32
*
,: %32
pointing: %32
to: %32
an: %32
array: %32
of: %32
characters: %32
long: %32
enough: %32
for: %13
: %32
the: %32
string: %32
and: %32
a: %32
terminating: %32
'
\
0
': %32
that: %32
will: %32
be: %32
added
.: %13
e
,
f
,
g: %32
floating
-
point: %32
number: %32
with: %32
optional: %32
sign
,: %32
optional: %32
decimal: %32
point: %32
and: %32
optional: %32
exponent
;: %13
: %32%32%32%32%32
float: %32
*: %13
%: %32
literal: %32
%:
;: %32
no: %32
assignment: %32
is: %32
made
.: %13
The: %32
conversion: %32
characters: %32
d
,: %32
i
,: %32
o
,: %32
u
,: %32
and: %32
x: %32
may: %32
be: %32
preceded: %32
by: %32
h: %32
to: %32
indicate: %32
that: %32
a: %32
pointer: %32
to: %32
short: %13
rather: %32
than: %32
int: %32
appears: %32
in: %32
the: %32
argument: %32
list
,: %32
or: %32
by: %32
l: %32
(
letter: %32
ell
): %32
to: %32
indicate: %32
that: %32
a: %32
pointer: %32
to: %32
long: %32
appears: %13
in: %32
the: %32
argument: %32
list
.: %13
As: %32
a: %32
first: %32
example
,: %32
the: %32
rudimentary: %32
calculator: %32
of: %32
Chapter: %32
4: %32
can: %32
be: %32
written: %32
with: %32
scanf: %32
to: %32
do: %32
the: %32
input: %13
conversion
:: %13
#
include: %32
<
stdio
.
h
>: %13
main
(
): %32
/
*: %32
rudimentary: %32
calculator: %32
*
/: %13
{: %13
double: %32
sum
,: %32
v
;: %13
sum: %32
=: %32
0
;: %13
while: %32
(
scanf
(
"
%:
lf
"
,: %32
&
v
): %32
=
=: %32
1
): %13
printf
(
"
\
t
%:
.
2
f
\
n
"
,: %32
sum: %32
+
=: %32
v
)
;: %13
return: %32
0
;: %13
}: %13
Suppose: %32
we: %32
want: %32
to: %32
read: %32
input: %32
lines: %32
that: %32
contain: %32
dates: %32
of: %32
the: %32
form: %13
2
5: %32
Dec: %32
1
9
8
8: %13
The: %32
scanf: %32
statement: %32
is: %13
int: %32
day
,: %32
year
;: %13
char: %32
monthname
[
2
0
]
;: %13
scanf
(
"
%:
d: %32
%:
s: %32
%:
d
"
,: %32
&
day
,: %32
monthname
,: %32
&
year
)
;: %13
No: %32
&: %32
is: %32
used: %32
with: %32
monthname
,: %32
since: %32
an: %32
array: %32
name: %32
is: %32
a: %32
pointer
.: %13
Literal: %32
characters: %32
can: %32
appear: %32
in: %32
the: %32
scanf: %32
format: %32
string
;: %32
they: %32
must: %32
match: %32
the: %32
same: %32
characters: %32
in: %32
the: %13
input
.: %32
So: %32
we: %32
could: %32
read: %32
dates: %32
of: %32
the: %32
form: %32
mm
/
dd
/
yy: %32
with: %32
the: %32
scanf: %32
statement
:: %13
Chapter: %32
7: %32
-: %32
Input: %32
and: %32
Output: %13
int: %32
day
,: %32
month
,: %32
year
;: %13
scanf
(
"
%:
d
/
%:
d
/
%:
d
"
,: %32
&
month
,: %32
&
day
,: %32
&
year
)
;: %13
scanf: %32
ignores: %32
blanks: %32
and: %32
tabs: %32
in: %32
its: %32
format: %32
string
.: %32
Furthermore
,: %32
it: %32
skips: %32
over: %32
white: %32
space: %32
(
blanks
,: %32
tabs
,: %13
newlines
,: %32
etc
.
): %32
as: %32
it: %32
looks: %32
for: %32
input: %32
values
.: %32
To: %32
read: %32
input: %32
whose: %32
format: %32
is: %32
not: %32
fixed
,: %32
it: %32
is: %32
often: %32
best: %32
to: %32
read: %13
a: %32
line: %32
at: %32
a: %32
time
,: %32
then: %32
pick: %32
it: %32
apart: %32
with: %32
scanf
.: %32
For: %32
example
,: %32
suppose: %32
we: %32
want: %32
to: %32
read: %32
lines: %32
that: %32
might: %13
contain: %32
a: %32
date: %32
in: %32
either: %32
of: %32
the: %32
forms: %32
above
.: %32
Then: %32
we: %32
could: %32
write: %13
while: %32
(
getline
(
line
,: %32
sizeof
(
line
)
): %32
>: %32
0
): %32
{: %13
if: %32
(
sscanf
(
line
,: %32
"
%:
d: %32
%:
s: %32
%:
d
"
,: %32
&
day
,: %32
monthname
,: %32
&
year
): %32
=
=: %32
3
): %13
printf
(
"
valid
:: %32
%:
s
\
n
"
,: %32
line
)
;: %32
/
*: %32
2
5: %32
Dec: %32
1
9
8
8: %32
form: %32
*
/: %13
else: %32
if: %32
(
sscanf
(
line
,: %32
"
%:
d
/
%:
d
/
%:
d
"
,: %32
&
month
,: %32
&
day
,: %32
&
year
): %32
=
=: %32
3
): %13
printf
(
"
valid
:: %32
%:
s
\
n
"
,: %32
line
)
;: %32
/
*: %32
mm
/
dd
/
yy: %32
form: %32
*
/: %13
else: %13
printf
(
"
invalid
:: %32
%:
s
\
n
"
,: %32
line
)
;: %32
/
*: %32
invalid: %32
form: %32
*
/: %13
}: %13
Calls: %32
to: %32
scanf: %32
can: %32
be: %32
mixed: %32
with: %32
calls: %32
to: %32
other: %32
input: %32
functions
.: %32
The: %32
next: %32
call: %32
to: %32
any: %32
input: %32
function: %32
will: %13
begin: %32
by: %32
reading: %32
the: %32
first: %32
character: %32
not: %32
read: %32
by: %32
scanf
.: %13
A: %32
final: %32
warning
:: %32
the: %32
arguments: %32
to: %32
scanf: %32
and: %32
sscanf: %32
must: %32
be: %32
pointers
.: %32
By: %32
far: %32
the: %32
most: %32
common: %32
error: %13
is: %32
writing: %13
scanf
(
"
%:
d
"
,: %32
n
)
;: %13
instead: %32
of: %13
scanf
(
"
%:
d
"
,: %32
&
n
)
;: %13
This: %32
error: %32
is: %32
not: %32
generally: %32
detected: %32
at: %32
compile: %32
time
.: %13
Exercise: %32
7
-
4
.: %32
Write: %32
a: %32
private: %32
version: %32
of: %32
scanf: %32
analogous: %32
to: %32
minprintf: %32
from: %32
the: %32
previous: %32
section
.: %13
Exercise: %32
5
-
5
.: %32
Rewrite: %32
the: %32
postfix: %32
calculator: %32
of: %32
Chapter: %32
4: %32
to: %32
use: %32
scanf: %32
and
/
or: %32
sscanf: %32
to: %32
do: %32
the: %32
input: %13
and: %32
number: %32
conversion
.: %13
7
.
5: %32
File: %32
Access: %13
The: %32
examples: %32
so: %32
far: %32
have: %32
all: %32
read: %32
the: %32
standard: %32
input: %32
and: %32
written: %32
the: %32
standard: %32
output
,: %32
which: %32
are: %13
automatically: %32
defined: %32
for: %32
a: %32
program: %32
by: %32
the: %32
local: %32
operating: %32
system
.: %13
Chapter: %32
7: %32
-: %32
Input: %32
and: %32
Output: %13
The: %32
next: %32
step: %32
is: %32
to: %32
write: %32
a: %32
program: %32
that: %32
accesses: %32
a: %32
file: %32
that: %32
is: %32
not: %32
already: %32
connected: %32
to: %32
the: %32
program
.: %32
One: %13
program: %32
that: %32
illustrates: %32
the: %32
need: %32
for: %32
such: %32
operations: %32
is: %32
cat
,: %32
which: %32
concatenates: %32
a: %32
set: %32
of: %32
named: %32
files: %32
into: %13
the: %32
standard: %32
output
.: %32
cat: %32
is: %32
used: %32
for: %32
printing: %32
files: %32
on: %32
the: %32
screen
,: %32
and: %32
as: %32
a: %32
general
-
purpose: %32
input: %32
collector: %13
for: %32
programs: %32
that: %32
do: %32
not: %32
have: %32
the: %32
capability: %32
of: %32
accessing: %32
files: %32
by: %32
name
.: %32
For: %32
example
,: %32
the: %32
command: %13
cat: %32
x
.
c: %32
y
.
c: %13
prints: %32
the: %32
contents: %32
of: %32
the: %32
files: %32
x
.
c: %32
and: %32
y
.
c: %32
(
and: %32
nothing: %32
else
): %32
on: %32
the: %32
standard: %32
output
.: %13
The: %32
question: %32
is: %32
how: %32
to: %32
arrange: %32
for: %32
the: %32
named: %32
files: %32
to: %32
be: %32
read: %32
-: %32
that: %32
is
,: %32
how: %32
to: %32
connect: %32
the: %32
external: %32
names: %13
that: %32
a: %32
user: %32
thinks: %32
of: %32
to: %32
the: %32
statements: %32
that: %32
read: %32
the: %32
data
.: %13
The: %32
rules: %32
are: %32
simple
.: %32
Before: %32
it: %32
can: %32
be: %32
read: %32
or: %32
written
,: %32
a: %32
file: %32
has: %32
to: %32
be: %32
opened: %32
by: %32
the: %32
library: %32
function: %13
fopen
.: %32
fopen: %32
takes: %32
an: %32
external: %32
name: %32
like: %32
x
.
c: %32
or: %32
y
.
c
,: %32
does: %32
some: %32
housekeeping: %32
and: %32
negotiation: %32
with: %13
the: %32
operating: %32
system: %32
(
details: %32
of: %32
which: %32
needn
'
t: %32
concern: %32
us
)
,: %32
and: %32
returns: %32
a: %32
pointer: %32
to: %32
be: %32
used: %32
in: %32
subsequent: %13
reads: %32
or: %32
writes: %32
of: %32
the: %32
file
.: %13
This: %32
pointer
,: %32
called: %32
the: %32
file: %32
pointer
,: %32
points: %32
to: %32
a: %32
structure: %32
that: %32
contains: %32
information: %32
about: %32
the: %32
file
,: %32
such: %32
as: %13
the: %32
location: %32
of: %32
a: %32
buffer
,: %32
the: %32
current: %32
character: %32
position: %32
in: %32
the: %32
buffer
,: %32
whether: %32
the: %32
file: %32
is: %32
being: %32
read: %32
or: %13
written
,: %32
and: %32
whether: %32
errors: %32
or: %32
end: %32
of: %32
file: %32
have: %32
occurred
.: %32
Users: %32
don
'
t: %32
need: %32
to: %32
know: %32
the: %32
details
,: %32
because: %32
the: %13
definitions: %32
obtained: %32
from: %32
<
stdio
.
h
>: %32
include: %32
a: %32
structure: %32
declaration: %32
called: %32
FILE
.: %32
The: %32
only: %32
declaration: %13
needed: %32
for: %32
a: %32
file: %32
pointer: %32
is: %32
exemplified: %32
by: %13
FILE: %32
*
fp
;: %13
FILE: %32
*
fopen
(
char: %32
*
name
,: %32
char: %32
*
mode
)
;: %13
This: %32
says: %32
that: %32
fp: %32
is: %32
a: %32
pointer: %32
to: %32
a: %32
FILE
,: %32
and: %32
fopen: %32
returns: %32
a: %32
pointer: %32
to: %32
a: %32
FILE
.: %32
Notice: %32
that: %32
FILE: %32
is: %32
a: %13
type: %32
name
,: %32
like: %32
int
,: %32
not: %32
a: %32
structure: %32
tag
;: %32
it: %32
is: %32
defined: %32
with: %32
a: %32
typedef
.: %32
(
Details: %32
of: %32
how: %32
fopen: %32
can: %32
be: %13
implemented: %32
on: %32
the: %32
UNIX: %32
system: %32
are: %32
given: %32
in: %32
Section: %32
8
.
5
.
): %13
The: %32
call: %32
to: %32
fopen: %32
in: %32
a: %32
program: %32
is: %13
fp: %32
=: %32
fopen
(
name
,: %32
mode
)
;: %13
The: %32
first: %32
argument: %32
of: %32
fopen: %32
is: %32
a: %32
character: %32
string: %32
containing: %32
the: %32
name: %32
of: %32
the: %32
file
.: %32
The: %32
second: %32
argument: %13
is: %32
the: %32
mode
,: %32
also: %32
a: %32
character: %32
string
,: %32
which: %32
indicates: %32
how: %32
one: %32
intends: %32
to: %32
use: %32
the: %32
file
.: %32
Allowable: %32
modes: %13
include: %32
read: %32
(
"
r
"
)
,: %32
write: %32
(
"
w
"
)
,: %32
and: %32
append: %32
(
"
a
"
)
.: %32
Some: %32
systems: %32
distinguish: %32
between: %32
text: %32
and: %32
binary: %13
files
;: %32
for: %32
the: %32
latter
,: %32
a: %32
"
b
": %32
must: %32
be: %32
appended: %32
to: %32
the: %32
mode: %32
string
.: %13
If: %32
a: %32
file: %32
that: %32
does: %32
not: %32
exist: %32
is: %32
opened: %32
for: %32
writing: %32
or: %32
appending
,: %32
it: %32
is: %32
created: %32
if: %32
possible
.: %32
Opening: %32
an: %13
existing: %32
file: %32
for: %32
writing: %32
causes: %32
the: %32
old: %32
contents: %32
to: %32
be: %32
discarded
,: %32
while: %32
opening: %32
for: %32
appending: %32
preserves: %13
Chapter: %32
7: %32
-: %32
Input: %32
and: %32
Output: %13
them
.: %32
Trying: %32
to: %32
read: %32
a: %32
file: %32
that: %32
does: %32
not: %32
exist: %32
is: %32
an: %32
error
,: %32
and: %32
there: %32
may: %32
be: %32
other: %32
causes: %32
of: %32
error: %32
as: %32
well
,: %13
like: %32
trying: %32
to: %32
read: %32
a: %32
file: %32
when: %32
you: %32
don
'
t: %32
have: %32
permission
.: %32
If: %32
there: %32
is: %32
any: %32
error
,: %32
fopen: %32
will: %32
return: %32
NULL
.: %13
(
The: %32
error: %32
can: %32
be: %32
identified: %32
more: %32
precisely
;: %32
see: %32
the: %32
discussion: %32
of: %32
error
-
handling: %32
functions: %32
at: %32
the: %32
end: %32
of: %13
Section: %32
1: %32
in: %32
Appendix: %32
B
.
): %13
The: %32
next: %32
thing: %32
needed: %32
is: %32
a: %32
way: %32
to: %32
read: %32
or: %32
write: %32
the: %32
file: %32
once: %32
it: %32
is: %32
open
.: %32
getc: %32
returns: %32
the: %32
next: %32
character: %13
from: %32
a: %32
file
;: %32
it: %32
needs: %32
the: %32
file: %32
pointer: %32
to: %32
tell: %32
it: %32
which: %32
file
.: %13
int: %32
getc
(
FILE: %32
*
fp
): %13
getc: %32
returns: %32
the: %32
next: %32
character: %32
from: %32
the: %32
stream: %32
referred: %32
to: %32
by: %32
fp
;: %32
it: %32
returns: %32
EOF: %32
for: %32
end: %32
of: %32
file: %32
or: %32
error
.: %13
putc: %32
is: %32
an: %32
output: %32
function
:: %13
int: %32
putc
(
int: %32
c
,: %32
FILE: %32
*
fp
): %13
putc: %32
writes: %32
the: %32
character: %32
c: %32
to: %32
the: %32
file: %32
fp: %32
and: %32
returns: %32
the: %32
character: %32
written
,: %32
or: %32
EOF: %32
if: %32
an: %32
error: %32
occurs
.: %13
Like: %32
getchar: %32
and: %32
putchar
,: %32
getc: %32
and: %32
putc: %32
may: %32
be: %32
macros: %32
instead: %32
of: %32
functions
.: %13
When: %32
a: %32
C: %32
program: %32
is: %32
started
,: %32
the: %32
operating: %32
system: %32
environment: %32
is: %32
responsible: %32
for: %32
opening: %32
three: %32
files: %32
and: %13
providing: %32
pointers: %32
for: %32
them
.: %32
These: %32
files: %32
are: %32
the: %32
standard: %32
input
,: %32
the: %32
standard: %32
output
,: %32
and: %32
the: %32
standard: %13
error
;: %32
the: %32
corresponding: %32
file: %32
pointers: %32
are: %32
called: %32
stdin
,: %32
stdout
,: %32
and: %32
stderr
,: %32
and: %32
are: %32
declared: %32
in: %13
<
stdio
.
h
>
.: %32
Normally: %32
stdin: %32
is: %32
connected: %32
to: %32
the: %32
keyboard: %32
and: %32
stdout: %32
and: %32
stderr: %32
are: %32
connected: %13
to: %32
the: %32
screen
,: %32
but: %32
stdin: %32
and: %32
stdout: %32
may: %32
be: %32
redirected: %32
to: %32
files: %32
or: %32
pipes: %32
as: %32
described: %32
in: %32
Section: %32
7
.
1
.: %13
getchar: %32
and: %32
putchar: %32
can: %32
be: %32
defined: %32
in: %32
terms: %32
of: %32
getc
,: %32
putc
,: %32
stdin
,: %32
and: %32
stdout: %32
as: %32
follows
:: %13
#
define: %32
getchar
(
): %13
#
define: %32
putchar
(
c
): %13
getc
(
stdin
): %13
putc
(
(
c
)
,: %32
stdout
): %13
For: %32
formatted: %32
input: %32
or: %32
output: %32
of: %32
files
,: %32
the: %32
functions: %32
fscanf: %32
and: %32
fprintf: %32
may: %32
be: %32
used
.: %32
These: %32
are: %13
identical: %32
to: %32
scanf: %32
and: %32
printf
,: %32
except: %32
that: %32
the: %32
first: %32
argument: %32
is: %32
a: %32
file: %32
pointer: %32
that: %32
specifies: %32
the: %32
file: %32
to: %13
be: %32
read: %32
or: %32
written
;: %32
the: %32
format: %32
string: %32
is: %32
the: %32
second: %32
argument
.: %13
int: %32
fscanf
(
FILE: %32
*
fp
,: %32
char: %32
*
format
,: %32
.
.
.
): %13
int: %32
fprintf
(
FILE: %32
*
fp
,: %32
char: %32
*
format
,: %32
.
.
.
): %13
With: %32
these: %32
preliminaries: %32
out: %32
of: %32
the: %32
way
,: %32
we: %32
are: %32
now: %32
in: %32
a: %32
position: %32
to: %32
write: %32
the: %32
program: %32
cat: %32
to: %13
concatenate: %32
files
.: %32
The: %32
design: %32
is: %32
one: %32
that: %32
has: %32
been: %32
found: %32
convenient: %32
for: %32
many: %32
programs
.: %32
If: %32
there: %32
are: %13
command
-
line: %32
arguments
,: %32
they: %32
are: %32
interpreted: %32
as: %32
filenames
,: %32
and: %32
processed: %32
in: %32
order
.: %32
If: %32
there: %32
are: %32
no: %13
arguments
,: %32
the: %32
standard: %32
input: %32
is: %32
processed
.: %13
Chapter: %32
7: %32
-: %32
Input: %32
and: %32
Output: %13
#
include: %32
<
stdio
.
h
>: %13
/
*: %32
cat
:: %13
main
(
int: %13
{: %13
FILE: %13
void: %13
concatenate: %32
files
,: %32
version: %32
1: %32
*
/: %13
argc
,: %32
char: %32
*
argv
[
]
): %13
*
fp
;: %13
filecopy
(
FILE: %32
*
,: %32
FILE: %32
*
): %13
if: %32
(
argc: %32
=
=: %32
1
): %32
/
*: %32
no: %32
args
;: %32
copy: %32
standard: %32
input: %32
*
/: %13
filecopy
(
stdin
,: %32
stdout
)
;: %13
else: %13
while
(
-
-
argc: %32
>: %32
0
): %13
if: %32
(
(
fp: %32
=: %32
fopen
(
*
+
+
argv
,: %32
"
r
"
)
): %32
=
=: %32
NULL
): %32
{: %13
printf
(
"
cat
:: %32
can
'
t: %32
open: %32
%:
s
\
n
,: %32
*
argv
)
;: %13
return: %32
1
;: %13
}: %32
else: %32
{: %13
filecopy
(
fp
,: %32
stdout
)
;: %13
fclose
(
fp
)
;: %13
}: %13
return: %32
0
;: %13
}: %13
/
*: %32
filecopy
:: %32
copy: %32
file: %32
ifp: %32
to: %32
file: %32
ofp: %32
*
/: %13
void: %32
filecopy
(
FILE: %32
*
ifp
,: %32
FILE: %32
*
ofp
): %13
{: %13
int: %32
c
;: %13
while: %32
(
(
c: %32
=: %32
getc
(
ifp
)
): %32
!
=: %32
EOF
): %13
putc
(
c
,: %32
ofp
)
;: %13
}: %13
The: %32
file: %32
pointers: %32
stdin: %32
and: %32
stdout: %32
are: %32
objects: %32
of: %32
type: %32
FILE: %32
*
.: %32
They: %32
are: %32
constants
,: %32
however
,: %32
not: %13
variables
,: %32
so: %32
it: %32
is: %32
not: %32
possible: %32
to: %32
assign: %32
to: %32
them
.: %13
The: %32
function: %13
int: %32
fclose
(
FILE: %32
*
fp
): %13
is: %32
the: %32
inverse: %32
of: %32
fopen
,: %32
it: %32
breaks: %32
the: %32
connection: %32
between: %32
the: %32
file: %32
pointer: %32
and: %32
the: %32
external: %32
name: %32
that: %32
was: %13
established: %32
by: %32
fopen
,: %32
freeing: %32
the: %32
file: %32
pointer: %32
for: %32
another: %32
file
.: %32
Since: %32
most: %32
operating: %32
systems: %32
have: %32
some: %13
limit: %32
on: %32
the: %32
number: %32
of: %32
files: %32
that: %32
a: %32
program: %32
may: %32
have: %32
open: %32
simultaneously
,: %32
it
'
s: %32
a: %32
good: %32
idea: %32
to: %32
free: %32
the: %32
file: %13
pointers: %32
when: %32
they: %32
are: %32
no: %32
longer: %32
needed
,: %32
as: %32
we: %32
did: %32
in: %32
cat
.: %32
There: %32
is: %32
also: %32
another: %32
reason: %32
for: %32
fclose: %32
on: %13
an: %32
output: %32
file: %32
-: %32
it: %32
flushes: %32
the: %32
buffer: %32
in: %32
which: %32
putc: %32
is: %32
collecting: %32
output
.: %32
fclose: %32
is: %32
called: %32
automatically: %13
Chapter: %32
7: %32
-: %32
Input: %32
and: %32
Output: %13
for: %32
each: %32
open: %32
file: %32
when: %32
a: %32
program: %32
terminates: %32
normally
.: %32
(
You: %32
can: %32
close: %32
stdin: %32
and: %32
stdout: %32
if: %32
they: %32
are: %13
not: %32
needed
.: %32
They: %32
can: %32
also: %32
be: %32
reassigned: %32
by: %32
the: %32
library: %32
function: %32
freopen
.
): %13
7
.
6: %32
Error: %32
Handling: %32
-: %32
Stderr: %32
and: %32
Exit: %13
The: %32
treatment: %32
of: %32
errors: %32
in: %32
cat: %32
is: %32
not: %32
ideal
.: %32
The: %32
trouble: %32
is: %32
that: %32
if: %32
one: %32
of: %32
the: %32
files: %32
can
'
t: %32
be: %32
accessed: %32
for: %13
some: %32
reason
,: %32
the: %32
diagnostic: %32
is: %32
printed: %32
at: %32
the: %32
end: %32
of: %32
the: %32
concatenated: %32
output
.: %32
That: %32
might: %32
be: %32
acceptable: %32
if: %13
the: %32
output: %32
is: %32
going: %32
to: %32
a: %32
screen
,: %32
but: %32
not: %32
if: %32
it
'
s: %32
going: %32
into: %32
a: %32
file: %32
or: %32
into: %32
another: %32
program: %32
via: %32
a: %32
pipeline
.: %13
To: %32
handle: %32
this: %32
situation: %32
better
,: %32
a: %32
second: %32
output: %32
stream
,: %32
called: %32
stderr
,: %32
is: %32
assigned: %32
to: %32
a: %32
program: %32
in: %32
the: %13
same: %32
way: %32
that: %32
stdin: %32
and: %32
stdout: %32
are
.: %32
Output: %32
written: %32
on: %32
stderr: %32
normally: %32
appears: %32
on: %32
the: %32
screen: %32
even: %13
if: %32
the: %32
standard: %32
output: %32
is: %32
redirected
.: %13
Let: %32
us: %32
revise: %32
cat: %32
to: %32
write: %32
its: %32
error: %32
messages: %32
on: %32
the: %32
standard: %32
error
.: %13
#
include: %32
<
stdio
.
h
>: %13
/
*: %32
cat
:: %13
main
(
int: %13
{: %13
FILE: %13
void: %13
char: %13
concatenate: %32
files
,: %32
version: %32
2: %32
*
/: %13
argc
,: %32
char: %32
*
argv
[
]
): %13
*
fp
;: %13
filecopy
(
FILE: %32
*
,: %32
FILE: %32
*
)
;: %13
*
prog: %32
=: %32
argv
[
0
]
;: %32
/
*: %32
program: %32
name: %32
for: %32
errors: %32
*
/: %13
if: %32
(
argc: %32
=
=: %32
1: %32
): %32
/
*: %32
no: %32
args
;: %32
copy: %32
standard: %32
input: %32
*
/: %13
filecopy
(
stdin
,: %32
stdout
)
;: %13
else: %13
while: %32
(
-
-
argc: %32
>: %32
0
): %13
if: %32
(
(
fp: %32
=: %32
fopen
(
*
+
+
argv
,: %32
"
r
"
)
): %32
=
=: %32
NULL
): %32
{: %13
fprintf
(
stderr
,: %32
"
%:
s
:: %32
can
'
t: %32
open: %32
%:
s
\
n
"
,: %13
prog
,: %32
*
argv
)
;: %13
exit
(
1
)
;: %13
}: %32
else: %32
{: %13
filecopy
(
fp
,: %32
stdout
)
;: %13
fclose
(
fp
)
;: %13
}: %13
if: %32
(
ferror
(
stdout
)
): %32
{: %13
fprintf
(
stderr
,: %32
"
%:
s
:: %32
error: %32
writing: %32
stdout
\
n
"
,: %32
prog
)
;: %13
exit
(
2
)
;: %13
}: %13
exit
(
0
)
;: %13
}: %13
Chapter: %32
7: %32
-: %32
Input: %32
and: %32
Output: %13
The: %32
program: %32
signals: %32
errors: %32
in: %32
two: %32
ways
.: %32
First
,: %32
the: %32
diagnostic: %32
output: %32
produced: %32
by: %32
fprintf: %32
goes: %32
to: %13
stderr
,: %32
so: %32
it: %32
finds: %32
its: %32
way: %32
to: %32
the: %32
screen: %32
instead: %32
of: %32
disappearing: %32
down: %32
a: %32
pipeline: %32
or: %32
into: %32
an: %32
output: %32
file
.: %13
We: %32
included: %32
the: %32
program: %32
name
,: %32
from: %32
argv
[
0
]
,: %32
in: %32
the: %32
message
,: %32
so: %32
if: %32
this: %32
program: %32
is: %32
used: %32
with: %32
others
,: %13
the: %32
source: %32
of: %32
an: %32
error: %32
is: %32
identified
.: %13
Second
,: %32
the: %32
program: %32
uses: %32
the: %32
standard: %32
library: %32
function: %32
exit
,: %32
which: %32
terminates: %32
program: %32
execution: %32
when: %13
it: %32
is: %32
called
.: %32
The: %32
argument: %32
of: %32
exit: %32
is: %32
available: %32
to: %32
whatever: %32
process: %32
called: %32
this: %32
one
,: %32
so: %32
the: %32
success: %32
or: %13
failure: %32
of: %32
the: %32
program: %32
can: %32
be: %32
tested: %32
by: %32
another: %32
program: %32
that: %32
uses: %32
this: %32
one: %32
as: %32
a: %32
sub
-
process
.: %13
Conventionally
,: %32
a: %32
return: %32
value: %32
of: %32
0: %32
signals: %32
that: %32
all: %32
is: %32
well
;: %32
non
-
zero: %32
values: %32
usually: %32
signal: %32
abnormal: %13
situations
.: %32
exit: %32
calls: %32
fclose: %32
for: %32
each: %32
open: %32
output: %32
file
,: %32
to: %32
flush: %32
out: %32
any: %32
buffered: %32
output
.: %13
Within: %32
main
,: %32
return: %32
expr: %32
is: %32
equivalent: %32
to: %32
exit
(
expr
)
.: %32
exit: %32
has: %32
the: %32
advantage: %32
that: %32
it: %32
can: %32
be: %32
called: %13
from: %32
other: %32
functions
,: %32
and: %32
that: %32
calls: %32
to: %32
it: %32
can: %32
be: %32
found: %32
with: %32
a: %32
pattern
-
searching: %32
program: %32
like: %32
those: %32
in: %13
Chapter: %32
5
.: %13
The: %32
function: %32
ferror: %32
returns: %32
non
-
zero: %32
if: %32
an: %32
error: %32
occurred: %32
on: %32
the: %32
stream: %32
fp
.: %13
int: %32
ferror
(
FILE: %32
*
fp
): %13
Although: %32
output: %32
errors: %32
are: %32
rare
,: %32
they: %32
do: %32
occur: %32
(
for: %32
example
,: %32
if: %32
a: %32
disk: %32
fills: %32
up
)
,: %32
so: %32
a: %32
production: %32
program: %13
should: %32
check: %32
this: %32
as: %32
well
.: %13
The: %32
function: %32
feof
(
FILE: %32
*
): %32
is: %32
analogous: %32
to: %32
ferror
;: %32
it: %32
returns: %32
non
-
zero: %32
if: %32
end: %32
of: %32
file: %32
has: %32
occurred: %13
on: %32
the: %32
specified: %32
file
.: %13
int: %32
feof
(
FILE: %32
*
fp
): %13
We: %32
have: %32
generally: %32
not: %32
worried: %32
about: %32
exit: %32
status: %32
in: %32
our: %32
small: %32
illustrative: %32
programs
,: %32
but: %32
any: %32
serious: %13
program: %32
should: %32
take: %32
care: %32
to: %32
return: %32
sensible
,: %32
useful: %32
status: %32
values
.: %13
7
.
7: %32
Line: %32
Input: %32
and: %32
Output: %13
The: %32
standard: %32
library: %32
provides: %32
an: %32
input: %32
and: %32
output: %32
routine: %32
fgets: %32
that: %32
is: %32
similar: %32
to: %32
the: %32
getline: %13
function: %32
that: %32
we: %32
have: %32
used: %32
in: %32
earlier: %32
chapters
:: %13
char: %32
*
fgets
(
char: %32
*
line
,: %32
int: %32
maxline
,: %32
FILE: %32
*
fp
): %13
fgets: %32
reads: %32
the: %32
next: %32
input: %32
line: %32
(
including: %32
the: %32
newline
): %32
from: %32
file: %32
fp: %32
into: %32
the: %32
character: %32
array: %32
line
;: %32
at: %13
most: %32
maxline
-
1: %32
characters: %32
will: %32
be: %32
read
.: %32
The: %32
resulting: %32
line: %32
is: %32
terminated: %32
with: %32
'
\
0
'
.: %32
Normally: %32
fgets: %13
returns: %32
line
;: %32
on: %32
end: %32
of: %32
file: %32
or: %32
error: %32
it: %32
returns: %32
NULL
.: %32
(
Our: %32
getline: %32
returns: %32
the: %32
line: %32
length
,: %32
which: %32
is: %32
a: %13
Chapter: %32
7: %32
-: %32
Input: %32
and: %32
Output: %13
more: %32
useful: %32
value
;: %32
zero: %32
means: %32
end: %32
of: %32
file
.
): %13
For: %32
output
,: %32
the: %32
function: %32
fputs: %32
writes: %32
a: %32
string: %32
(
which: %32
need: %32
not: %32
contain: %32
a: %32
newline
): %32
to: %32
a: %32
file
:: %13
int: %32
fputs
(
char: %32
*
line
,: %32
FILE: %32
*
fp
): %13
It: %32
returns: %32
EOF: %32
if: %32
an: %32
error: %32
occurs
,: %32
and: %32
non
-
negative: %32
otherwise
.: %13
The: %32
library: %32
functions: %32
gets: %32
and: %32
puts: %32
are: %32
similar: %32
to: %32
fgets: %32
and: %32
fputs
,: %32
but: %32
operate: %32
on: %32
stdin: %32
and: %13
stdout
.: %32
Confusingly
,: %32
gets: %32
deletes: %32
the: %32
terminating: %32
'
\
n
'
,: %32
and: %32
puts: %32
adds: %32
it
.: %13
To: %32
show: %32
that: %32
there: %32
is: %32
nothing: %32
special: %32
about: %32
functions: %32
like: %32
fgets: %32
and: %32
fputs
,: %32
here: %32
they: %32
are
,: %32
copied: %32
from: %13
the: %32
standard: %32
library: %32
on: %32
our: %32
system
:: %13
/
*: %32
fgets
:: %32
get: %32
at: %32
most: %32
n: %32
chars: %32
from: %32
iop: %32
*
/: %13
char: %32
*
fgets
(
char: %32
*
s
,: %32
int: %32
n
,: %32
FILE: %32
*
iop
): %13
{: %13
register: %32
int: %32
c
;: %13
register: %32
char: %32
*
cs
;: %13
cs: %32
=: %32
s
;: %13
while: %32
(
-
-
n: %32
>: %32
0: %32
&
&: %32
(
c: %32
=: %32
getc
(
iop
)
): %32
!
=: %32
EOF
): %13
if: %32
(
(
*
cs
+
+: %32
=: %32
c
): %32
=
=: %32
'
\
n
'
): %13
break
;: %13
*
cs: %32
=: %32
'
\
0
'
;: %13
return: %32
(
c: %32
=
=: %32
EOF: %32
&
&: %32
cs: %32
=
=: %32
s
): %32
?: %32
NULL: %32
:: %32
s
;: %13
}: %13
/
*: %32
fputs
:: %32
put: %32
string: %32
s: %32
on: %32
file: %32
iop: %32
*
/: %13
int: %32
fputs
(
char: %32
*
s
,: %32
FILE: %32
*
iop
): %13
{: %13
int: %32
c
;: %13
while: %32
(
c: %32
=: %32
*
s
+
+
): %13
putc
(
c
,: %32
iop
)
;: %13
return: %32
ferror
(
iop
): %32
?: %32
EOF: %32
:: %32
0
;: %13
}: %13
For: %32
no: %32
obvious: %32
reason
,: %32
the: %32
standard: %32
specifies: %32
different: %32
return: %32
values: %32
for: %32
ferror: %32
and: %32
fputs
.: %13
It: %32
is: %32
easy: %32
to: %32
implement: %32
our: %32
getline: %32
from: %32
fgets
:: %13
Chapter: %32
7: %32
-: %32
Input: %32
and: %32
Output: %13
/
*: %32
getline
:: %32
read: %32
a: %32
line
,: %32
return: %32
length: %32
*
/: %13
int: %32
getline
(
char: %32
*
line
,: %32
int: %32
max
): %13
{: %13
if: %32
(
fgets
(
line
,: %32
max
,: %32
stdin
): %32
=
=: %32
NULL
): %13
return: %32
0
;: %13
else: %13
return: %32
strlen
(
line
)
;: %13
}: %13
Exercise: %32
7
-
6
.: %32
Write: %32
a: %32
program: %32
to: %32
compare: %32
two: %32
files
,: %32
printing: %32
the: %32
first: %32
line: %32
where: %32
they: %32
differ
.: %13
Exercise: %32
7
-
7
.: %32
Modify: %32
the: %32
pattern: %32
finding: %32
program: %32
of: %32
Chapter: %32
5: %32
to: %32
take: %32
its: %32
input: %32
from: %32
a: %32
set: %32
of: %32
named: %32
files: %13
or
,: %32
if: %32
no: %32
files: %32
are: %32
named: %32
as: %32
arguments
,: %32
from: %32
the: %32
standard: %32
input
.: %32
Should: %32
the: %32
file: %32
name: %32
be: %32
printed: %32
when: %32
a: %13
matching: %32
line: %32
is: %32
found
?: %13
Exercise: %32
7
-
8
.: %32
Write: %32
a: %32
program: %32
to: %32
print: %32
a: %32
set: %32
of: %32
files
,: %32
starting: %32
each: %32
new: %32
one: %32
on: %32
a: %32
new: %32
page
,: %32
with: %32
a: %32
title: %32
and: %13
a: %32
running: %32
page: %32
count: %32
for: %32
each: %32
file
.: %13
7
.
8: %32
Miscellaneous: %32
Functions: %13
The: %32
standard: %32
library: %32
provides: %32
a: %32
wide: %32
variety: %32
of: %32
functions
.: %32
This: %32
section: %32
is: %32
a: %32
brief: %32
synopsis: %32
of: %32
the: %32
most: %13
useful
.: %32
More: %32
details: %32
and: %32
many: %32
other: %32
functions: %32
can: %32
be: %32
found: %32
in: %32
Appendix: %32
B
.: %13
7
.
8
.
1: %32
String: %32
Operations: %13
We: %32
have: %32
already: %32
mentioned: %32
the: %32
string: %32
functions: %32
strlen
,: %32
strcpy
,: %32
strcat
,: %32
and: %32
strcmp
,: %32
found: %32
in: %13
<
string
.
h
>
.: %32
In: %32
the: %32
following
,: %32
s: %32
and: %32
t: %32
are: %32
char: %32
*
'
s
,: %32
and: %32
c: %32
and: %32
n: %32
are: %32
ints
.: %13
strcat
(
s
,
t
): %13
concatenate: %32
t: %32
to: %32
end: %32
of: %32
s: %13
strncat
(
s
,
t
,
n
): %32
concatenate: %32
n: %32
characters: %32
of: %32
t: %32
to: %32
end: %32
of: %32
s: %13
strcmp
(
s
,
t
): %13
return: %32
negative
,: %32
zero
,: %32
or: %32
positive: %32
for: %32
s: %32
<: %32
t
,: %32
s: %32
=
=: %32
t
,: %32
s: %32
>: %32
t: %13
strncmp
(
s
,
t
,
n
): %32
same: %32
as: %32
strcmp: %32
but: %32
only: %32
in: %32
first: %32
n: %32
characters: %13
strcpy
(
s
,
t
): %13
copy: %32
t: %32
to: %32
s: %13
strncpy
(
s
,
t
,
n
): %32
copy: %32
at: %32
most: %32
n: %32
characters: %32
of: %32
t: %32
to: %32
s: %13
strlen
(
s
): %13
return: %32
length: %32
of: %32
s: %13
strchr
(
s
,
c
): %13
return: %32
pointer: %32
to: %32
first: %32
c: %32
in: %32
s
,: %32
or: %32
NULL: %32
if: %32
not: %32
present: %13
strrchr
(
s
,
c
): %32
return: %32
pointer: %32
to: %32
last: %32
c: %32
in: %32
s
,: %32
or: %32
NULL: %32
if: %32
not: %32
present: %13
Chapter: %32
7: %32
-: %32
Input: %32
and: %32
Output: %13
7
.
8
.
2: %32
Character: %32
Class: %32
Testing: %32
and: %32
Conversion: %13
Several: %32
functions: %32
from: %32
<
ctype
.
h
>: %32
perform: %32
character: %32
tests: %32
and: %32
conversions
.: %32
In: %32
the: %32
following
,: %32
c: %32
is: %32
an: %13
int: %32
that: %32
can: %32
be: %32
represented: %32
as: %32
an: %32
unsigned: %32
char: %32
or: %32
EOF
.: %32
The: %32
function: %32
returns: %32
int
.: %13
isalpha
(
c
): %32
non
-
zero: %32
if: %32
c: %32
is: %32
alphabetic
,: %32
0: %32
if: %32
not: %13
isupper
(
c
): %32
non
-
zero: %32
if: %32
c: %32
is: %32
upper: %32
case
,: %32
0: %32
if: %32
not: %13
islower
(
c
): %32
non
-
zero: %32
if: %32
c: %32
is: %32
lower: %32
case
,: %32
0: %32
if: %32
not: %13
isdigit
(
c
): %32
non
-
zero: %32
if: %32
c: %32
is: %32
digit
,: %32
0: %32
if: %32
not: %13
isalnum
(
c
): %32
non
-
zero: %32
if: %32
isalpha
(
c
): %32
or: %32
isdigit
(
c
)
,: %32
0: %32
if: %32
not: %13
isspace
(
c
): %32
non
-
zero: %32
if: %32
c: %32
is: %32
blank
,: %32
tab
,: %32
newline
,: %32
return
,: %32
formfeed
,: %32
vertical: %32
tab: %13
toupper
(
c
): %32
return: %32
c: %32
converted: %32
to: %32
upper: %32
case: %13
tolower
(
c
): %32
return: %32
c: %32
converted: %32
to: %32
lower: %32
case: %13
7
.
8
.
3: %32
Ungetc: %13
The: %32
standard: %32
library: %32
provides: %32
a: %32
rather: %32
restricted: %32
version: %32
of: %32
the: %32
function: %32
ungetch: %32
that: %32
we: %32
wrote: %32
in: %13
Chapter: %32
4
;: %32
it: %32
is: %32
called: %32
ungetc
.: %13
int: %32
ungetc
(
int: %32
c
,: %32
FILE: %32
*
fp
): %13
pushes: %32
the: %32
character: %32
c: %32
back: %32
onto: %32
file: %32
fp
,: %32
and: %32
returns: %32
either: %32
c
,: %32
or: %32
EOF: %32
for: %32
an: %32
error
.: %32
Only: %32
one: %32
character: %32
of: %13
pushback: %32
is: %32
guaranteed: %32
per: %32
file
.: %32
ungetc: %32
may: %32
be: %32
used: %32
with: %32
any: %32
of: %32
the: %32
input: %32
functions: %32
like: %32
scanf
,: %13
getc
,: %32
or: %32
getchar
.: %13
7
.
8
.
4: %32
Command: %32
Execution: %13
The: %32
function: %32
system
(
char: %32
*
s
): %32
executes: %32
the: %32
command: %32
contained: %32
in: %32
the: %32
character: %32
string: %32
s
,: %32
then: %13
resumes: %32
execution: %32
of: %32
the: %32
current: %32
program
.: %32
The: %32
contents: %32
of: %32
s: %32
depend: %32
strongly: %32
on: %32
the: %32
local: %32
operating: %13
system
.: %32
As: %32
a: %32
trivial: %32
example
,: %32
on: %32
UNIX: %32
systems
,: %32
the: %32
statement: %13
system
(
"
date
"
)
;: %13
causes: %32
the: %32
program: %32
date: %32
to: %32
be: %32
run
;: %32
it: %32
prints: %32
the: %32
date: %32
and: %32
time: %32
of: %32
day: %32
on: %32
the: %32
standard: %32
output
.: %32
system: %13
returns: %32
a: %32
system
-
dependent: %32
integer: %32
status: %32
from: %32
the: %32
command: %32
executed
.: %32
In: %32
the: %32
UNIX: %32
system
,: %32
the: %32
status: %13
return: %32
is: %32
the: %32
value: %32
returned: %32
by: %32
exit
.: %13
7
.
8
.
5: %32
Storage: %32
Management: %13
Chapter: %32
7: %32
-: %32
Input: %32
and: %32
Output: %13
The: %32
functions: %32
malloc: %32
and: %32
calloc: %32
obtain: %32
blocks: %32
of: %32
memory: %32
dynamically
.: %13
void: %32
*
malloc
(
size
_
t: %32
n
): %13
returns: %32
a: %32
pointer: %32
to: %32
n: %32
bytes: %32
of: %32
uninitialized: %32
storage
,: %32
or: %32
NULL: %32
if: %32
the: %32
request: %32
cannot: %32
be: %32
satisfied
.: %13
void: %32
*
calloc
(
size
_
t: %32
n
,: %32
size
_
t: %32
size
): %13
returns: %32
a: %32
pointer: %32
to: %32
enough: %32
free: %32
space: %32
for: %32
an: %32
array: %32
of: %32
n: %32
objects: %32
of: %32
the: %32
specified: %32
size
,: %32
or: %32
NULL: %32
if: %32
the: %13
request: %32
cannot: %32
be: %32
satisfied
.: %32
The: %32
storage: %32
is: %32
initialized: %32
to: %32
zero
.: %13
The: %32
pointer: %32
returned: %32
by: %32
malloc: %32
or: %32
calloc: %32
has: %32
the: %32
proper: %32
alignment: %32
for: %32
the: %32
object: %32
in: %32
question
,: %32
but: %32
it: %13
must: %32
be: %32
cast: %32
into: %32
the: %32
appropriate: %32
type
,: %32
as: %32
in: %13
int: %32
*
ip
;: %13
ip: %32
=: %32
(
int: %32
*
): %32
calloc
(
n
,: %32
sizeof
(
int
)
)
;: %13
free
(
p
): %32
frees: %32
the: %32
space: %32
pointed: %32
to: %32
by: %32
p
,: %32
where: %32
p: %32
was: %32
originally: %32
obtained: %32
by: %32
a: %32
call: %32
to: %32
malloc: %32
or: %13
calloc
.: %32
There: %32
are: %32
no: %32
restrictions: %32
on: %32
the: %32
order: %32
in: %32
which: %32
space: %32
is: %32
freed
,: %32
but: %32
it: %32
is: %32
a: %32
ghastly: %32
error: %32
to: %32
free: %13
something: %32
not: %32
obtained: %32
by: %32
calling: %32
malloc: %32
or: %32
calloc
.: %13
It: %32
is: %32
also: %32
an: %32
error: %32
to: %32
use: %32
something: %32
after: %32
it: %32
has: %32
been: %32
freed
.: %32
A: %32
typical: %32
but: %32
incorrect: %32
piece: %32
of: %32
code: %32
is: %32
this: %13
loop: %32
that: %32
frees: %32
items: %32
from: %32
a: %32
list
:: %13
for: %32
(
p: %32
=: %32
head
;: %32
p: %32
!
=: %32
NULL
;: %32
p: %32
=: %32
p
-
>
next
): %32
/
*: %32
WRONG: %32
*
/: %13
free
(
p
)
;: %13
The: %32
right: %32
way: %32
is: %32
to: %32
save: %32
whatever: %32
is: %32
needed: %32
before: %32
freeing
:: %13
for: %32
(
p: %32
=: %32
head
;: %32
p: %32
!
=: %32
NULL
;: %32
p: %32
=: %32
q
): %32
{: %13
q: %32
=: %32
p
-
>
next
;: %13
free
(
p
)
;: %13
}: %13
Section: %32
8
.
7: %32
shows: %32
the: %32
implementation: %32
of: %32
a: %32
storage: %32
allocator: %32
like: %32
malloc
,: %32
in: %32
which: %32
allocated: %32
blocks: %32
may: %13
be: %32
freed: %32
in: %32
any: %32
order
.: %13
7
.
8
.
6: %32
Mathematical: %32
Functions: %13
There: %32
are: %32
more: %32
than: %32
twenty: %32
mathematical: %32
functions: %32
declared: %32
in: %32
<
math
.
h
>
;: %32
here: %32
are: %32
some: %32
of: %32
the: %32
more: %13
Chapter: %32
7: %32
-: %32
Input: %32
and: %32
Output: %13
frequently: %32
used
.: %32
Each: %32
takes: %32
one: %32
or: %32
two: %32
double: %32
arguments: %32
and: %32
returns: %32
a: %32
double
.: %13
sine: %32
of: %32
x
,: %32
x: %32
in: %32
radians: %13
sin
(
x
): %13
cosine: %32
of: %32
x
,: %32
x: %32
in: %32
radians: %13
cos
(
x
): %13
atan
2
(
y
,
x
): %32
arctangent: %32
of: %32
y
/
x
,: %32
in: %32
radians: %13
exp
(
x
): %13
log
(
x
): %13
log
1
0
(
x
): %13
pow
(
x
,
y
): %13
sqrt
(
x
): %13
fabs
(
x
): %13
exponential: %32
function: %32
ex: %13
natural: %32
(
base: %32
e
): %32
logarithm: %32
of: %32
x: %32
(
x
>
0
): %13
common: %32
(
base: %32
1
0
): %32
logarithm: %32
of: %32
x: %32
(
x
>
0
): %13
xy: %13
square: %32
root: %32
of: %32
x: %32
(
x
>
0
): %13
absolute: %32
value: %32
of: %32
x: %13
7
.
8
.
7: %32
Random: %32
Number: %32
generation: %13
The: %32
function: %32
rand
(
): %32
computes: %32
a: %32
sequence: %32
of: %32
pseudo
-
random: %32
integers: %32
in: %32
the: %32
range: %32
zero: %32
to: %32
RAND
_
MAX
,: %13
which: %32
is: %32
defined: %32
in: %32
<
stdlib
.
h
>
.: %32
One: %32
way: %32
to: %32
produce: %32
random: %32
floating
-
point: %32
numbers: %32
greater: %32
than: %32
or: %13
equal: %32
to: %32
zero: %32
but: %32
less: %32
than: %32
one: %32
is: %13
#
define: %32
frand
(
): %32
(
(
double
): %32
rand
(
): %32
/: %32
(
RAND
_
MAX
+
1
.
0
)
): %13
(
If: %32
your: %32
library: %32
already: %32
provides: %32
a: %32
function: %32
for: %32
floating
-
point: %32
random: %32
numbers
,: %32
it: %32
is: %32
likely: %32
to: %32
have: %32
better: %13
statistical: %32
properties: %32
than: %32
this: %32
one
.
): %13
The: %32
function: %32
srand
(
unsigned
): %32
sets: %32
the: %32
seed: %32
for: %32
rand
.: %32
The: %32
portable: %32
implementation: %32
of: %32
rand: %32
and: %13
srand: %32
suggested: %32
by: %32
the: %32
standard: %32
appears: %32
in: %32
Section: %32
2
.
7
.: %13
Exercise: %32
7
-
9
.: %32
Functions: %32
like: %32
isupper: %32
can: %32
be: %32
implemented: %32
to: %32
save: %32
space: %32
or: %32
to: %32
save: %32
time
.: %32
Explore: %32
both: %13
possibilities
.: %13
Back: %32
to: %32
Chapter: %32
6: %32
-
-: %32
Index: %32
-
-: %32
Chapter: %32
8: %13
Chapter: %32
8: %32
-: %32
The: %32
UNIX: %32
System: %32
Interface: %13
Back: %32
to: %32
Chapter: %32
7: %32
-
-: %32
Index: %32
-
-: %32
Appendix: %32
A: %13
Chapter: %32
8: %32
-: %32
The: %32
UNIX: %32
System: %32
Interface: %13
The: %32
UNIX: %32
operating: %32
system: %32
provides: %32
its: %32
services: %32
through: %32
a: %32
set: %32
of: %32
system: %32
calls
,: %32
which: %32
are: %32
in: %32
effect: %32
functions: %32
within: %32
the: %32
operating: %32
system: %32
that: %32
may: %32
be: %32
called: %32
by: %32
user: %13
programs
.: %32
This: %32
chapter: %32
describes: %32
how: %32
to: %32
use: %32
some: %32
of: %32
the: %32
most: %32
important: %32
system: %32
calls: %32
from: %32
C: %32
programs
.: %32
If: %32
you: %32
use: %32
UNIX
,: %32
this: %32
should: %32
be: %32
directly: %32
helpful
,: %32
for: %32
it: %32
is: %13
sometimes: %32
necessary: %32
to: %32
employ: %32
system: %32
calls: %32
for: %32
maximum: %32
efficiency
,: %32
or: %32
to: %32
access: %32
some: %32
facility: %32
that: %32
is: %32
not: %32
in: %32
the: %32
library
.: %32
Even: %32
if: %32
you: %32
use: %32
C: %32
on: %32
a: %32
different: %32
operating: %13
system
,: %32
however
,: %32
you: %32
should: %32
be: %32
able: %32
to: %32
glean: %32
insight: %32
into: %32
C: %32
programming: %32
from: %32
studying: %32
these: %32
examples
;: %32
although: %32
details: %32
vary
,: %32
similar: %32
code: %32
will: %32
be: %32
found: %32
on: %32
any: %13
system
.: %32
Since: %32
the: %32
ANSI: %32
C: %32
library: %32
is: %32
in: %32
many: %32
cases: %32
modeled: %32
on: %32
UNIX: %32
facilities
,: %32
this: %32
code: %32
may: %32
help: %32
your: %32
understanding: %32
of: %32
the: %32
library: %32
as: %32
well
.: %13
This: %32
chapter: %32
is: %32
divided: %32
into: %32
three: %32
major: %32
parts
:: %32
input
/
output
,: %32
file: %32
system
,: %32
and: %32
storage: %32
allocation
.: %32
The: %32
first: %32
two: %32
parts: %32
assume: %32
a: %32
modest: %32
familiarity: %32
with: %32
the: %32
external: %13
characteristics: %32
of: %32
UNIX: %32
systems
.: %13
Chapter: %32
7: %32
was: %32
concerned: %32
with: %32
an: %32
input
/
output: %32
interface: %32
that: %32
is: %32
uniform: %32
across: %32
operating: %32
systems
.: %32
On: %32
any: %32
particular: %32
system: %32
the: %32
routines: %32
of: %32
the: %32
standard: %32
library: %32
have: %32
to: %13
be: %32
written: %32
in: %32
terms: %32
of: %32
the: %32
facilities: %32
provided: %32
by: %32
the: %32
host: %32
system
.: %32
In: %32
the: %32
next: %32
few: %32
sections: %32
we: %32
will: %32
describe: %32
the: %32
UNIX: %32
system: %32
calls: %32
for: %32
input: %32
and: %32
output
,: %32
and: %32
show: %32
how: %13
parts: %32
of: %32
the: %32
standard: %32
library: %32
can: %32
be: %32
implemented: %32
with: %32
them
.: %13
8
.
1: %32
File: %32
Descriptors: %13
In: %32
the: %32
UNIX: %32
operating: %32
system
,: %32
all: %32
input: %32
and: %32
output: %32
is: %32
done: %32
by: %32
reading: %32
or: %32
writing: %32
files
,: %32
because: %32
all: %32
peripheral: %32
devices
,: %32
even: %32
keyboard: %32
and: %32
screen
,: %32
are: %32
files: %32
in: %32
the: %32
file: %13
system
.: %32
This: %32
means: %32
that: %32
a: %32
single: %32
homogeneous: %32
interface: %32
handles: %32
all: %32
communication: %32
between: %32
a: %32
program: %32
and: %32
peripheral: %32
devices
.: %13
In: %32
the: %32
most: %32
general: %32
case
,: %32
before: %32
you: %32
read: %32
and: %32
write: %32
a: %32
file
,: %32
you: %32
must: %32
inform: %32
the: %32
system: %32
of: %32
your: %32
intent: %32
to: %32
do: %32
so
,: %32
a: %32
process: %32
called: %32
opening: %32
the: %32
file
.: %32
If: %32
you: %32
are: %32
going: %32
to: %13
write: %32
on: %32
a: %32
file: %32
it: %32
may: %32
also: %32
be: %32
necessary: %32
to: %32
create: %32
it: %32
or: %32
to: %32
discard: %32
its: %32
previous: %32
contents
.: %32
The: %32
system: %32
checks: %32
your: %32
right: %32
to: %32
do: %32
so: %32
(
Does: %32
the: %32
file: %32
exist
?: %32
Do: %32
you: %32
have: %13
permission: %32
to: %32
access: %32
it
?
): %32
and: %32
if: %32
all: %32
is: %32
well
,: %32
returns: %32
to: %32
the: %32
program: %32
a: %32
small: %32
non
-
negative: %32
integer: %32
called: %32
a: %32
file: %32
descriptor
.: %32
Whenever: %32
input: %32
or: %32
output: %32
is: %32
to: %32
be: %32
done: %32
on: %32
the: %13
file
,: %32
the: %32
file: %32
descriptor: %32
is: %32
used: %32
instead: %32
of: %32
the: %32
name: %32
to: %32
identify: %32
the: %32
file
.: %32
(
A: %32
file: %32
descriptor: %32
is: %32
analogous: %32
to: %32
the: %32
file: %32
pointer: %32
used: %32
by: %32
the: %32
standard: %32
library
,: %32
or: %32
to: %32
the: %32
file: %13
handle: %32
of: %32
MS
-
DOS
.
): %32
All: %32
information: %32
about: %32
an: %32
open: %32
file: %32
is: %32
maintained: %32
by: %32
the: %32
system
;: %32
the: %32
user: %32
program: %32
refers: %32
to: %32
the: %32
file: %32
only: %32
by: %32
the: %32
file: %32
descriptor
.: %13
Since: %32
input: %32
and: %32
output: %32
involving: %32
keyboard: %32
and: %32
screen: %32
is: %32
so: %32
common
,: %32
special: %32
arrangements: %32
exist: %32
to: %32
make: %32
this: %32
convenient
.: %32
When: %32
the: %32
command: %32
interpreter: %32
(
the: %32
`
`
shell
'
'
): %13
runs: %32
a: %32
program
,: %32
three: %32
files: %32
are: %32
open
,: %32
with: %32
file: %32
descriptors: %32
0
,: %32
1
,: %32
and: %32
2
,: %32
called: %32
the: %32
standard: %32
input
,: %32
the: %32
standard: %32
output
,: %32
and: %32
the: %32
standard: %32
error
.: %32
If: %32
a: %32
program: %32
reads: %32
0: %32
and: %13
writes: %32
1: %32
and: %32
2
,: %32
it: %32
can: %32
do: %32
input: %32
and: %32
output: %32
without: %32
worrying: %32
about: %32
opening: %32
files
.: %13
The: %32
user: %32
of: %32
a: %32
program: %32
can: %32
redirect: %32
I
/
O: %32
to: %32
and: %32
from: %32
files: %32
with: %32
<: %32
and: %32
>
:: %13
prog: %32
<
infile: %32
>
outfile: %13
Chapter: %32
8: %32
-: %32
The: %32
UNIX: %32
System: %32
Interface: %13
In: %32
this: %32
case
,: %32
the: %32
shell: %32
changes: %32
the: %32
default: %32
assignments: %32
for: %32
the: %32
file: %32
descriptors: %32
0: %32
and: %32
1: %32
to: %32
the: %32
named: %32
files
.: %32
Normally: %32
file: %32
descriptor: %32
2: %32
remains: %32
attached: %32
to: %32
the: %32
screen
,: %32
so: %13
error: %32
messages: %32
can: %32
go: %32
there
.: %32
Similar: %32
observations: %32
hold: %32
for: %32
input: %32
or: %32
output: %32
associated: %32
with: %32
a: %32
pipe
.: %32
In: %32
all: %32
cases
,: %32
the: %32
file: %32
assignments: %32
are: %32
changed: %32
by: %32
the: %32
shell
,: %32
not: %32
by: %32
the: %13
program
.: %32
The: %32
program: %32
does: %32
not: %32
know: %32
where: %32
its: %32
input: %32
comes: %32
from: %32
nor: %32
where: %32
its: %32
output: %32
goes
,: %32
so: %32
long: %32
as: %32
it: %32
uses: %32
file: %32
0: %32
for: %32
input: %32
and: %32
1: %32
and: %32
2: %32
for: %32
output
.: %13
8
.
2: %32
Low: %32
Level: %32
I
/
O: %32
-: %32
Read: %32
and: %32
Write: %13
Input: %32
and: %32
output: %32
uses: %32
the: %32
read: %32
and: %32
write: %32
system: %32
calls
,: %32
which: %32
are: %32
accessed: %32
from: %32
C: %32
programs: %32
through: %32
two: %32
functions: %32
called: %32
read: %32
and: %32
write
.: %32
For: %32
both
,: %32
the: %32
first: %13
argument: %32
is: %32
a: %32
file: %32
descriptor
.: %32
The: %32
second: %32
argument: %32
is: %32
a: %32
character: %32
array: %32
in: %32
your: %32
program: %32
where: %32
the: %32
data: %32
is: %32
to: %32
go: %32
to: %32
or: %32
to: %32
come: %32
from
.: %32
The: %32
third: %32
argument: %32
is: %32
the: %32
number: %13
is: %32
the: %32
number: %32
of: %32
bytes: %32
to: %32
be: %32
transferred
.: %13
int: %32
n
_
read: %32
=: %32
read
(
int: %32
fd
,: %32
char: %32
*
buf
,: %32
int: %32
n
)
;: %13
int: %32
n
_
written: %32
=: %32
write
(
int: %32
fd
,: %32
char: %32
*
buf
,: %32
int: %32
n
)
;: %13
Each: %32
call: %32
returns: %32
a: %32
count: %32
of: %32
the: %32
number: %32
of: %32
bytes: %32
transferred
.: %32
On: %32
reading
,: %32
the: %32
number: %32
of: %32
bytes: %32
returned: %32
may: %32
be: %32
less: %32
than: %32
the: %32
number: %32
requested
.: %32
A: %32
return: %32
value: %32
of: %32
zero: %13
bytes: %32
implies: %32
end: %32
of: %32
file
,: %32
and: %32
-
1: %32
indicates: %32
an: %32
error: %32
of: %32
some: %32
sort
.: %32
For: %32
writing
,: %32
the: %32
return: %32
value: %32
is: %32
the: %32
number: %32
of: %32
bytes: %32
written
;: %32
an: %32
error: %32
has: %32
occurred: %32
if: %32
this: %32
isn
'
t: %32
equal: %32
to: %13
the: %32
number: %32
requested
.: %13
Any: %32
number: %32
of: %32
bytes: %32
can: %32
be: %32
read: %32
or: %32
written: %32
in: %32
one: %32
call
.: %32
The: %32
most: %32
common: %32
values: %32
are: %32
1
,: %32
which: %32
means: %32
one: %32
character: %32
at: %32
a: %32
time: %32
(
`
`
unbuffered
'
'
)
,: %32
and: %32
a: %32
number: %32
like: %32
1
0
2
4: %13
or: %32
4
0
9
6: %32
that: %32
corresponds: %32
to: %32
a: %32
physical: %32
block: %32
size: %32
on: %32
a: %32
peripheral: %32
device
.: %32
Larger: %32
sizes: %32
will: %32
be: %32
more: %32
efficient: %32
because: %32
fewer: %32
system: %32
calls: %32
will: %32
be: %32
made
.: %13
Putting: %32
these: %32
facts: %32
together
,: %32
we: %32
can: %32
write: %32
a: %32
simple: %32
program: %32
to: %32
copy: %32
its: %32
input: %32
to: %32
its: %32
output
,: %32
the: %32
equivalent: %32
of: %32
the: %32
file: %32
copying: %32
program: %32
written: %32
for: %32
Chapter: %32
1
.: %32
This: %13
program: %32
will: %32
copy: %32
anything: %32
to: %32
anything
,: %32
since: %32
the: %32
input: %32
and: %32
output: %32
can: %32
be: %32
redirected: %32
to: %32
any: %32
file: %32
or: %32
device
.: %13
#
include: %32
"
syscalls
.
h
": %13
main
(
): %32
/
*: %32
copy: %32
input: %32
to: %32
output: %32
*
/: %13
{: %13
char: %32
buf
[
BUFSIZ
]
;: %13
int: %32
n
;: %13
while: %32
(
(
n: %32
=: %32
read
(
0
,: %32
buf
,: %32
BUFSIZ
)
): %32
>: %32
0
): %13
write
(
1
,: %32
buf
,: %32
n
)
;: %13
return: %32
0
;: %13
}: %13
We: %32
have: %32
collected: %32
function: %32
prototypes: %32
for: %32
the: %32
system: %32
calls: %32
into: %32
a: %32
file: %32
called: %32
syscalls
.
h: %32
so: %32
we: %32
can: %32
include: %32
it: %32
in: %32
the: %32
programs: %32
of: %32
this: %32
chapter
.: %32
This: %32
name: %32
is: %32
not: %13
standard
,: %32
however
.: %13
The: %32
parameter: %32
BUFSIZ: %32
is: %32
also: %32
defined: %32
in: %32
syscalls
.
h
;: %32
its: %32
value: %32
is: %32
a: %32
good: %32
size: %32
for: %32
the: %32
local: %32
system
.: %32
If: %32
the: %32
file: %32
size: %32
is: %32
not: %32
a: %32
multiple: %32
of: %32
BUFSIZ
,: %32
some: %32
read: %32
will: %13
return: %32
a: %32
smaller: %32
number: %32
of: %32
bytes: %32
to: %32
be: %32
written: %32
by: %32
write
;: %32
the: %32
next: %32
call: %32
to: %32
read: %32
after: %32
that: %32
will: %32
return: %32
zero
.: %13
Chapter: %32
8: %32
-: %32
The: %32
UNIX: %32
System: %32
Interface: %13
It: %32
is: %32
instructive: %32
to: %32
see: %32
how: %32
read: %32
and: %32
write: %32
can: %32
be: %32
used: %32
to: %32
construct: %32
higher
-
level: %32
routines: %32
like: %32
getchar
,: %32
putchar
,: %32
etc
.: %32
For: %32
example
,: %32
here: %32
is: %32
a: %32
version: %32
of: %13
getchar: %32
that: %32
does: %32
unbuffered: %32
input
,: %32
by: %32
reading: %32
the: %32
standard: %32
input: %32
one: %32
character: %32
at: %32
a: %32
time
.: %13
#
include: %32
"
syscalls
.
h
": %13
/
*: %32
getchar
:: %32
unbuffered: %32
single: %32
character: %32
input: %32
*
/: %13
int: %32
getchar
(
void
): %13
{: %13
char: %32
c
;: %13
return: %32
(
read
(
0
,: %32
&
c
,: %32
1
): %32
=
=: %32
1
): %32
?: %32
(
unsigned: %32
char
): %32
c: %32
:: %32
EOF
;: %13
}: %13
c: %32
must: %32
be: %32
a: %32
char
,: %32
because: %32
read: %32
needs: %32
a: %32
character: %32
pointer
.: %32
Casting: %32
c: %32
to: %32
unsigned: %32
char: %32
in: %32
the: %32
return: %32
statement: %32
eliminates: %32
any: %32
problem: %32
of: %32
sign: %32
extension
.: %13
The: %32
second: %32
version: %32
of: %32
getchar: %32
does: %32
input: %32
in: %32
big: %32
chunks
,: %32
and: %32
hands: %32
out: %32
the: %32
characters: %32
one: %32
at: %32
a: %32
time
.: %13
#
include: %32
"
syscalls
.
h
": %13
/
*: %32
getchar
:: %32
simple: %32
buffered: %32
version: %32
*
/: %13
int: %32
getchar
(
void
): %13
{: %13
static: %32
char: %32
buf
[
BUFSIZ
]
;: %13
static: %32
char: %32
*
bufp: %32
=: %32
buf
;: %13
static: %32
int: %32
n: %32
=: %32
0
;: %13
if: %32
(
n: %32
=
=: %32
0
): %32
{: %32
/
*: %32
buffer: %32
is: %32
empty: %32
*
/: %13
n: %32
=: %32
read
(
0
,: %32
buf
,: %32
sizeof: %32
buf
)
;: %13
bufp: %32
=: %32
buf
;: %13
}: %13
return: %32
(
-
-
n: %32
>
=: %32
0
): %32
?: %32
(
unsigned: %32
char
): %32
*
bufp
+
+: %32
:: %32
EOF
;: %13
}: %13
If: %32
these: %32
versions: %32
of: %32
getchar: %32
were: %32
to: %32
be: %32
compiled: %32
with: %32
<
stdio
.
h
>: %32
included
,: %32
it: %32
would: %32
be: %32
necessary: %32
to: %32
#
undef: %32
the: %32
name: %32
getchar: %32
in: %32
case: %32
it: %32
is: %32
implemented: %32
as: %32
a: %13
macro
.: %13
8
.
3: %32
Open
,: %32
Creat
,: %32
Close
,: %32
Unlink: %13
Other: %32
than: %32
the: %32
default: %32
standard: %32
input
,: %32
output: %32
and: %32
error
,: %32
you: %32
must: %32
explicitly: %32
open: %32
files: %32
in: %32
order: %32
to: %32
read: %32
or: %32
write: %32
them
.: %32
There: %32
are: %32
two: %32
system: %32
calls: %32
for: %32
this
,: %32
open: %32
and: %13
creat: %32
[
sic
]
.: %13
Chapter: %32
8: %32
-: %32
The: %32
UNIX: %32
System: %32
Interface: %13
open: %32
is: %32
rather: %32
like: %32
the: %32
fopen: %32
discussed: %32
in: %32
Chapter: %32
7
,: %32
except: %32
that: %32
instead: %32
of: %32
returning: %32
a: %32
file: %32
pointer
,: %32
it: %32
returns: %32
a: %32
file: %32
descriptor
,: %32
which: %32
is: %32
just: %32
an: %32
int
.: %32
open: %32
returns: %32
-: %13
1: %32
if: %32
any: %32
error: %32
occurs
.: %13
#
include: %32
<
fcntl
.
h
>: %13
int: %32
fd
;: %13
int: %32
open
(
char: %32
*
name
,: %32
int: %32
flags
,: %32
int: %32
perms
)
;: %13
fd: %32
=: %32
open
(
name
,: %32
flags
,: %32
perms
)
;: %13
As: %32
with: %32
fopen
,: %32
the: %32
name: %32
argument: %32
is: %32
a: %32
character: %32
string: %32
containing: %32
the: %32
filename
.: %32
The: %32
second: %32
argument
,: %32
flags
,: %32
is: %32
an: %32
int: %32
that: %32
specifies: %32
how: %32
the: %32
file: %32
is: %32
to: %32
be: %13
opened
;: %32
the: %32
main: %32
values: %32
are: %13
O
_
RDONLY: %32
open: %32
for: %32
reading: %32
only: %13
O
_
WRONLY: %32
open: %32
for: %32
writing: %32
only: %13
O
_
RDWR: %32
open: %32
for: %32
both: %32
reading: %32
and: %32
writing: %13
These: %32
constants: %32
are: %32
defined: %32
in: %32
<
fcntl
.
h
>: %32
on: %32
System: %32
V: %32
UNIX: %32
systems
,: %32
and: %32
in: %32
<
sys
/
file
.
h
>: %32
on: %32
Berkeley: %32
(
BSD
): %32
versions
.: %13
To: %32
open: %32
an: %32
existing: %32
file: %32
for: %32
reading
,: %13
fd: %32
=: %32
open
(
name
,: %32
O
_
RDONLY
,
0
)
;: %13
The: %32
perms: %32
argument: %32
is: %32
always: %32
zero: %32
for: %32
the: %32
uses: %32
of: %32
open: %32
that: %32
we: %32
will: %32
discuss
.: %13
It: %32
is: %32
an: %32
error: %32
to: %32
try: %32
to: %32
open: %32
a: %32
file: %32
that: %32
does: %32
not: %32
exist
.: %32
The: %32
system: %32
call: %32
creat: %32
is: %32
provided: %32
to: %32
create: %32
new: %32
files
,: %32
or: %32
to: %32
re
-
write: %32
old: %32
ones
.: %13
int: %32
creat
(
char: %32
*
name
,: %32
int: %32
perms
)
;: %13
fd: %32
=: %32
creat
(
name
,: %32
perms
)
;: %13
returns: %32
a: %32
file: %32
descriptor: %32
if: %32
it: %32
was: %32
able: %32
to: %32
create: %32
the: %32
file
,: %32
and: %32
-
1: %32
if: %32
not
.: %32
If: %32
the: %32
file: %32
already: %32
exists
,: %32
creat: %32
will: %32
truncate: %32
it: %32
to: %32
zero: %32
length
,: %32
thereby: %32
discarding: %32
its: %32
previous: %13
contents
;: %32
it: %32
is: %32
not: %32
an: %32
error: %32
to: %32
creat: %32
a: %32
file: %32
that: %32
already: %32
exists
.: %13
If: %32
the: %32
file: %32
does: %32
not: %32
already: %32
exist
,: %32
creat: %32
creates: %32
it: %32
with: %32
the: %32
permissions: %32
specified: %32
by: %32
the: %32
perms: %32
argument
.: %32
In: %32
the: %32
UNIX: %32
file: %32
system
,: %32
there: %32
are: %32
nine: %32
bits: %32
of: %32
permission: %13
information: %32
associated: %32
with: %32
a: %32
file: %32
that: %32
control: %32
read
,: %32
write: %32
and: %32
execute: %32
access: %32
for: %32
the: %32
owner: %32
of: %32
the: %32
file
,: %32
for: %32
the: %32
owner
'
s: %32
group
,: %32
and: %32
for: %32
all: %32
others
.: %32
Thus: %32
a: %32
three
-
digit: %32
octal: %13
number: %32
is: %32
convenient: %32
for: %32
specifying: %32
the: %32
permissions
.: %32
For: %32
example
,: %32
0
7
7
5: %32
specifies: %32
read
,: %32
write: %32
and: %32
execute: %32
permission: %32
for: %32
the: %32
owner
,: %32
and: %32
read: %32
and: %32
execute: %32
permission: %13
for: %32
the: %32
group: %32
and: %32
everyone: %32
else
.: %13
To: %32
illustrate
,: %32
here: %32
is: %32
a: %32
simplified: %32
version: %32
of: %32
the: %32
UNIX: %32
program: %32
cp
,: %32
which: %32
copies: %32
one: %32
file: %32
to: %32
another
.: %32
Our: %32
version: %32
copies: %32
only: %32
one: %32
file
,: %32
it: %32
does: %32
not: %32
permit: %32
the: %32
second: %13
argument: %32
to: %32
be: %32
a: %32
directory
,: %32
and: %32
it: %32
invents: %32
permissions: %32
instead: %32
of: %32
copying: %32
them
.: %13
Chapter: %32
8: %32
-: %32
The: %32
UNIX: %32
System: %32
Interface: %13
#
include: %32
<
stdio
.
h
>: %13
#
include: %32
<
fcntl
.
h
>: %13
#
include: %32
"
syscalls
.
h
": %13
#
define: %32
PERMS: %32
0
6
6
6: %13
void: %32
error
(
char: %32
*
,: %13
/
*: %32
RW: %32
for: %32
owner
,: %32
group
,: %32
others: %32
*
/: %13
.
.
.
)
;: %13
/
*: %32
cp
:: %32
copy: %32
f
1: %32
to: %32
f
2: %32
*
/: %13
main
(
int: %32
argc
,: %32
char: %32
*
argv
[
]
): %13
{: %13
int: %32
f
1
,: %32
f
2
,: %32
n
;: %13
char: %32
buf
[
BUFSIZ
]
;: %13
if: %32
(
argc: %32
!
=: %32
3
): %13
error
(
"
Usage
:: %32
cp: %32
from: %32
to
"
)
;: %13
if: %32
(
(
f
1: %32
=: %32
open
(
argv
[
1
]
,: %32
O
_
RDONLY
,: %32
0
)
): %32
=
=: %32
-
1
): %13
error
(
"
cp
:: %32
can
'
t: %32
open: %32
%:
s
"
,: %32
argv
[
1
]
)
;: %13
if: %32
(
(
f
2: %32
=: %32
creat
(
argv
[
2
]
,: %32
PERMS
)
): %32
=
=: %32
-
1
): %13
error
(
"
cp
:: %32
can
'
t: %32
create: %32
%:
s
,: %32
mode: %32
%:
0
3
o
"
,: %13
argv
[
2
]
,: %32
PERMS
)
;: %13
while: %32
(
(
n: %32
=: %32
read
(
f
1
,: %32
buf
,: %32
BUFSIZ
)
): %32
>: %32
0
): %13
if: %32
(
write
(
f
2
,: %32
buf
,: %32
n
): %32
!
=: %32
n
): %13
error
(
"
cp
:: %32
write: %32
error: %32
on: %32
file: %32
%:
s
"
,: %32
argv
[
2
]
)
;: %13
return: %32
0
;: %13
}: %13
This: %32
program: %32
creates: %32
the: %32
output: %32
file: %32
with: %32
fixed: %32
permissions: %32
of: %32
0
6
6
6
.: %32
With: %32
the: %32
stat: %32
system: %32
call
,: %32
described: %32
in: %32
Section: %32
8
.
6
,: %32
we: %32
can: %32
determine: %32
the: %32
mode: %32
of: %32
an: %32
existing: %13
file: %32
and: %32
thus: %32
give: %32
the: %32
same: %32
mode: %32
to: %32
the: %32
copy
.: %13
Notice: %32
that: %32
the: %32
function: %32
error: %32
is: %32
called: %32
with: %32
variable: %32
argument: %32
lists: %32
much: %32
like: %32
printf
.: %32
The: %32
implementation: %32
of: %32
error: %32
illustrates: %32
how: %32
to: %32
use: %32
another: %32
member: %32
of: %32
the: %13
printf: %32
family
.: %32
The: %32
standard: %32
library: %32
function: %32
vprintf: %32
is: %32
like: %32
printf: %32
except: %32
that: %32
the: %32
variable: %32
argument: %32
list: %32
is: %32
replaced: %32
by: %32
a: %32
single: %32
argument: %32
that: %32
has: %32
been: %13
initialized: %32
by: %32
calling: %32
the: %32
va
_
start: %32
macro
.: %32
Similarly
,: %32
vfprintf: %32
and: %32
vsprintf: %32
match: %32
fprintf: %32
and: %32
sprintf
.: %13
#
include: %32
<
stdio
.
h
>: %13
#
include: %32
<
stdarg
.
h
>: %13
/
*: %32
error
:: %32
print: %32
an: %32
error: %32
message: %32
and: %32
die: %32
*
/: %13
void: %32
error
(
char: %32
*
fmt
,: %32
.
.
.
): %13
{: %13
va
_
list: %32
args
;: %13
va
_
start
(
args
,: %32
fmt
)
;: %13
Chapter: %32
8: %32
-: %32
The: %32
UNIX: %32
System: %32
Interface: %13
fprintf
(
stderr
,: %32
"
error
:: %32
"
)
;: %13
vprintf
(
stderr
,: %32
fmt
,: %32
args
)
;: %13
fprintf
(
stderr
,: %32
"
\
n
"
)
;: %13
va
_
end
(
args
)
;: %13
exit
(
1
)
;: %13
}: %13
There: %32
is: %32
a: %32
limit: %32
(
often: %32
about: %32
2
0
): %32
on: %32
the: %32
number: %32
of: %32
files: %32
that: %32
a: %32
program: %32
may: %32
open: %32
simultaneously
.: %32
Accordingly
,: %32
any: %32
program: %32
that: %32
intends: %32
to: %32
process: %32
many: %32
files: %32
must: %32
be: %13
prepared: %32
to: %32
re
-
use: %32
file: %32
descriptors
.: %32
The: %32
function: %32
close
(
int: %32
fd
): %32
breaks: %32
the: %32
connection: %32
between: %32
a: %32
file: %32
descriptor: %32
and: %32
an: %32
open: %32
file
,: %32
and: %32
frees: %32
the: %32
file: %32
descriptor: %32
for: %13
use: %32
with: %32
some: %32
other: %32
file
;: %32
it: %32
corresponds: %32
to: %32
fclose: %32
in: %32
the: %32
standard: %32
library: %32
except: %32
that: %32
there: %32
is: %32
no: %32
buffer: %32
to: %32
flush
.: %32
Termination: %32
of: %32
a: %32
program: %32
via: %32
exit: %32
or: %32
return: %32
from: %13
the: %32
main: %32
program: %32
closes: %32
all: %32
open: %32
files
.: %13
The: %32
function: %32
unlink
(
char: %32
*
name
): %32
removes: %32
the: %32
file: %32
name: %32
from: %32
the: %32
file: %32
system
.: %32
It: %32
corresponds: %32
to: %32
the: %32
standard: %32
library: %32
function: %32
remove
.: %13
Exercise: %32
8
-
1
.: %32
Rewrite: %32
the: %32
program: %32
cat: %32
from: %32
Chapter: %32
7: %32
using: %32
read
,: %32
write
,: %32
open
,: %32
and: %32
close: %32
instead: %32
of: %32
their: %32
standard: %32
library: %32
equivalents
.: %32
Perform: %32
experiments: %13
to: %32
determine: %32
the: %32
relative: %32
speeds: %32
of: %32
the: %32
two: %32
versions
.: %13
8
.
4: %32
Random: %32
Access: %32
-: %32
Lseek: %13
Input: %32
and: %32
output: %32
are: %32
normally: %32
sequential
:: %32
each: %32
read: %32
or: %32
write: %32
takes: %32
place: %32
at: %32
a: %32
position: %32
in: %32
the: %32
file: %32
right: %32
after: %32
the: %32
previous: %32
one
.: %32
When: %32
necessary
,: %32
however
,: %32
a: %32
file: %32
can: %13
be: %32
read: %32
or: %32
written: %32
in: %32
any: %32
arbitrary: %32
order
.: %32
The: %32
system: %32
call: %32
lseek: %32
provides: %32
a: %32
way: %32
to: %32
move: %32
around: %32
in: %32
a: %32
file: %32
without: %32
reading: %32
or: %32
writing: %32
any: %32
data
:: %13
long: %32
lseek
(
int: %32
fd
,: %32
long: %32
offset
,: %32
int: %32
origin
)
;: %13
sets: %32
the: %32
current: %32
position: %32
in: %32
the: %32
file: %32
whose: %32
descriptor: %32
is: %32
fd: %32
to: %32
offset
,: %32
which: %32
is: %32
taken: %32
relative: %32
to: %32
the: %32
location: %32
specified: %32
by: %32
origin
.: %32
Subsequent: %32
reading: %32
or: %32
writing: %13
will: %32
begin: %32
at: %32
that: %32
position
.: %32
origin: %32
can: %32
be: %32
0
,: %32
1
,: %32
or: %32
2: %32
to: %32
specify: %32
that: %32
offset: %32
is: %32
to: %32
be: %32
measured: %32
from: %32
the: %32
beginning
,: %32
from: %32
the: %32
current: %32
position
,: %32
or: %32
from: %32
the: %32
end: %32
of: %32
the: %13
file: %32
respectively
.: %32
For: %32
example
,: %32
to: %32
append: %32
to: %32
a: %32
file: %32
(
the: %32
redirection: %32
>
>: %32
in: %32
the: %32
UNIX: %32
shell
,: %32
or: %32
"
a
": %32
for: %32
fopen
)
,: %32
seek: %32
to: %32
the: %32
end: %32
before: %32
writing
:: %13
lseek
(
fd
,: %32
0
L
,: %32
2
)
;: %13
To: %32
get: %32
back: %32
to: %32
the: %32
beginning: %32
(
`
`
rewind
'
'
)
,: %13
lseek
(
fd
,: %32
0
L
,: %32
0
)
;: %13
Notice: %32
the: %32
0
L: %32
argument
;: %32
it: %32
could: %32
also: %32
be: %32
written: %32
as: %32
(
long
): %32
0: %32
or: %32
just: %32
as: %32
0: %32
if: %32
lseek: %32
is: %32
properly: %32
declared
.: %13
With: %32
lseek
,: %32
it: %32
is: %32
possible: %32
to: %32
treat: %32
files: %32
more: %32
or: %32
less: %32
like: %32
arrays
,: %32
at: %32
the: %32
price: %32
of: %32
slower: %32
access
.: %32
For: %32
example
,: %32
the: %32
following: %32
function: %32
reads: %32
any: %32
number: %32
of: %32
bytes: %32
from: %13
any: %32
arbitrary: %32
place: %32
in: %32
a: %32
file
.: %32
It: %32
returns: %32
the: %32
number: %32
read
,: %32
or: %32
-
1: %32
on: %32
error
.: %13
#
include: %32
"
syscalls
.
h
": %13
Chapter: %32
8: %32
-: %32
The: %32
UNIX: %32
System: %32
Interface: %13
/
*
get
:: %32
read: %32
n: %32
bytes: %32
from: %32
position: %32
pos: %32
*
/: %13
int: %32
get
(
int: %32
fd
,: %32
long: %32
pos
,: %32
char: %32
*
buf
,: %32
int: %32
n
): %13
{: %13
if: %32
(
lseek
(
fd
,: %32
pos
,: %32
0
): %32
>
=: %32
0
): %32
/
*: %32
get: %32
to: %32
pos: %32
*
/: %13
return: %32
read
(
fd
,: %32
buf
,: %32
n
)
;: %13
else: %13
return: %32
-
1
;: %13
}: %13
The: %32
return: %32
value: %32
from: %32
lseek: %32
is: %32
a: %32
long: %32
that: %32
gives: %32
the: %32
new: %32
position: %32
in: %32
the: %32
file
,: %32
or: %32
-
1: %32
if: %32
an: %32
error: %32
occurs
.: %32
The: %32
standard: %32
library: %32
function: %32
fseek: %32
is: %32
similar: %32
to: %32
lseek: %13
except: %32
that: %32
the: %32
first: %32
argument: %32
is: %32
a: %32
FILE: %32
*: %32
and: %32
the: %32
return: %32
is: %32
non
-
zero: %32
if: %32
an: %32
error: %32
occurred
.: %13
8
.
5: %32
Example: %32
-: %32
An: %32
implementation: %32
of: %32
Fopen: %32
and: %32
Getc: %13
Let: %32
us: %32
illustrate: %32
how: %32
some: %32
of: %32
these: %32
pieces: %32
fit: %32
together: %32
by: %32
showing: %32
an: %32
implementation: %32
of: %32
the: %32
standard: %32
library: %32
routines: %32
fopen: %32
and: %32
getc
.: %13
Recall: %32
that: %32
files: %32
in: %32
the: %32
standard: %32
library: %32
are: %32
described: %32
by: %32
file: %32
pointers: %32
rather: %32
than: %32
file: %32
descriptors
.: %32
A: %32
file: %32
pointer: %32
is: %32
a: %32
pointer: %32
to: %32
a: %32
structure: %32
that: %32
contains: %32
several: %32
pieces: %32
of: %13
information: %32
about: %32
the: %32
file
:: %32
a: %32
pointer: %32
to: %32
a: %32
buffer
,: %32
so: %32
the: %32
file: %32
can: %32
be: %32
read: %32
in: %32
large: %32
chunks
;: %32
a: %32
count: %32
of: %32
the: %32
number: %32
of: %32
characters: %32
left: %32
in: %32
the: %32
buffer
;: %32
a: %32
pointer: %32
to: %32
the: %32
next: %13
character: %32
position: %32
in: %32
the: %32
buffer
;: %32
the: %32
file: %32
descriptor
;: %32
and: %32
flags: %32
describing: %32
read
/
write: %32
mode
,: %32
error: %32
status
,: %32
etc
.: %13
The: %32
data: %32
structure: %32
that: %32
describes: %32
a: %32
file: %32
is: %32
contained: %32
in: %32
<
stdio
.
h
>
,: %32
which: %32
must: %32
be: %32
included: %32
(
by: %32
#
include
): %32
in: %32
any: %32
source: %32
file: %32
that: %32
uses: %32
routines: %32
from: %32
the: %32
standard: %13
input
/
output: %32
library
.: %32
It: %32
is: %32
also: %32
included: %32
by: %32
functions: %32
in: %32
that: %32
library
.: %32
In: %32
the: %32
following: %32
excerpt: %32
from: %32
a: %32
typical: %32
<
stdio
.
h
>
,: %32
names: %32
that: %32
are: %32
intended: %32
for: %32
use: %32
only: %32
by: %13
functions: %32
of: %32
the: %32
library: %32
begin: %32
with: %32
an: %32
underscore: %32
so: %32
they: %32
are: %32
less: %32
likely: %32
to: %32
collide: %32
with: %32
names: %32
in: %32
a: %32
user
'
s: %32
program
.: %32
This: %32
convention: %32
is: %32
used: %32
by: %32
all: %32
standard: %32
library: %13
routines
.: %13
#
define: %13
#
define: %13
#
define: %13
#
define: %13
NULL: %13
EOF: %13
BUFSIZ: %13
OPEN
_
MAX: %13
0: %13
(
-
1
): %13
1
0
2
4: %13
2
0: %13
/
*: %32
max: %32
#
files: %32
open: %32
at: %32
once: %32
*
/: %13
typedef: %32
struct: %32
_
iobuf: %32
{: %13
int: %32
cnt
;: %13
/
*: %32
characters: %32
left: %32
*
/: %13
char: %32
*
ptr
;: %13
/
*: %32
next: %32
character: %32
position: %32
*
/: %13
char: %32
*
base
;: %13
/
*: %32
location: %32
of: %32
buffer: %32
*
/: %13
int: %32
flag
;: %13
/
*: %32
mode: %32
of: %32
file: %32
access: %32
*
/: %13
int: %32
fd
;: %13
/
*: %32
file: %32
descriptor: %32
*
/: %13
}: %32
FILE
;: %13
extern: %32
FILE: %32
_
iob
[
OPEN
_
MAX
]
;: %13
#
define: %32
stdin: %13
#
define: %32
stdout: %13
(
&
_
iob
[
0
]
): %13
(
&
_
iob
[
1
]
): %13
Chapter: %32
8: %32
-: %32
The: %32
UNIX: %32
System: %32
Interface: %13
#
define: %32
stderr: %13
enum: %32
_
flags: %13
_
READ: %13
_
WRITE: %13
_
UNBUF: %13
_
EOF: %13
_
ERR: %13
}
;: %13
{: %13
=: %13
=: %13
=: %13
=: %13
=: %13
(
&
_
iob
[
2
]
): %13
0
1
,: %13
0
2
,: %13
0
4
,: %13
0
1
0
,: %13
0
2
0: %13
/
*: %13
/
*: %13
/
*: %13
/
*: %13
/
*: %13
file: %32
open: %32
for: %32
reading: %32
*
/: %13
file: %32
open: %32
for: %32
writing: %32
*
/: %13
file: %32
is: %32
unbuffered: %32
*
/: %13
EOF: %32
has: %32
occurred: %32
on: %32
this: %32
file: %32
*
/: %13
error: %32
occurred: %32
on: %32
this: %32
file: %32
*
/: %13
int: %32
_
fillbuf
(
FILE: %32
*
)
;: %13
int: %32
_
flushbuf
(
int
,: %32
FILE: %32
*
)
;: %13
#
define: %32
feof
(
p
): %13
#
define: %32
ferror
(
p
): %13
#
define: %32
fileno
(
p
): %13
(
(
p
)
-
>
flag: %32
&: %32
_
EOF
): %32
!
=: %32
0
): %13
(
(
p
)
-
>
flag: %32
&: %32
_
ERR
): %32
!
=: %32
0
): %13
(
(
p
)
-
>
fd
): %13
#
define: %32
getc
(
p
): %13
(
-
-
(
p
)
-
>
cnt: %32
>
=: %32
0: %32
\: %13
?: %32
(
unsigned: %32
char
): %32
*
(
p
)
-
>
ptr
+
+: %32
:: %32
_
fillbuf
(
p
)
): %13
#
define: %32
putc
(
x
,
p
): %32
(
-
-
(
p
)
-
>
cnt: %32
>
=: %32
0: %32
\: %13
?: %32
*
(
p
)
-
>
ptr
+
+: %32
=: %32
(
x
): %32
:: %32
_
flushbuf
(
(
x
)
,
p
)
): %13
#
define: %32
getchar
(
): %13
#
define: %32
putcher
(
x
): %13
getc
(
stdin
): %13
putc
(
(
x
)
,: %32
stdout
): %13
The: %32
getc: %32
macro: %32
normally: %32
decrements: %32
the: %32
count
,: %32
advances: %32
the: %32
pointer
,: %32
and: %32
returns: %32
the: %32
character
.: %32
(
Recall: %32
that: %32
a: %32
long: %32
#
define: %32
is: %32
continued: %32
with: %32
a: %32
backslash
.
): %32
If: %32
the: %13
count: %32
goes: %32
negative
,: %32
however
,: %32
getc: %32
calls: %32
the: %32
function: %32
_
fillbuf: %32
to: %32
replenish: %32
the: %32
buffer
,: %32
re
-
initialize: %32
the: %32
structure: %32
contents
,: %32
and: %32
return: %32
a: %32
character
.: %32
The: %32
characters: %13
are: %32
returned: %32
unsigned
,: %32
which: %32
ensures: %32
that: %32
all: %32
characters: %32
will: %32
be: %32
positive
.: %13
Although: %32
we: %32
will: %32
not: %32
discuss: %32
any: %32
details
,: %32
we: %32
have: %32
included: %32
the: %32
definition: %32
of: %32
putc: %32
to: %32
show: %32
that: %32
it: %32
operates: %32
in: %32
much: %32
the: %32
same: %32
way: %32
as: %32
getc
,: %32
calling: %32
a: %32
function: %13
_
flushbuf: %32
when: %32
its: %32
buffer: %32
is: %32
full
.: %32
We: %32
have: %32
also: %32
included: %32
macros: %32
for: %32
accessing: %32
the: %32
error: %32
and: %32
end
-
of
-
file: %32
status: %32
and: %32
the: %32
file: %32
descriptor
.: %13
The: %32
function: %32
fopen: %32
can: %32
now: %32
be: %32
written
.: %32
Most: %32
of: %32
fopen: %32
is: %32
concerned: %32
with: %32
getting: %32
the: %32
file: %32
opened: %32
and: %32
positioned: %32
at: %32
the: %32
right: %32
place
,: %32
and: %32
setting: %32
the: %32
flag: %32
bits: %32
to: %13
indicate: %32
the: %32
proper: %32
state
.: %32
fopen: %32
does: %32
not: %32
allocate: %32
any: %32
buffer: %32
space
;: %32
this: %32
is: %32
done: %32
by: %32
_
fillbuf: %32
when: %32
the: %32
file: %32
is: %32
first: %32
read
.: %13
#
include: %32
<
fcntl
.
h
>: %13
#
include: %32
"
syscalls
.
h
": %13
#
define: %32
PERMS: %32
0
6
6
6: %13
/
*: %32
RW: %32
for: %32
owner
,: %32
group
,: %32
others: %32
*
/: %13
FILE: %32
*
fopen
(
char: %32
*
name
,: %32
char: %32
*
mode
): %13
{: %13
int: %32
fd
;: %13
FILE: %32
*
fp
;: %13
Chapter: %32
8: %32
-: %32
The: %32
UNIX: %32
System: %32
Interface: %13
if: %32
(
*
mode: %32
!
=: %32
'
r
': %32
&
&: %32
*
mode: %32
!
=: %32
'
w
': %32
&
&: %32
*
mode: %32
!
=: %32
'
a
'
): %13
return: %32
NULL
;: %13
for: %32
(
fp: %32
=: %32
_
iob
;: %32
fp: %32
<: %32
_
iob: %32
+: %32
OPEN
_
MAX
;: %32
fp
+
+
): %13
if: %32
(
(
fp
-
>
flag: %32
&: %32
(
_
READ: %32
|: %32
_
WRITE
)
): %32
=
=: %32
0
): %13
break
;: %13
/
*: %32
found: %32
free: %32
slot: %32
*
/: %13
if: %32
(
fp: %32
>
=: %32
_
iob: %32
+: %32
OPEN
_
MAX
): %13
/
*: %32
no: %32
free: %32
slots: %32
*
/: %13
return: %32
NULL
;: %13
if: %32
(
*
mode: %32
=
=: %32
'
w
'
): %13
fd: %32
=: %32
creat
(
name
,: %32
PERMS
)
;: %13
else: %32
if: %32
(
*
mode: %32
=
=: %32
'
a
'
): %32
{: %13
if: %32
(
(
fd: %32
=: %32
open
(
name
,: %32
O
_
WRONLY
,: %32
0
)
): %32
=
=: %32
-
1
): %13
fd: %32
=: %32
creat
(
name
,: %32
PERMS
)
;: %13
lseek
(
fd
,: %32
0
L
,: %32
2
)
;: %13
}: %32
else: %13
fd: %32
=: %32
open
(
name
,: %32
O
_
RDONLY
,: %32
0
)
;: %13
if: %32
(
fd: %32
=
=: %32
-
1
): %13
/
*: %32
couldn
'
t: %32
access: %32
name: %32
*
/: %13
return: %32
NULL
;: %13
fp
-
>
fd: %32
=: %32
fd
;: %13
fp
-
>
cnt: %32
=: %32
0
;: %13
fp
-
>
base: %32
=: %32
NULL
;: %13
fp
-
>
flag: %32
=: %32
(
*
mode: %32
=
=: %32
'
r
'
): %32
?: %32
_
READ: %32
:: %32
_
WRITE
;: %13
return: %32
fp
;: %13
}: %13
This: %32
version: %32
of: %32
fopen: %32
does: %32
not: %32
handle: %32
all: %32
of: %32
the: %32
access: %32
mode: %32
possibilities: %32
of: %32
the: %32
standard
,: %32
though: %32
adding: %32
them: %32
would: %32
not: %32
take: %32
much: %32
code
.: %32
In: %32
particular
,: %32
our: %32
fopen: %13
does: %32
not: %32
recognize: %32
the: %32
`
`
b
'
': %32
that: %32
signals: %32
binary: %32
access
,: %32
since: %32
that: %32
is: %32
meaningless: %32
on: %32
UNIX: %32
systems
,: %32
nor: %32
the: %32
`
`
+
'
': %32
that: %32
permits: %32
both: %32
reading: %32
and: %32
writing
.: %13
The: %32
first: %32
call: %32
to: %32
getc: %32
for: %32
a: %32
particular: %32
file: %32
finds: %32
a: %32
count: %32
of: %32
zero
,: %32
which: %32
forces: %32
a: %32
call: %32
of: %32
_
fillbuf
.: %32
If: %32
_
fillbuf: %32
finds: %32
that: %32
the: %32
file: %32
is: %32
not: %32
open: %32
for: %32
reading
,: %32
it: %32
returns: %13
EOF: %32
immediately
.: %32
Otherwise
,: %32
it: %32
tries: %32
to: %32
allocate: %32
a: %32
buffer: %32
(
if: %32
reading: %32
is: %32
to: %32
be: %32
buffered
)
.: %13
Once: %32
the: %32
buffer: %32
is: %32
established
,: %32
_
fillbuf: %32
calls: %32
read: %32
to: %32
fill: %32
it
,: %32
sets: %32
the: %32
count: %32
and: %32
pointers
,: %32
and: %32
returns: %32
the: %32
character: %32
at: %32
the: %32
beginning: %32
of: %32
the: %32
buffer
.: %32
Subsequent: %32
calls: %13
to: %32
_
fillbuf: %32
will: %32
find: %32
a: %32
buffer: %32
allocated
.: %13
#
include: %32
"
syscalls
.
h
": %13
/
*: %32
_
fillbuf
:: %32
allocate: %32
and: %32
fill: %32
input: %32
buffer: %32
*
/: %13
int: %32
_
fillbuf
(
FILE: %32
*
fp
): %13
{: %13
int: %32
bufsize
;: %13
if: %32
(
(
fp
-
>
flag
&
(
_
READ
|
_
EOF
_
ERR
)
): %32
!
=: %32
_
READ
): %13
Chapter: %32
8: %32
-: %32
The: %32
UNIX: %32
System: %32
Interface: %13
return: %32
EOF
;: %13
bufsize: %32
=: %32
(
fp
-
>
flag: %32
&: %32
_
UNBUF
): %32
?: %32
1: %32
:: %32
BUFSIZ
;: %13
if: %32
(
fp
-
>
base: %32
=
=: %32
NULL
): %13
/
*: %32
no: %32
buffer: %32
yet: %32
*
/: %13
if: %32
(
(
fp
-
>
base: %32
=: %32
(
char: %32
*
): %32
malloc
(
bufsize
)
): %32
=
=: %32
NULL
): %13
return: %32
EOF
;: %13
/
*: %32
can
'
t: %32
get: %32
buffer: %32
*
/: %13
fp
-
>
ptr: %32
=: %32
fp
-
>
base
;: %13
fp
-
>
cnt: %32
=: %32
read
(
fp
-
>
fd
,: %32
fp
-
>
ptr
,: %32
bufsize
)
;: %13
if: %32
(
-
-
fp
-
>
cnt: %32
<: %32
0
): %32
{: %13
if: %32
(
fp
-
>
cnt: %32
=
=: %32
-
1
): %13
fp
-
>
flag: %32
|
=: %32
_
EOF
;: %13
else: %13
fp
-
>
flag: %32
|
=: %32
_
ERR
;: %13
fp
-
>
cnt: %32
=: %32
0
;: %13
return: %32
EOF
;: %13
}: %13
return: %32
(
unsigned: %32
char
): %32
*
fp
-
>
ptr
+
+
;: %13
}: %13
The: %32
only: %32
remaining: %32
loose: %32
end: %32
is: %32
how: %32
everything: %32
gets: %32
started
.: %32
The: %32
array: %32
_
iob: %32
must: %32
be: %32
defined: %32
and: %32
initialized: %32
for: %32
stdin
,: %32
stdout: %32
and: %32
stderr
:: %13
FILE: %32
_
iob
[
OPEN
_
MAX
]: %32
=: %32
{: %13
{: %32
0
,: %32
(
char: %32
*
): %32
0
,: %32
(
char: %13
{: %32
0
,: %32
(
char: %32
*
): %32
0
,: %32
(
char: %13
{: %32
0
,: %32
(
char: %32
*
): %32
0
,: %32
(
char: %13
}
;: %13
/
*: %13
*
): %13
*
): %13
*
): %13
stdin
,: %32
stdout
,: %32
stderr: %32
*
/: %13
0
,: %32
_
READ
,: %32
0: %32
}
,: %13
0
,: %32
_
WRITE
,: %32
1: %32
}
,: %13
0
,: %32
_
WRITE
,: %32
|: %32
_
UNBUF
,: %32
2: %32
}: %13
The: %32
initialization: %32
of: %32
the: %32
flag: %32
part: %32
of: %32
the: %32
structure: %32
shows: %32
that: %32
stdin: %32
is: %32
to: %32
be: %32
read
,: %32
stdout: %32
is: %32
to: %32
be: %32
written
,: %32
and: %32
stderr: %32
is: %32
to: %32
be: %32
written: %32
unbuffered
.: %13
Exercise: %32
8
-
2
.: %32
Rewrite: %32
fopen: %32
and: %32
_
fillbuf: %32
with: %32
fields: %32
instead: %32
of: %32
explicit: %32
bit: %32
operations
.: %32
Compare: %32
code: %32
size: %32
and: %32
execution: %32
speed
.: %13
Exercise: %32
8
-
3
.: %32
Design: %32
and: %32
write: %32
_
flushbuf
,: %32
fflush
,: %32
and: %32
fclose
.: %13
Exercise: %32
8
-
4
.: %32
The: %32
standard: %32
library: %32
function: %13
int: %32
fseek
(
FILE: %32
*
fp
,: %32
long: %32
offset
,: %32
int: %32
origin
): %13
is: %32
identical: %32
to: %32
lseek: %32
except: %32
that: %32
fp: %32
is: %32
a: %32
file: %32
pointer: %32
instead: %32
of: %32
a: %32
file: %32
descriptor: %32
and: %32
return: %32
value: %32
is: %32
an: %32
int: %32
status
,: %32
not: %32
a: %32
position
.: %32
Write: %32
fseek
.: %32
Make: %32
sure: %32
that: %32
your: %13
fseek: %32
coordinates: %32
properly: %32
with: %32
the: %32
buffering: %32
done: %32
for: %32
the: %32
other: %32
functions: %32
of: %32
the: %32
library
.: %13
8
.
6: %32
Example: %32
-: %32
Listing: %32
Directories: %13
Chapter: %32
8: %32
-: %32
The: %32
UNIX: %32
System: %32
Interface: %13
A: %32
different: %32
kind: %32
of: %32
file: %32
system: %32
interaction: %32
is: %32
sometimes: %32
called: %32
for: %32
-: %32
determining: %32
information: %32
about: %32
a: %32
file
,: %32
not: %32
what: %32
it: %32
contains
.: %32
A: %32
directory
-
listing: %32
program: %32
such: %32
as: %32
the: %13
UNIX: %32
command: %32
ls: %32
is: %32
an: %32
example: %32
-: %32
it: %32
prints: %32
the: %32
names: %32
of: %32
files: %32
in: %32
a: %32
directory
,: %32
and
,: %32
optionally
,: %32
other: %32
information
,: %32
such: %32
as: %32
sizes
,: %32
permissions
,: %32
and: %32
so: %32
on
.: %32
The: %32
MS
-
DOS: %13
dir: %32
command: %32
is: %32
analogous
.: %13
Since: %32
a: %32
UNIX: %32
directory: %32
is: %32
just: %32
a: %32
file
,: %32
ls: %32
need: %32
only: %32
read: %32
it: %32
to: %32
retrieve: %32
the: %32
filenames
.: %32
But: %32
is: %32
is: %32
necessary: %32
to: %32
use: %32
a: %32
system: %32
call: %32
to: %32
access: %32
other: %32
information: %32
about: %32
a: %32
file
,: %13
such: %32
as: %32
its: %32
size
.: %32
On: %32
other: %32
systems
,: %32
a: %32
system: %32
call: %32
may: %32
be: %32
needed: %32
even: %32
to: %32
access: %32
filenames
;: %32
this: %32
is: %32
the: %32
case: %32
on: %32
MS
-
DOS: %32
for: %32
instance
.: %32
What: %32
we: %32
want: %32
is: %32
provide: %32
access: %32
to: %13
the: %32
information: %32
in: %32
a: %32
relatively: %32
system
-
independent: %32
way
,: %32
even: %32
though: %32
the: %32
implementation: %32
may: %32
be: %32
highly: %32
system
-
dependent
.: %13
We: %32
will: %32
illustrate: %32
some: %32
of: %32
this: %32
by: %32
writing: %32
a: %32
program: %32
called: %32
fsize
.: %32
fsize: %32
is: %32
a: %32
special: %32
form: %32
of: %32
ls: %32
that: %32
prints: %32
the: %32
sizes: %32
of: %32
all: %32
files: %32
named: %32
in: %32
its: %32
commandline: %13
argument: %32
list
.: %32
If: %32
one: %32
of: %32
the: %32
files: %32
is: %32
a: %32
directory
,: %32
fsize: %32
applies: %32
itself: %32
recursively: %32
to: %32
that: %32
directory
.: %32
If: %32
there: %32
are: %32
no: %32
arguments: %32
at: %32
all
,: %32
it: %32
processes: %32
the: %32
current: %32
directory
.: %13
Let: %32
us: %32
begin: %32
with: %32
a: %32
short: %32
review: %32
of: %32
UNIX: %32
file: %32
system: %32
structure
.: %32
A: %32
directory: %32
is: %32
a: %32
file: %32
that: %32
contains: %32
a: %32
list: %32
of: %32
filenames: %32
and: %32
some: %32
indication: %32
of: %32
where: %32
they: %32
are: %32
located
.: %13
The: %32
`
`
location
'
': %32
is: %32
an: %32
index: %32
into: %32
another: %32
table: %32
called: %32
the: %32
`
`
inode: %32
list
.
'
': %32
The: %32
inode: %32
for: %32
a: %32
file: %32
is: %32
where: %32
all: %32
information: %32
about: %32
the: %32
file: %32
except: %32
its: %32
name: %32
is: %32
kept
.: %32
A: %32
directory: %13
entry: %32
generally: %32
consists: %32
of: %32
only: %32
two: %32
items
,: %32
the: %32
filename: %32
and: %32
an: %32
inode: %32
number
.: %13
Regrettably
,: %32
the: %32
format: %32
and: %32
precise: %32
contents: %32
of: %32
a: %32
directory: %32
are: %32
not: %32
the: %32
same: %32
on: %32
all: %32
versions: %32
of: %32
the: %32
system
.: %32
So: %32
we: %32
will: %32
divide: %32
the: %32
task: %32
into: %32
two: %32
pieces: %32
to: %32
try: %32
to: %32
isolate: %13
the: %32
non
-
portable: %32
parts
.: %32
The: %32
outer: %32
level: %32
defines: %32
a: %32
structure: %32
called: %32
a: %32
Dirent: %32
and: %32
three: %32
routines: %32
opendir
,: %32
readdir
,: %32
and: %32
closedir: %32
to: %32
provide: %32
system
-
independent: %13
access: %32
to: %32
the: %32
name: %32
and: %32
inode: %32
number: %32
in: %32
a: %32
directory: %32
entry
.: %32
We: %32
will: %32
write: %32
fsize: %32
with: %32
this: %32
interface
.: %32
Then: %32
we: %32
will: %32
show: %32
how: %32
to: %32
implement: %32
these: %32
on: %32
systems: %32
that: %32
use: %13
the: %32
same: %32
directory: %32
structure: %32
as: %32
Version: %32
7: %32
and: %32
System: %32
V: %32
UNIX
;: %32
variants: %32
are: %32
left: %32
as: %32
exercises
.: %13
The: %32
Dirent: %32
structure: %32
contains: %32
the: %32
inode: %32
number: %32
and: %32
the: %32
name
.: %32
The: %32
maximum: %32
length: %32
of: %32
a: %32
filename: %32
component: %32
is: %32
NAME
_
MAX
,: %32
which: %32
is: %32
a: %32
system
-
dependent: %32
value
.: %13
opendir: %32
returns: %32
a: %32
pointer: %32
to: %32
a: %32
structure: %32
called: %32
DIR
,: %32
analogous: %32
to: %32
FILE
,: %32
which: %32
is: %32
used: %32
by: %32
readdir: %32
and: %32
closedir
.: %32
This: %32
information: %32
is: %32
collected: %32
into: %32
a: %32
file: %32
called: %13
dirent
.
h
.: %13
#
define: %32
NAME
_
MAX: %13
1
4: %13
/
*: %32
longest: %32
filename: %32
component
;: %32
*
/: %13
/
*: %32
system
-
dependent: %32
*
/: %13
typedef: %32
struct: %32
{: %13
/
*: %32
portable: %32
directory: %32
entry: %32
*
/: %13
long: %32
ino
;: %13
/
*: %32
inode: %32
number: %32
*
/: %13
char: %32
name
[
NAME
_
MAX
+
1
]
;: %13
/
*: %32
name: %32
+: %32
'
\
0
': %32
terminator: %32
*
/: %13
}: %32
Dirent
;: %13
typedef: %32
struct: %32
{: %13
int: %32
fd
;: %13
Dirent: %32
d
;: %13
}: %32
DIR
;: %13
/
*: %32
minimal: %32
DIR
:: %32
no: %32
buffering
,: %32
etc
.: %32
*
/: %13
/
*: %32
file: %32
descriptor: %32
for: %32
the: %32
directory: %32
*
/: %13
/
*: %32
the: %32
directory: %32
entry: %32
*
/: %13
DIR: %32
*
opendir
(
char: %32
*
dirname
)
;: %13
Dirent: %32
*
readdir
(
DIR: %32
*
dfd
)
;: %13
void: %32
closedir
(
DIR: %32
*
dfd
)
;: %13
The: %32
system: %32
call: %32
stat: %32
takes: %32
a: %32
filename: %32
and: %32
returns: %32
all: %32
of: %32
the: %32
information: %32
in: %32
the: %32
inode: %32
for: %32
that: %32
file
,: %32
or: %32
-
1: %32
if: %32
there: %32
is: %32
an: %32
error
.: %32
That: %32
is
,: %13
Chapter: %32
8: %32
-: %32
The: %32
UNIX: %32
System: %32
Interface: %13
char: %32
*
name
;: %13
struct: %32
stat: %32
stbuf
;: %13
int: %32
stat
(
char: %32
*
,: %32
struct: %32
stat: %32
*
)
;: %13
stat
(
name
,: %32
&
stbuf
)
;: %13
fills: %32
the: %32
structure: %32
stbuf: %32
with: %32
the: %32
inode: %32
information: %32
for: %32
the: %32
file: %32
name
.: %32
The: %32
structure: %32
describing: %32
the: %32
value: %32
returned: %32
by: %32
stat: %32
is: %32
in: %32
<
sys
/
stat
.
h
>
,: %32
and: %32
typically: %13
looks: %32
like: %32
this
:: %13
struct: %32
stat: %13
{: %13
dev
_
t: %13
ino
_
t: %13
short: %13
short: %13
short: %13
short: %13
dev
_
t: %13
off
_
t: %13
time
_
t: %13
time
_
t: %13
time
_
t: %13
}
;: %13
/
*: %32
inode: %32
information: %32
returned: %32
by: %32
stat: %32
*
/: %13
st
_
dev
;: %13
st
_
ino
;: %13
st
_
mode
;: %13
st
_
nlink
;: %13
st
_
uid
;: %13
st
_
gid
;: %13
st
_
rdev
;: %13
st
_
size
;: %13
st
_
atime
;: %13
st
_
mtime
;: %13
st
_
ctime
;: %13
/
*: %13
/
*: %13
/
*: %13
/
*: %13
/
*: %13
/
*: %13
/
*: %13
/
*: %13
/
*: %13
/
*: %13
/
*: %13
device: %32
of: %32
inode: %32
*
/: %13
inode: %32
number: %32
*
/: %13
mode: %32
bits: %32
*
/: %13
number: %32
of: %32
links: %32
to: %32
file: %32
*
/: %13
owners: %32
user: %32
id: %32
*
/: %13
owners: %32
group: %32
id: %32
*
/: %13
for: %32
special: %32
files: %32
*
/: %13
file: %32
size: %32
in: %32
characters: %32
*
/: %13
time: %32
last: %32
accessed: %32
*
/: %13
time: %32
last: %32
modified: %32
*
/: %13
time: %32
originally: %32
created: %32
*
/: %13
Most: %32
of: %32
these: %32
values: %32
are: %32
explained: %32
by: %32
the: %32
comment: %32
fields
.: %32
The: %32
types: %32
like: %32
dev
_
t: %32
and: %32
ino
_
t: %32
are: %32
defined: %32
in: %32
<
sys
/
types
.
h
>
,: %32
which: %32
must: %32
be: %32
included: %32
too
.: %13
The: %32
st
_
mode: %32
entry: %32
contains: %32
a: %32
set: %32
of: %32
flags: %32
describing: %32
the: %32
file
.: %32
The: %32
flag: %32
definitions: %32
are: %32
also: %32
included: %32
in: %32
<
sys
/
types
.
h
>
;: %32
we: %32
need: %32
only: %32
the: %32
part: %32
that: %32
deals: %32
with: %32
file: %13
type
:: %13
#
define: %32
S
_
IFMT: %13
#
define: %32
S
_
IFDIR: %13
#
define: %32
S
_
IFCHR: %13
#
define: %32
S
_
IFBLK: %13
#
define: %32
S
_
IFREG: %13
/
*: %32
.
.
.: %32
*
/: %13
0
1
6
0
0
0
0: %13
0
0
4
0
0
0
0: %13
0
0
2
0
0
0
0: %13
0
0
6
0
0
0
0: %13
0
0
1
0
0
0
0: %13
/
*: %13
/
*: %13
/
*: %13
/
*: %13
/
*: %13
type: %32
of: %32
file
:: %32
*
/: %13
directory: %32
*
/: %13
character: %32
special: %32
*
/: %13
block: %32
special: %32
*
/: %13
regular: %32
*
/: %13
Now: %32
we: %32
are: %32
ready: %32
to: %32
write: %32
the: %32
program: %32
fsize
.: %32
If: %32
the: %32
mode: %32
obtained: %32
from: %32
stat: %32
indicates: %32
that: %32
a: %32
file: %32
is: %32
not: %32
a: %32
directory
,: %32
then: %32
the: %32
size: %32
is: %32
at: %32
hand: %32
and: %32
can: %32
be: %32
printed: %13
directly
.: %32
If: %32
the: %32
name: %32
is: %32
a: %32
directory
,: %32
however
,: %32
then: %32
we: %32
have: %32
to: %32
process: %32
that: %32
directory: %32
one: %32
file: %32
at: %32
a: %32
time
;: %32
it: %32
may: %32
in: %32
turn: %32
contain: %32
sub
-
directories
,: %32
so: %32
the: %32
process: %32
is: %13
recursive
.: %13
The: %32
main: %32
routine: %32
deals: %32
with: %32
command
-
line: %32
arguments
;: %32
it: %32
hands: %32
each: %32
argument: %32
to: %32
the: %32
function: %32
fsize
.: %13
Chapter: %32
8: %32
-: %32
The: %32
UNIX: %32
System: %32
Interface: %13
#
include: %13
#
include: %13
#
include: %13
#
include: %13
#
include: %13
#
include: %13
#
include: %13
<
stdio
.
h
>: %13
<
string
.
h
>: %13
"
syscalls
.
h
": %13
<
fcntl
.
h
>: %13
<
sys
/
types
.
h
>: %13
<
sys
/
stat
.
h
>: %13
"
dirent
.
h
": %13
/
*: %32
flags: %32
for: %32
read: %32
and: %32
write: %32
*
/: %13
/
*: %32
typedefs: %32
*
/: %13
/
*: %32
structure: %32
returned: %32
by: %32
stat: %32
*
/: %13
void: %32
fsize
(
char: %32
*
): %13
/
*: %32
print: %32
file: %32
name: %32
*
/: %13
main
(
int: %32
argc
,: %32
char: %32
*
*
argv
): %13
{: %13
if: %32
(
argc: %32
=
=: %32
1
): %32
/
*: %32
default
:: %32
current: %32
directory: %32
*
/: %13
fsize
(
"
.
"
)
;: %13
else: %13
while: %32
(
-
-
argc: %32
>: %32
0
): %13
fsize
(
*
+
+
argv
)
;: %13
return: %32
0
;: %13
}: %13
The: %32
function: %32
fsize: %32
prints: %32
the: %32
size: %32
of: %32
the: %32
file
.: %32
If: %32
the: %32
file: %32
is: %32
a: %32
directory
,: %32
however
,: %32
fsize: %32
first: %32
calls: %32
dirwalk: %32
to: %32
handle: %32
all: %32
the: %32
files: %32
in: %32
it
.: %32
Note: %32
how: %32
the: %32
flag: %32
names: %13
S
_
IFMT: %32
and: %32
S
_
IFDIR: %32
are: %32
used: %32
to: %32
decide: %32
if: %32
the: %32
file: %32
is: %32
a: %32
directory
.: %32
Parenthesization: %32
matters
,: %32
because: %32
the: %32
precedence: %32
of: %32
&: %32
is: %32
lower: %32
than: %32
that: %32
of: %32
=
=
.: %13
int: %32
stat
(
char: %32
*
,: %32
struct: %32
stat: %32
*
)
;: %13
void: %32
dirwalk
(
char: %32
*
,: %32
void: %32
(
*
fcn
)
(
char: %32
*
)
)
;: %13
/
*: %32
fsize
:: %32
print: %32
the: %32
name: %32
of: %32
file: %32
"
name
": %32
*
/: %13
void: %32
fsize
(
char: %32
*
name
): %13
{: %13
struct: %32
stat: %32
stbuf
;: %13
if: %32
(
stat
(
name
,: %32
&
stbuf
): %32
=
=: %32
-
1
): %32
{: %13
fprintf
(
stderr
,: %32
"
fsize
:: %32
can
'
t: %32
access: %32
%:
s
\
n
"
,: %32
name
)
;: %13
return
;: %13
}: %13
if: %32
(
(
stbuf
.
st
_
mode: %32
&: %32
S
_
IFMT
): %32
=
=: %32
S
_
IFDIR
): %13
dirwalk
(
name
,: %32
fsize
)
;: %13
printf
(
"
%:
8
ld: %32
%:
s
\
n
"
,: %32
stbuf
.
st
_
size
,: %32
name
)
;: %13
}: %13
The: %32
function: %32
dirwalk: %32
is: %32
a: %32
general: %32
routine: %32
that: %32
applies: %32
a: %32
function: %32
to: %32
each: %32
file: %32
in: %32
a: %32
directory
.: %32
It: %32
opens: %32
the: %32
directory
,: %32
loops: %32
through: %32
the: %32
files: %32
in: %32
it
,: %32
calling: %32
the: %32
function: %13
on: %32
each
,: %32
then: %32
closes: %32
the: %32
directory: %32
and: %32
returns
.: %32
Since: %32
fsize: %32
calls: %32
dirwalk: %32
on: %32
each: %32
directory
,: %32
the: %32
two: %32
functions: %32
call: %32
each: %32
other: %32
recursively
.: %13
Chapter: %32
8: %32
-: %32
The: %32
UNIX: %32
System: %32
Interface: %13
#
define: %32
MAX
_
PATH: %32
1
0
2
4: %13
/
*: %32
dirwalk
:: %32
apply: %32
fcn: %32
to: %32
all: %32
files: %32
in: %32
dir: %32
*
/: %13
void: %32
dirwalk
(
char: %32
*
dir
,: %32
void: %32
(
*
fcn
)
(
char: %32
*
)
): %13
{: %13
char: %32
name
[
MAX
_
PATH
]
;: %13
Dirent: %32
*
dp
;: %13
DIR: %32
*
dfd
;: %13
if: %32
(
(
dfd: %32
=: %32
opendir
(
dir
)
): %32
=
=: %32
NULL
): %32
{: %13
fprintf
(
stderr
,: %32
"
dirwalk
:: %32
can
'
t: %32
open: %32
%:
s
\
n
"
,: %32
dir
)
;: %13
return
;: %13
}: %13
while: %32
(
(
dp: %32
=: %32
readdir
(
dfd
)
): %32
!
=: %32
NULL
): %32
{: %13
if: %32
(
strcmp
(
dp
-
>
name
,: %32
"
.
"
): %32
=
=: %32
0: %13
|
|: %32
strcmp
(
dp
-
>
name
,: %32
"
.
.
"
)
): %13
continue
;: %13
/
*: %32
skip: %32
self: %32
and: %32
parent: %32
*
/: %13
if: %32
(
strlen
(
dir
)
+
strlen
(
dp
-
>
name
)
+
2: %32
>: %32
sizeof
(
name
)
): %13
fprintf
(
stderr
,: %32
"
dirwalk
:: %32
name: %32
%:
s: %32
%:
s: %32
too: %32
long
\
n
"
,: %13
dir
,: %32
dp
-
>
name
)
;: %13
else: %32
{: %13
sprintf
(
name
,: %32
"
%:
s
/
%:
s
"
,: %32
dir
,: %32
dp
-
>
name
)
;: %13
(
*
fcn
)
(
name
)
;: %13
}: %13
}: %13
closedir
(
dfd
)
;: %13
}: %13
Each: %32
call: %32
to: %32
readdir: %32
returns: %32
a: %32
pointer: %32
to: %32
information: %32
for: %32
the: %32
next: %32
file
,: %32
or: %32
NULL: %32
when: %32
there: %32
are: %32
no: %32
files: %32
left
.: %32
Each: %32
directory: %32
always: %32
contains: %32
entries: %32
for: %32
itself
,: %32
called: %13
"
.
"
,: %32
and: %32
its: %32
parent
,: %32
"
.
.
"
;: %32
these: %32
must: %32
be: %32
skipped
,: %32
or: %32
the: %32
program: %32
will: %32
loop: %32
forever
.: %13
Down: %32
to: %32
this: %32
last: %32
level
,: %32
the: %32
code: %32
is: %32
independent: %32
of: %32
how: %32
directories: %32
are: %32
formatted
.: %32
The: %32
next: %32
step: %32
is: %32
to: %32
present: %32
minimal: %32
versions: %32
of: %32
opendir
,: %32
readdir
,: %32
and: %13
closedir: %32
for: %32
a: %32
specific: %32
system
.: %32
The: %32
following: %32
routines: %32
are: %32
for: %32
Version: %32
7: %32
and: %32
System: %32
V: %32
UNIX: %32
systems
;: %32
they: %32
use: %32
the: %32
directory: %32
information: %32
in: %32
the: %32
header: %13
<
sys
/
dir
.
h
>
,: %32
which: %32
looks: %32
like: %32
this
:: %13
#
ifndef: %32
DIRSIZ: %13
#
define: %32
DIRSIZ: %32
1
4: %13
#
endif: %13
struct: %32
direct: %32
{: %13
/
*: %32
directory: %32
entry: %32
*
/: %13
ino
_
t: %32
d
_
ino
;: %13
/
*: %32
inode: %32
number: %32
*
/: %13
char: %32
d
_
name
[
DIRSIZ
]
;: %32
/
*: %32
long: %32
name: %32
does: %32
not: %32
have: %32
'
\
0
': %32
*
/: %13
Chapter: %32
8: %32
-: %32
The: %32
UNIX: %32
System: %32
Interface: %13
}
;: %13
Some: %32
versions: %32
of: %32
the: %32
system: %32
permit: %32
much: %32
longer: %32
names: %32
and: %32
have: %32
a: %32
more: %32
complicated: %32
directory: %32
structure
.: %13
The: %32
type: %32
ino
_
t: %32
is: %32
a: %32
typedef: %32
that: %32
describes: %32
the: %32
index: %32
into: %32
the: %32
inode: %32
list
.: %32
It: %32
happens: %32
to: %32
be: %32
unsigned: %32
short: %32
on: %32
the: %32
systems: %32
we: %32
use: %32
regularly
,: %32
but: %32
this: %32
is: %32
not: %32
the: %13
sort: %32
of: %32
information: %32
to: %32
embed: %32
in: %32
a: %32
program
;: %32
it: %32
might: %32
be: %32
different: %32
on: %32
a: %32
different: %32
system
,: %32
so: %32
the: %32
typedef: %32
is: %32
better
.: %32
A: %32
complete: %32
set: %32
of: %32
`
`
system
'
': %32
types: %32
is: %32
found: %32
in: %13
<
sys
/
types
.
h
>
.: %13
opendir: %32
opens: %32
the: %32
directory
,: %32
verifies: %32
that: %32
the: %32
file: %32
is: %32
a: %32
directory: %32
(
this: %32
time: %32
by: %32
the: %32
system: %32
call: %32
fstat
,: %32
which: %32
is: %32
like: %32
stat: %32
except: %32
that: %32
it: %32
applies: %32
to: %32
a: %32
file: %32
descriptor
)
,: %13
allocates: %32
a: %32
directory: %32
structure
,: %32
and: %32
records: %32
the: %32
information
:: %13
int: %32
fstat
(
int: %32
fd
,: %32
struct: %32
stat: %32
*
)
;: %13
/
*: %32
opendir
:: %32
open: %32
a: %32
directory: %32
for: %32
readdir: %32
calls: %32
*
/: %13
DIR: %32
*
opendir
(
char: %32
*
dirname
): %13
{: %13
int: %32
fd
;: %13
struct: %32
stat: %32
stbuf
;: %13
DIR: %32
*
dp
;: %13
if: %32
(
(
fd: %32
=: %32
open
(
dirname
,: %32
O
_
RDONLY
,: %32
0
)
): %32
=
=: %32
-
1: %13
|
|: %32
fstat
(
fd
,: %32
&
stbuf
): %32
=
=: %32
-
1: %13
|
|: %32
(
stbuf
.
st
_
mode: %32
&: %32
S
_
IFMT
): %32
!
=: %32
S
_
IFDIR: %13
|
|: %32
(
dp: %32
=: %32
(
DIR: %32
*
): %32
malloc
(
sizeof
(
DIR
)
)
): %32
=
=: %32
NULL
): %13
return: %32
NULL
;: %13
dp
-
>
fd: %32
=: %32
fd
;: %13
return: %32
dp
;: %13
}: %13
closedir: %32
closes: %32
the: %32
directory: %32
file: %32
and: %32
frees: %32
the: %32
space
:: %13
/
*: %32
closedir
:: %32
close: %32
directory: %32
opened: %32
by: %32
opendir: %32
*
/: %13
void: %32
closedir
(
DIR: %32
*
dp
): %13
{: %13
if: %32
(
dp
): %32
{: %13
close
(
dp
-
>
fd
)
;: %13
free
(
dp
)
;: %13
}: %13
}: %13
Finally
,: %32
readdir: %32
uses: %32
read: %32
to: %32
read: %32
each: %32
directory: %32
entry
.: %32
If: %32
a: %32
directory: %32
slot: %32
is: %32
not: %32
currently: %32
in: %32
use: %32
(
because: %32
a: %32
file: %32
has: %32
been: %32
removed
)
,: %32
the: %32
inode: %32
number: %32
is: %32
zero
,: %32
and: %13
this: %32
position: %32
is: %32
skipped
.: %32
Otherwise
,: %32
the: %32
inode: %32
number: %32
and: %32
name: %32
are: %32
placed: %32
in: %32
a: %32
static: %32
structure: %32
and: %32
a: %32
pointer: %32
to: %32
that: %32
is: %32
returned: %32
to: %32
the: %32
user
.: %32
Each: %32
call: %32
overwrites: %32
the: %13
Chapter: %32
8: %32
-: %32
The: %32
UNIX: %32
System: %32
Interface: %13
information: %32
from: %32
the: %32
previous: %32
one
.: %13
#
include: %32
<
sys
/
dir
.
h
>: %13
/
*: %32
local: %32
directory: %32
structure: %32
*
/: %13
/
*: %32
readdir
:: %32
read: %32
directory: %32
entries: %32
in: %32
sequence: %32
*
/: %13
Dirent: %32
*
readdir
(
DIR: %32
*
dp
): %13
{: %13
struct: %32
direct: %32
dirbuf
;: %32
/
*: %32
local: %32
directory: %32
structure: %32
*
/: %13
static: %32
Dirent: %32
d
;: %13
/
*: %32
return
:: %32
portable: %32
structure: %32
*
/: %13
while: %32
(
read
(
dp
-
>
fd
,: %32
(
char: %32
*
): %32
&
dirbuf
,: %32
sizeof
(
dirbuf
)
): %13
=
=: %32
sizeof
(
dirbuf
)
): %32
{: %13
if: %32
(
dirbuf
.
d
_
ino: %32
=
=: %32
0
): %32
/
*: %32
slot: %32
not: %32
in: %32
use: %32
*
/: %13
continue
;: %13
d
.
ino: %32
=: %32
dirbuf
.
d
_
ino
;: %13
strncpy
(
d
.
name
,: %32
dirbuf
.
d
_
name
,: %32
DIRSIZ
)
;: %13
d
.
name
[
DIRSIZ
]: %32
=: %32
'
\
0
'
;: %32
/
*: %32
ensure: %32
termination: %32
*
/: %13
return: %32
&
d
;: %13
}: %13
return: %32
NULL
;: %13
}: %13
Although: %32
the: %32
fsize: %32
program: %32
is: %32
rather: %32
specialized
,: %32
it: %32
does: %32
illustrate: %32
a: %32
couple: %32
of: %32
important: %32
ideas
.: %32
First
,: %32
many: %32
programs: %32
are: %32
not: %32
`
`
system: %32
programs
'
'
;: %32
they: %32
merely: %32
use: %13
information: %32
that: %32
is: %32
maintained: %32
by: %32
the: %32
operating: %32
system
.: %32
For: %32
such: %32
programs
,: %32
it: %32
is: %32
crucial: %32
that: %32
the: %32
representation: %32
of: %32
the: %32
information: %32
appear: %32
only: %32
in: %32
standard: %32
headers
,: %32
and: %13
that: %32
programs: %32
include: %32
those: %32
headers: %32
instead: %32
of: %32
embedding: %32
the: %32
declarations: %32
in: %32
themselves
.: %32
The: %32
second: %32
observation: %32
is: %32
that: %32
with: %32
care: %32
it: %32
is: %32
possible: %32
to: %32
create: %32
an: %32
interface: %13
to: %32
system
-
dependent: %32
objects: %32
that: %32
is: %32
itself: %32
relatively: %32
system
-
independent
.: %32
The: %32
functions: %32
of: %32
the: %32
standard: %32
library: %32
are: %32
good: %32
examples
.: %13
Exercise: %32
8
-
5
.: %32
Modify: %32
the: %32
fsize: %32
program: %32
to: %32
print: %32
the: %32
other: %32
information: %32
contained: %32
in: %32
the: %32
inode: %32
entry
.: %13
8
.
7: %32
Example: %32
-: %32
A: %32
Storage: %32
Allocator: %13
In: %32
Chapter: %32
5
,: %32
we: %32
presented: %32
a: %32
vary: %32
limited: %32
stack
-
oriented: %32
storage: %32
allocator
.: %32
The: %32
version: %32
that: %32
we: %32
will: %32
now: %32
write: %32
is: %32
unrestricted
.: %32
Calls: %32
to: %32
malloc: %32
and: %32
free: %32
may: %32
occur: %13
in: %32
any: %32
order
;: %32
malloc: %32
calls: %32
upon: %32
the: %32
operating: %32
system: %32
to: %32
obtain: %32
more: %32
memory: %32
as: %32
necessary
.: %32
These: %32
routines: %32
illustrate: %32
some: %32
of: %32
the: %32
considerations: %32
involved: %32
in: %32
writing: %13
machine
-
dependent: %32
code: %32
in: %32
a: %32
relatively: %32
machine
-
independent: %32
way
,: %32
and: %32
also: %32
show: %32
a: %32
real
-
life: %32
application: %32
of: %32
structures
,: %32
unions: %32
and: %32
typedef
.: %13
Rather: %32
than: %32
allocating: %32
from: %32
a: %32
compiled
-
in: %32
fixed
-
size: %32
array
,: %32
malloc: %32
will: %32
request: %32
space: %32
from: %32
the: %32
operating: %32
system: %32
as: %32
needed
.: %32
Since: %32
other: %32
activities: %32
in: %32
the: %32
program: %13
may: %32
also: %32
request: %32
space: %32
without: %32
calling: %32
this: %32
allocator
,: %32
the: %32
space: %32
that: %32
malloc: %32
manages: %32
may: %32
not: %32
be: %32
contiguous
.: %32
Thus: %32
its: %32
free: %32
storage: %32
is: %32
kept: %32
as: %32
a: %32
list: %32
of: %32
free: %32
blocks
.: %13
Each: %32
block: %32
contains: %32
a: %32
size
,: %32
a: %32
pointer: %32
to: %32
the: %32
next: %32
block
,: %32
and: %32
the: %32
space: %32
itself
.: %32
The: %32
blocks: %32
are: %32
kept: %32
in: %32
order: %32
of: %32
increasing: %32
storage: %32
address
,: %32
and: %32
the: %32
last: %32
block: %32
(
highest: %13
address
): %32
points: %32
to: %32
the: %32
first
.: %13
Chapter: %32
8: %32
-: %32
The: %32
UNIX: %32
System: %32
Interface: %13
When: %32
a: %32
request: %32
is: %32
made
,: %32
the: %32
free: %32
list: %32
is: %32
scanned: %32
until: %32
a: %32
big
-
enough: %32
block: %32
is: %32
found
.: %32
This: %32
algorithm: %32
is: %32
called: %32
`
`
first: %32
fit
,
'
': %32
by: %32
contrast: %32
with: %32
`
`
best: %32
fit
,
'
': %32
which: %32
looks: %32
for: %32
the: %13
smallest: %32
block: %32
that: %32
will: %32
satisfy: %32
the: %32
request
.: %32
If: %32
the: %32
block: %32
is: %32
exactly: %32
the: %32
size: %32
requested: %32
it: %32
is: %32
unlinked: %32
from: %32
the: %32
list: %32
and: %32
returned: %32
to: %32
the: %32
user
.: %32
If: %32
the: %32
block: %32
is: %32
too: %32
big
,: %32
it: %32
is: %13
split
,: %32
and: %32
the: %32
proper: %32
amount: %32
is: %32
returned: %32
to: %32
the: %32
user: %32
while: %32
the: %32
residue: %32
remains: %32
on: %32
the: %32
free: %32
list
.: %32
If: %32
no: %32
big
-
enough: %32
block: %32
is: %32
found
,: %32
another: %32
large: %32
chunk: %32
is: %32
obtained: %32
by: %32
the: %13
operating: %32
system: %32
and: %32
linked: %32
into: %32
the: %32
free: %32
list
.: %13
Freeing: %32
also: %32
causes: %32
a: %32
search: %32
of: %32
the: %32
free: %32
list
,: %32
to: %32
find: %32
the: %32
proper: %32
place: %32
to: %32
insert: %32
the: %32
block: %32
being: %32
freed
.: %32
If: %32
the: %32
block: %32
being: %32
freed: %32
is: %32
adjacent: %32
to: %32
a: %32
free: %32
block: %32
on: %32
either: %32
side
,: %32
it: %13
is: %32
coalesced: %32
with: %32
it: %32
into: %32
a: %32
single: %32
bigger: %32
block
,: %32
so: %32
storage: %32
does: %32
not: %32
become: %32
too: %32
fragmented
.: %32
Determining: %32
the: %32
adjacency: %32
is: %32
easy: %32
because: %32
the: %32
free: %32
list: %32
is: %32
maintained: %32
in: %13
order: %32
of: %32
decreasing: %32
address
.: %13
One: %32
problem
,: %32
which: %32
we: %32
alluded: %32
to: %32
in: %32
Chapter: %32
5
,: %32
is: %32
to: %32
ensure: %32
that: %32
the: %32
storage: %32
returned: %32
by: %32
malloc: %32
is: %32
aligned: %32
properly: %32
for: %32
the: %32
objects: %32
that: %32
will: %32
be: %32
stored: %32
in: %32
it
.: %32
Although: %13
machines: %32
vary
,: %32
for: %32
each: %32
machine: %32
there: %32
is: %32
a: %32
most: %32
restrictive: %32
type
:: %32
if: %32
the: %32
most: %32
restrictive: %32
type: %32
can: %32
be: %32
stored: %32
at: %32
a: %32
particular: %32
address
,: %32
all: %32
other: %32
types: %32
may: %32
be: %32
also
.: %32
On: %32
some: %13
machines
,: %32
the: %32
most: %32
restrictive: %32
type: %32
is: %32
a: %32
double
;: %32
on: %32
others
,: %32
int: %32
or: %32
long: %32
suffices
.: %13
A: %32
free: %32
block: %32
contains: %32
a: %32
pointer: %32
to: %32
the: %32
next: %32
block: %32
in: %32
the: %32
chain
,: %32
a: %32
record: %32
of: %32
the: %32
size: %32
of: %32
the: %32
block
,: %32
and: %32
then: %32
the: %32
free: %32
space: %32
itself
;: %32
the: %32
control: %32
information: %32
at: %32
the: %32
beginning: %13
is: %32
called: %32
the: %32
`
`
header
.
'
': %32
To: %32
simplify: %32
alignment
,: %32
all: %32
blocks: %32
are: %32
multiples: %32
of: %32
the: %32
header: %32
size
,: %32
and: %32
the: %32
header: %32
is: %32
aligned: %32
properly
.: %32
This: %32
is: %32
achieved: %32
by: %32
a: %32
union: %32
that: %32
contains: %13
the: %32
desired: %32
header: %32
structure: %32
and: %32
an: %32
instance: %32
of: %32
the: %32
most: %32
restrictive: %32
alignment: %32
type
,: %32
which: %32
we: %32
have: %32
arbitrarily: %32
made: %32
a: %32
long
:: %13
typedef: %32
long: %32
Align
;: %32
/
*: %32
for: %32
alignment: %32
to: %32
long: %32
boundary: %32
*
/: %13
union: %32
header: %32
{: %32
/
*: %32
block: %32
header: %32
*
/: %13
Chapter: %32
8: %32
-: %32
The: %32
UNIX: %32
System: %32
Interface: %13
struct: %32
{: %13
union: %32
header: %32
*
ptr
;: %32
/
*: %32
next: %32
block: %32
if: %32
on: %32
free: %32
list: %32
*
/: %13
unsigned: %32
size
;: %13
/
*: %32
size: %32
of: %32
this: %32
block: %32
*
/: %13
}: %32
s
;: %13
Align: %32
x
;: %13
/
*: %32
force: %32
alignment: %32
of: %32
blocks: %32
*
/: %13
}
;: %13
typedef: %32
union: %32
header: %32
Header
;: %13
The: %32
Align: %32
field: %32
is: %32
never: %32
used
;: %32
it: %32
just: %32
forces: %32
each: %32
header: %32
to: %32
be: %32
aligned: %32
on: %32
a: %32
worst
-
case: %32
boundary
.: %13
In: %32
malloc
,: %32
the: %32
requested: %32
size: %32
in: %32
characters: %32
is: %32
rounded: %32
up: %32
to: %32
the: %32
proper: %32
number: %32
of: %32
header
-
sized: %32
units
;: %32
the: %32
block: %32
that: %32
will: %32
be: %32
allocated: %32
contains: %32
one: %32
more: %32
unit
,: %32
for: %32
the: %13
header: %32
itself
,: %32
and: %32
this: %32
is: %32
the: %32
value: %32
recorded: %32
in: %32
the: %32
size: %32
field: %32
of: %32
the: %32
header
.: %32
The: %32
pointer: %32
returned: %32
by: %32
malloc: %32
points: %32
at: %32
the: %32
free: %32
space
,: %32
not: %32
at: %32
the: %32
header: %32
itself
.: %32
The: %32
user: %13
can: %32
do: %32
anything: %32
with: %32
the: %32
space: %32
requested
,: %32
but: %32
if: %32
anything: %32
is: %32
written: %32
outside: %32
of: %32
the: %32
allocated: %32
space: %32
the: %32
list: %32
is: %32
likely: %32
to: %32
be: %32
scrambled
.: %13
The: %32
size: %32
field: %32
is: %32
necessary: %32
because: %32
the: %32
blocks: %32
controlled: %32
by: %32
malloc: %32
need: %32
not: %32
be: %32
contiguous: %32
-: %32
it: %32
is: %32
not: %32
possible: %32
to: %32
compute: %32
sizes: %32
by: %32
pointer: %32
arithmetic
.: %13
The: %32
variable: %32
base: %32
is: %32
used: %32
to: %32
get: %32
started
.: %32
If: %32
freep: %32
is: %32
NULL
,: %32
as: %32
it: %32
is: %32
at: %32
the: %32
first: %32
call: %32
of: %32
malloc
,: %32
then: %32
a: %32
degenerate: %32
free: %32
list: %32
is: %32
created
;: %32
it: %32
contains: %32
one: %32
block: %32
of: %32
size: %13
zero
,: %32
and: %32
points: %32
to: %32
itself
.: %32
In: %32
any: %32
case
,: %32
the: %32
free: %32
list: %32
is: %32
then: %32
searched
.: %32
The: %32
search: %32
for: %32
a: %32
free: %32
block: %32
of: %32
adequate: %32
size: %32
begins: %32
at: %32
the: %32
point: %32
(
freep
): %32
where: %32
the: %32
last: %32
block: %32
was: %13
found
;: %32
this: %32
strategy: %32
helps: %32
keep: %32
the: %32
list: %32
homogeneous
.: %32
If: %32
a: %32
too
-
big: %32
block: %32
is: %32
found
,: %32
the: %32
tail: %32
end: %32
is: %32
returned: %32
to: %32
the: %32
user
;: %32
in: %32
this: %32
way: %32
the: %32
header: %32
of: %32
the: %32
original: %32
needs: %32
only: %13
to: %32
have: %32
its: %32
size: %32
adjusted
.: %32
In: %32
all: %32
cases
,: %32
the: %32
pointer: %32
returned: %32
to: %32
the: %32
user: %32
points: %32
to: %32
the: %32
free: %32
space: %32
within: %32
the: %32
block
,: %32
which: %32
begins: %32
one: %32
unit: %32
beyond: %32
the: %32
header
.: %13
static: %32
Header: %32
base
;: %13
/
*: %32
empty: %32
list: %32
to: %32
get: %32
started: %32
*
/: %13
static: %32
Header: %32
*
freep: %32
=: %32
NULL
;: %13
/
*: %32
start: %32
of: %32
free: %32
list: %32
*
/: %13
/
*: %32
malloc
:: %32
general
-
purpose: %32
storage: %32
allocator: %32
*
/: %13
void: %32
*
malloc
(
unsigned: %32
nbytes
): %13
{: %13
Header: %32
*
p
,: %32
*
prevp
;: %13
Chapter: %32
8: %32
-: %32
The: %32
UNIX: %32
System: %32
Interface: %13
Header: %32
*
moreroce
(
unsigned
)
;: %13
unsigned: %32
nunits
;: %13
nunits: %32
=: %32
(
nbytes
+
sizeof
(
Header
)
-
1
)
/
sizeof
(
header
): %32
+: %32
1
;: %13
if: %32
(
(
prevp: %32
=: %32
freep
): %32
=
=: %32
NULL
): %32
{: %13
/
*: %32
no: %32
free: %32
list: %32
yet: %32
*
/: %13
base
.
s
.
ptr: %32
=: %32
freeptr: %32
=: %32
prevptr: %32
=: %32
&
base
;: %13
base
.
s
.
size: %32
=: %32
0
;: %13
}: %13
for: %32
(
p: %32
=: %32
prevp
-
>
s
.
ptr
;: %32
;: %32
prevp: %32
=: %32
p
,: %32
p: %32
=: %32
p
-
>
s
.
ptr
): %32
{: %13
if: %32
(
p
-
>
s
.
size: %32
>
=: %32
nunits
): %32
{: %32
/
*: %32
big: %32
enough: %32
*
/: %13
if: %32
(
p
-
>
s
.
size: %32
=
=: %32
nunits
): %32
/
*: %32
exactly: %32
*
/: %13
prevp
-
>
s
.
ptr: %32
=: %32
p
-
>
s
.
ptr
;: %13
else: %32
{: %13
/
*: %32
allocate: %32
tail: %32
end: %32
*
/: %13
p
-
>
s
.
size: %32
-
=: %32
nunits
;: %13
p: %32
+
=: %32
p
-
>
s
.
size
;: %13
p
-
>
s
.
size: %32
=: %32
nunits
;: %13
}: %13
freep: %32
=: %32
prevp
;: %13
return: %32
(
void: %32
*
)
(
p
+
1
)
;: %13
}: %13
if: %32
(
p: %32
=
=: %32
freep
): %32
/
*: %32
wrapped: %32
around: %32
free: %32
list: %32
*
/: %13
if: %32
(
(
p: %32
=: %32
morecore
(
nunits
)
): %32
=
=: %32
NULL
): %13
return: %32
NULL
;: %13
/
*: %32
none: %32
left: %32
*
/: %13
}: %13
}: %13
The: %32
function: %32
morecore: %32
obtains: %32
storage: %32
from: %32
the: %32
operating: %32
system
.: %32
The: %32
details: %32
of: %32
how: %32
it: %32
does: %32
this: %32
vary: %32
from: %32
system: %32
to: %32
system
.: %32
Since: %32
asking: %32
the: %32
system: %32
for: %32
memory: %13
is: %32
a: %32
comparatively: %32
expensive: %32
operation
.: %32
we: %32
don
'
t: %32
want: %32
to: %32
do: %32
that: %32
on: %32
every: %32
call: %32
to: %32
malloc
,: %32
so: %32
morecore: %32
requests: %32
al: %32
least: %32
NALLOC: %32
units
;: %32
this: %32
larger: %32
block: %32
will: %32
be: %13
chopped: %32
up: %32
as: %32
needed
.: %32
After: %32
setting: %32
the: %32
size: %32
field
,: %32
morecore: %32
inserts: %32
the: %32
additional: %32
memory: %32
into: %32
the: %32
arena: %32
by: %32
calling: %32
free
.: %13
The: %32
UNIX: %32
system: %32
call: %32
sbrk
(
n
): %32
returns: %32
a: %32
pointer: %32
to: %32
n: %32
more: %32
bytes: %32
of: %32
storage
.: %32
sbrk: %32
returns: %32
-
1: %32
if: %32
there: %32
was: %32
no: %32
space
,: %32
even: %32
though: %32
NULL: %32
could: %32
have: %32
been: %32
a: %32
better: %13
design
.: %32
The: %32
-
1: %32
must: %32
be: %32
cast: %32
to: %32
char: %32
*: %32
so: %32
it: %32
can: %32
be: %32
compared: %32
with: %32
the: %32
return: %32
value
.: %32
Again
,: %32
casts: %32
make: %32
the: %32
function: %32
relatively: %32
immune: %32
to: %32
the: %32
details: %32
of: %32
pointer: %13
representation: %32
on: %32
different: %32
machines
.: %32
There: %32
is: %32
still: %32
one: %32
assumption
,: %32
however
,: %32
that: %32
pointers: %32
to: %32
different: %32
blocks: %32
returned: %32
by: %32
sbrk: %32
can: %32
be: %32
meaningfully: %32
compared
.: %32
This: %13
is: %32
not: %32
guaranteed: %32
by: %32
the: %32
standard
,: %32
which: %32
permits: %32
pointer: %32
comparisons: %32
only: %32
within: %32
an: %32
array
.: %32
Thus: %32
this: %32
version: %32
of: %32
malloc: %32
is: %32
portable: %32
only: %32
among: %32
machines: %32
for: %32
which: %13
general: %32
pointer: %32
comparison: %32
is: %32
meaningful
.: %13
#
define: %32
NALLOC: %13
1
0
2
4: %13
/
*: %32
minimum: %32
#
units: %32
to: %32
request: %32
*
/: %13
/
*: %32
morecore
:: %32
ask: %32
system: %32
for: %32
more: %32
memory: %32
*
/: %13
static: %32
Header: %32
*
morecore
(
unsigned: %32
nu
): %13
{: %13
char: %32
*
cp
,: %32
*
sbrk
(
int
)
;: %13
Header: %32
*
up
;: %13
Chapter: %32
8: %32
-: %32
The: %32
UNIX: %32
System: %32
Interface: %13
if: %32
(
nu: %32
<: %32
NALLOC
): %13
nu: %32
=: %32
NALLOC
;: %13
cp: %32
=: %32
sbrk
(
nu: %32
*: %32
sizeof
(
Header
)
)
;: %13
if: %32
(
cp: %32
=
=: %32
(
char: %32
*
): %32
-
1
): %13
/
*: %32
no: %32
space: %32
at: %32
all: %32
*
/: %13
return: %32
NULL
;: %13
up: %32
=: %32
(
Header: %32
*
): %32
cp
;: %13
up
-
>
s
.
size: %32
=: %32
nu
;: %13
free
(
(
void: %32
*
)
(
up
+
1
)
)
;: %13
return: %32
freep
;: %13
}: %13
free: %32
itself: %32
is: %32
the: %32
last: %32
thing
.: %32
It: %32
scans: %32
the: %32
free: %32
list
,: %32
starting: %32
at: %32
freep
,: %32
looking: %32
for: %32
the: %32
place: %32
to: %32
insert: %32
the: %32
free: %32
block
.: %32
This: %32
is: %32
either: %32
between: %32
two: %32
existing: %32
blocks: %32
or: %32
at: %32
the: %13
end: %32
of: %32
the: %32
list
.: %32
In: %32
any: %32
case
,: %32
if: %32
the: %32
block: %32
being: %32
freed: %32
is: %32
adjacent: %32
to: %32
either: %32
neighbor
,: %32
the: %32
adjacent: %32
blocks: %32
are: %32
combined
.: %32
The: %32
only: %32
troubles: %32
are: %32
keeping: %32
the: %32
pointers: %13
pointing: %32
to: %32
the: %32
right: %32
things: %32
and: %32
the: %32
sizes: %32
correct
.: %13
/
*: %32
free
:: %32
put: %32
block: %32
ap: %32
in: %32
free: %32
list: %32
*
/: %13
void: %32
free
(
void: %32
*
ap
): %13
{: %13
Header: %32
*
bp
,: %32
*
p
;: %13
bp: %32
=: %32
(
Header: %32
*
)
ap: %32
-: %32
1
;: %13
/
*: %32
point: %32
to: %32
block: %32
header: %32
*
/: %13
for: %32
(
p: %32
=: %32
freep
;: %32
!
(
bp: %32
>: %32
p: %32
&
&: %32
bp: %32
<: %32
p
-
>
s
.
ptr
)
;: %32
p: %32
=: %32
p
-
>
s
.
ptr
): %13
if: %32
(
p: %32
>
=: %32
p
-
>
s
.
ptr: %32
&
&: %32
(
bp: %32
>: %32
p: %32
|
|: %32
bp: %32
<: %32
p
-
>
s
.
ptr
)
): %13
break
;: %32
/
*: %32
freed: %32
block: %32
at: %32
start: %32
or: %32
end: %32
of: %32
arena: %32
*
/: %13
if: %32
(
bp: %32
+: %32
bp
-
>
size: %32
=
=: %32
p
-
>
s
.
ptr
): %32
{: %13
/
*: %32
join: %32
to: %32
upper: %32
nbr: %32
*
/: %13
bp
-
>
s
.
size: %32
+
=: %32
p
-
>
s
.
ptr
-
>
s
.
size
;: %13
bp
-
>
s
.
ptr: %32
=: %32
p
-
>
s
.
ptr
-
>
s
.
ptr
;: %13
}: %32
else: %13
bp
-
>
s
.
ptr: %32
=: %32
p
-
>
s
.
ptr
;: %13
if: %32
(
p: %32
+: %32
p
-
>
size: %32
=
=: %32
bp
): %32
{: %13
/
*: %32
join: %32
to: %32
lower: %32
nbr: %32
*
/: %13
p
-
>
s
.
size: %32
+
=: %32
bp
-
>
s
.
size
;: %13
p
-
>
s
.
ptr: %32
=: %32
bp
-
>
s
.
ptr
;: %13
}: %32
else: %13
p
-
>
s
.
ptr: %32
=: %32
bp
;: %13
freep: %32
=: %32
p
;: %13
}: %13
Although: %32
storage: %32
allocation: %32
is: %32
intrinsically: %32
machine
-
dependent
,: %32
the: %32
code: %32
above: %32
illustrates: %32
how: %32
the: %32
machine: %32
dependencies: %32
can: %32
be: %32
controlled: %32
and: %32
confined: %32
to: %32
a: %32
very: %13
small: %32
part: %32
of: %32
the: %32
program
.: %32
The: %32
use: %32
of: %32
typedef: %32
and: %32
union: %32
handles: %32
alignment: %32
(
given: %32
that: %32
sbrk: %32
supplies: %32
an: %32
appropriate: %32
pointer
)
.: %32
Casts: %32
arrange: %32
that: %32
pointer: %13
conversions: %32
are: %32
made: %32
explicit
,: %32
and: %32
even: %32
cope: %32
with: %32
a: %32
badly
-
designed: %32
system: %32
interface
.: %32
Even: %32
though: %32
the: %32
details: %32
here: %32
are: %32
related: %32
to: %32
storage: %32
allocation
,: %32
the: %32
general: %13
approach: %32
is: %32
applicable: %32
to: %32
other: %32
situations: %32
as: %32
well
.: %13
Chapter: %32
8: %32
-: %32
The: %32
UNIX: %32
System: %32
Interface: %13
Exercise: %32
8
-
6
.: %32
The: %32
standard: %32
library: %32
function: %32
calloc
(
n
,
size
): %32
returns: %32
a: %32
pointer: %32
to: %32
n: %32
objects: %32
of: %32
size: %32
size
,: %32
with: %32
the: %32
storage: %32
initialized: %32
to: %32
zero
.: %32
Write: %32
calloc
,: %32
by: %13
calling: %32
malloc: %32
or: %32
by: %32
modifying: %32
it
.: %13
Exercise: %32
8
-
7
.: %32
malloc: %32
accepts: %32
a: %32
size: %32
request: %32
without: %32
checking: %32
its: %32
plausibility
;: %32
free: %32
believes: %32
that: %32
the: %32
block: %32
it: %32
is: %32
asked: %32
to: %32
free: %32
contains: %32
a: %32
valid: %32
size: %32
field
.: %32
Improve: %13
these: %32
routines: %32
so: %32
they: %32
make: %32
more: %32
pains: %32
with: %32
error: %32
checking
.: %13
Exercise: %32
8
-
8
.: %32
Write: %32
a: %32
routine: %32
bfree
(
p
,
n
): %32
that: %32
will: %32
free: %32
any: %32
arbitrary: %32
block: %32
p: %32
of: %32
n: %32
characters: %32
into: %32
the: %32
free: %32
list: %32
maintained: %32
by: %32
malloc: %32
and: %32
free
.: %32
By: %32
using: %13
bfree
,: %32
a: %32
user: %32
can: %32
add: %32
a: %32
static: %32
or: %32
external: %32
array: %32
to: %32
the: %32
free: %32
list: %32
at: %32
any: %32
time
.: %13
Back: %32
to: %32
Chapter: %32
7: %32
-
-: %32
Index: %32
-
-: %32
Appendix: %32
A: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
Back: %32
to: %32
Chapter: %32
8: %32
-
-: %32
Index: %32
-
-: %32
Appendix: %32
B: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
A
.
1: %32
Introduction: %13
This: %32
manual: %32
describes: %32
the: %32
C: %32
language: %32
specified: %32
by: %32
the: %32
draft: %32
submitted: %32
to: %32
ANSI: %32
on: %32
3
1: %32
October
,: %32
1
9
8
8
,: %32
for: %13
approval: %32
as: %32
`
`
American: %32
Standard: %32
for: %32
Information: %32
Systems: %32
-: %32
programming: %32
Language: %32
C
,: %32
X
3
.
1
5
9
-
1
9
8
9
.
'
': %13
The: %32
manual: %32
is: %32
an: %32
interpretation: %32
of: %32
the: %32
proposed: %32
standard
,: %32
not: %32
the: %32
standard: %32
itself
,: %32
although: %32
care: %32
has: %32
been: %13
taken: %32
to: %32
make: %32
it: %32
a: %32
reliable: %32
guide: %32
to: %32
the: %32
language
.: %13
For: %32
the: %32
most: %32
part
,: %32
this: %32
document: %32
follows: %32
the: %32
broad: %32
outline: %32
of: %32
the: %32
standard
,: %32
which: %32
in: %32
turn: %32
follows: %32
that: %32
of: %13
the: %32
first: %32
edition: %32
of: %32
this: %32
book
,: %32
although: %32
the: %32
organization: %32
differs: %32
in: %32
detail
.: %32
Except: %32
for: %32
renaming: %32
a: %32
few: %13
productions
,: %32
and: %32
not: %32
formalizing: %32
the: %32
definitions: %32
of: %32
the: %32
lexical: %32
tokens: %32
or: %32
the: %32
preprocessor
,: %32
the: %32
grammar: %13
given: %32
here: %32
for: %32
the: %32
language: %32
proper: %32
is: %32
equivalent: %32
to: %32
that: %32
of: %32
the: %32
standard
.: %13
Throughout: %32
this: %32
manual
,: %32
commentary: %32
material: %32
is: %32
indented: %32
and: %32
written: %32
in: %32
smaller: %32
type
,: %32
as: %32
this: %32
is
.: %32
Most: %32
often: %32
these: %13
comments: %32
highlight: %32
ways: %32
in: %32
which: %32
ANSI: %32
Standard: %32
C: %32
differs: %32
from: %32
the: %32
language: %32
defined: %32
by: %32
the: %32
first: %32
edition: %32
of: %32
this: %13
book
,: %32
or: %32
from: %32
refinements: %32
subsequently: %32
introduced: %32
in: %32
various: %32
compilers
.: %13
A
.
2: %32
Lexical: %32
Conventions: %13
A: %32
program: %32
consists: %32
of: %32
one: %32
or: %32
more: %32
translation: %32
units: %32
stored: %32
in: %32
files
.: %32
It: %32
is: %32
translated: %32
in: %32
several: %32
phases
,: %13
which: %32
are: %32
described: %32
in: %32
Par
.
A
.
1
2
.: %32
The: %32
first: %32
phases: %32
do: %32
low
-
level: %32
lexical: %32
transformations
,: %32
carry: %32
out: %13
directives: %32
introduced: %32
by: %32
the: %32
lines: %32
beginning: %32
with: %32
the: %32
#: %32
character
,: %32
and: %32
perform: %32
macro: %32
definition: %32
and: %13
expansion
.: %32
When: %32
the: %32
preprocessing: %32
of: %32
Par
.
A
.
1
2: %32
is: %32
complete
,: %32
the: %32
program: %32
has: %32
been: %32
reduced: %32
to: %32
a: %32
sequence: %13
of: %32
tokens
.: %13
A
.
2
.
1: %32
Tokens: %13
There: %32
are: %32
six: %32
classes: %32
of: %32
tokens
:: %32
identifiers
,: %32
keywords
,: %32
constants
,: %32
string: %32
literals
,: %32
operators
,: %32
and: %32
other: %13
separators
.: %32
Blanks
,: %32
horizontal: %32
and: %32
vertical: %32
tabs
,: %32
newlines
,: %32
formfeeds: %32
and: %32
comments: %32
as: %32
described: %32
below: %13
(
collectively
,: %32
`
`
white: %32
space
'
'
): %32
are: %32
ignored: %32
except: %32
as: %32
they: %32
separate: %32
tokens
.: %32
Some: %32
white: %32
space: %32
is: %32
required: %32
to: %13
separate: %32
otherwise: %32
adjacent: %32
identifiers
,: %32
keywords
,: %32
and: %32
constants
.: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
If: %32
the: %32
input: %32
stream: %32
has: %32
been: %32
separated: %32
into: %32
tokens: %32
up: %32
to: %32
a: %32
given: %32
character
,: %32
the: %32
next: %32
token: %32
is: %32
the: %32
longest: %13
string: %32
of: %32
characters: %32
that: %32
could: %32
constitute: %32
a: %32
token
.: %13
A
.
2
.
2: %32
Comments: %13
The: %32
characters: %32
/
*: %32
introduce: %32
a: %32
comment
,: %32
which: %32
terminates: %32
with: %32
the: %32
characters: %32
*
/
.: %32
Comments: %32
do: %32
not: %13
nest
,: %32
and: %32
they: %32
do: %32
not: %32
occur: %32
within: %32
a: %32
string: %32
or: %32
character: %32
literals
.: %13
A
.
2
.
3: %32
Identifiers: %13
An: %32
identifier: %32
is: %32
a: %32
sequence: %32
of: %32
letters: %32
and: %32
digits
.: %32
The: %32
first: %32
character: %32
must: %32
be: %32
a: %32
letter
;: %32
the: %32
underscore: %32
_: %13
counts: %32
as: %32
a: %32
letter
.: %32
Upper: %32
and: %32
lower: %32
case: %32
letters: %32
are: %32
different
.: %32
Identifiers: %32
may: %32
have: %32
any: %32
length
,: %32
and: %32
for: %13
internal: %32
identifiers
,: %32
at: %32
least: %32
the: %32
first: %32
3
1: %32
characters: %32
are: %32
significant
;: %32
some: %32
implementations: %32
may: %32
take: %32
more: %13
characters: %32
significant
.: %32
Internal: %32
identifiers: %32
include: %32
preprocessor: %32
macro: %32
names: %32
and: %32
all: %32
other: %32
names: %32
that: %32
do: %13
not: %32
have: %32
external: %32
linkage: %32
(
Par
.
A
.
1
1
.
2
)
.: %32
Identifiers: %32
with: %32
external: %32
linkage: %32
are: %32
more: %32
restricted
:: %13
implementations: %32
may: %32
make: %32
as: %32
few: %32
as: %32
the: %32
first: %32
six: %32
characters: %32
significant
,: %32
and: %32
may: %32
ignore: %32
case: %13
distinctions
.: %13
A
.
2
.
4: %32
Keywords: %13
The: %32
following: %32
identifiers: %32
are: %32
reserved: %32
for: %32
the: %32
use: %32
as: %32
keywords
,: %32
and: %32
may: %32
not: %32
be: %32
used: %32
otherwise
:: %13
auto: %13
break: %13
case: %13
char: %13
const: %13
continue: %13
default: %13
do: %13
double: %13
else: %13
enum: %13
extern: %13
float: %13
for: %13
goto: %13
if: %13
int: %13
long: %13
register: %13
return: %13
short: %13
signed: %13
sizeof: %13
static: %13
struct: %13
switch: %13
typedef: %13
union: %13
unsigned: %13
void: %13
volatile: %13
while: %13
Some: %32
implementations: %32
also: %32
reserve: %32
the: %32
words: %32
fortran: %32
and: %32
asm
.: %13
The: %32
keywords: %32
const
,: %32
signed
,: %32
and: %32
volatile: %32
are: %32
new: %32
with: %32
the: %32
ANSI: %32
standard
;: %32
enum: %32
and: %32
void: %32
are: %32
new: %13
since: %32
the: %32
first: %32
edition
,: %32
but: %32
in: %32
common: %32
use
;: %32
entry
,: %32
formerly: %32
reserved: %32
but: %32
never: %32
used
,: %32
is: %32
no: %32
longer: %32
reserved
.: %13
A
.
2
.
5: %32
Constants: %13
There: %32
are: %32
several: %32
kinds: %32
of: %32
constants
.: %32
Each: %32
has: %32
a: %32
data: %32
type
;: %32
Par
.
A
.
4
.
2: %32
discusses: %32
the: %32
basic: %32
types
:: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
constant
:: %13
integer
-
constant: %13
character
-
constant: %13
floating
-
constant: %13
enumeration
-
constant: %13
A
.
2
.
5
.
1: %32
Integer: %32
Constants: %13
An: %32
integer: %32
constant: %32
consisting: %32
of: %32
a: %32
sequence: %32
of: %32
digits: %32
is: %32
taken: %32
to: %32
be: %32
octal: %32
if: %32
it: %32
begins: %32
with: %32
0: %32
(
digit: %32
zero
)
,: %13
decimal: %32
otherwise
.: %32
Octal: %32
constants: %32
do: %32
not: %32
contain: %32
the: %32
digits: %32
8: %32
or: %32
9
.: %32
A: %32
sequence: %32
of: %32
digits: %32
preceded: %32
by: %32
0
x: %13
or: %32
0
X: %32
(
digit: %32
zero
): %32
is: %32
taken: %32
to: %32
be: %32
a: %32
hexadecimal: %32
integer
.: %32
The: %32
hexadecimal: %32
digits: %32
include: %32
a: %32
or: %32
A: %32
through: %32
f: %13
or: %32
F: %32
with: %32
values: %32
1
0: %32
through: %32
1
5
.: %13
An: %32
integer: %32
constant: %32
may: %32
be: %32
suffixed: %32
by: %32
the: %32
letter: %32
u: %32
or: %32
U
,: %32
to: %32
specify: %32
that: %32
it: %32
is: %32
unsigned
.: %32
It: %32
may: %32
also: %32
be: %13
suffixed: %32
by: %32
the: %32
letter: %32
l: %32
or: %32
L: %32
to: %32
specify: %32
that: %32
it: %32
is: %32
long
.: %13
The: %32
type: %32
of: %32
an: %32
integer: %32
constant: %32
depends: %32
on: %32
its: %32
form
,: %32
value: %32
and: %32
suffix
.: %32
(
See: %32
Par
.
A
.
4: %32
for: %32
a: %32
discussion: %32
of: %13
types
)
.: %32
If: %32
it: %32
is: %32
unsuffixed: %32
and: %32
decimal
,: %32
it: %32
has: %32
the: %32
first: %32
of: %32
these: %32
types: %32
in: %32
which: %32
its: %32
value: %32
can: %32
be: %32
represented
:: %13
int
,: %32
long: %32
int
,: %32
unsigned: %32
long: %32
int
.: %32
If: %32
it: %32
is: %32
unsuffixed
,: %32
octal: %32
or: %32
hexadecimal
,: %32
it: %32
has: %32
the: %32
first: %13
possible: %32
of: %32
these: %32
types
:: %32
int
,: %32
unsigned: %32
int
,: %32
long: %32
int
,: %32
unsigned: %32
long: %32
int
.: %32
If: %32
it: %32
is: %32
suffixed: %13
by: %32
u: %32
or: %32
U
,: %32
then: %32
unsigned: %32
int
,: %32
unsigned: %32
long: %32
int
.: %32
If: %32
it: %32
is: %32
suffixed: %32
by: %32
l: %32
or: %32
L
,: %32
then: %32
long: %32
int
,: %13
unsigned: %32
long: %32
int
.: %32
If: %32
an: %32
integer: %32
constant: %32
is: %32
suffixed: %32
by: %32
UL
,: %32
it: %32
is: %32
unsigned: %32
long
.: %13
The: %32
elaboration: %32
of: %32
the: %32
types: %32
of: %32
integer: %32
constants: %32
goes: %32
considerably: %32
beyond: %32
the: %32
first: %32
edition
,: %32
which: %32
merely: %32
caused: %13
large: %32
integer: %32
constants: %32
to: %32
be: %32
long
.: %32
The: %32
U: %32
suffixes: %32
are: %32
new
.: %13
A
.
2
.
5
.
2: %32
Character: %32
Constants: %13
A: %32
character: %32
constant: %32
is: %32
a: %32
sequence: %32
of: %32
one: %32
or: %32
more: %32
characters: %32
enclosed: %32
in: %32
single: %32
quotes: %32
as: %32
in: %32
'
x
'
.: %32
The: %13
value: %32
of: %32
a: %32
character: %32
constant: %32
with: %32
only: %32
one: %32
character: %32
is: %32
the: %32
numeric: %32
value: %32
of: %32
the: %32
character: %32
in: %32
the: %13
machine
'
s: %32
character: %32
set: %32
at: %32
execution: %32
time
.: %32
The: %32
value: %32
of: %32
a: %32
multi
-
character: %32
constant: %32
is: %32
implementation
-: %13
defined
.: %13
Character: %32
constants: %32
do: %32
not: %32
contain: %32
the: %32
': %32
character: %32
or: %32
newlines
;: %32
in: %32
order: %32
to: %32
represent: %32
them
,: %32
and: %32
certain: %13
other: %32
characters
,: %32
the: %32
following: %32
escape: %32
sequences: %32
may: %32
be: %32
used
:: %13
newline: %13
NL: %32
(
LF
): %32
\
n: %13
backslash: %13
\: %32
\
\: %13
horizontal: %32
tab: %32
HT: %32
\
t: %32
question: %32
mark: %32
?: %32
\
?: %13
vertical: %32
tab: %32
VT: %32
\
v: %32
single: %32
quote: %32
': %32
\
': %13
backspace: %32
BS: %32
\
b: %32
double: %32
quote: %32
": %32
\
": %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
carriage: %32
return: %32
CR: %32
\
r: %32
octal: %32
number: %32
ooo: %32
\
ooo: %13
formfeed: %32
FF: %32
\
f: %32
hex: %32
number: %13
audible: %32
alert: %32
BEL: %32
\
a: %32%13
hh: %13
\
xhh: %13
The: %32
escape: %32
\
ooo: %32
consists: %32
of: %32
the: %32
backslash: %32
followed: %32
by: %32
1
,: %32
2
,: %32
or: %32
3: %32
octal: %32
digits
,: %32
which: %32
are: %32
taken: %32
to: %32
specify: %13
the: %32
value: %32
of: %32
the: %32
desired: %32
character
.: %32
A: %32
common: %32
example: %32
of: %32
this: %32
construction: %32
is: %32
\
0: %32
(
not: %32
followed: %32
by: %32
a: %13
digit
)
,: %32
which: %32
specifies: %32
the: %32
character: %32
NUL
.: %32
The: %32
escape: %32
\
xhh: %32
consists: %32
of: %32
the: %32
backslash
,: %32
followed: %32
by: %32
x
,: %13
followed: %32
by: %32
hexadecimal: %32
digits
,: %32
which: %32
are: %32
taken: %32
to: %32
specify: %32
the: %32
value: %32
of: %32
the: %32
desired: %32
character
.: %32
There: %32
is: %32
no: %13
limit: %32
on: %32
the: %32
number: %32
of: %32
digits
,: %32
but: %32
the: %32
behavior: %32
is: %32
undefined: %32
if: %32
the: %32
resulting: %32
character: %32
value: %32
exceeds: %32
that: %13
of: %32
the: %32
largest: %32
character
.: %32
For: %32
either: %32
octal: %32
or: %32
hexadecimal: %32
escape: %32
characters
,: %32
if: %32
the: %32
implementation: %32
treats: %13
the: %32
char: %32
type: %32
as: %32
signed
,: %32
the: %32
value: %32
is: %32
sign
-
extended: %32
as: %32
if: %32
cast: %32
to: %32
char: %32
type
.: %32
If: %32
the: %32
character: %32
following: %32
the: %13
\: %32
is: %32
not: %32
one: %32
of: %32
those: %32
specified
,: %32
the: %32
behavior: %32
is: %32
undefined
.: %13
In: %32
some: %32
implementations
,: %32
there: %32
is: %32
an: %32
extended: %32
set: %32
of: %32
characters: %32
that: %32
cannot: %32
be: %32
represented: %32
in: %32
the: %32
char: %13
type
.: %32
A: %32
constant: %32
in: %32
this: %32
extended: %32
set: %32
is: %32
written: %32
with: %32
a: %32
preceding: %32
L
,: %32
for: %32
example: %32
L
'
x
'
,: %32
and: %32
is: %32
called: %32
a: %13
wide: %32
character: %32
constant
.: %32
Such: %32
a: %32
constant: %32
has: %32
type: %32
wchar
_
t
,: %32
an: %32
integral: %32
type: %32
defined: %32
in: %32
the: %32
standard: %13
header: %32
<
stddef
.
h
>
.: %32
As: %32
with: %32
ordinary: %32
character: %32
constants
,: %32
hexadecimal: %32
escapes: %32
may: %32
be: %32
used
;: %32
the: %13
effect: %32
is: %32
undefined: %32
if: %32
the: %32
specified: %32
value: %32
exceeds: %32
that: %32
representable: %32
with: %32
wchar
_
t
.: %13
Some: %32
of: %32
these: %32
escape: %32
sequences: %32
are: %32
new
,: %32
in: %32
particular: %32
the: %32
hexadecimal: %32
character: %32
representation
.: %32
Extended: %13
characters: %32
are: %32
also: %32
new
.: %32
The: %32
character: %32
sets: %32
commonly: %32
used: %32
in: %32
the: %32
Americas: %32
and: %32
western: %32
Europe: %32
can: %32
be: %32
encoded: %32
to: %13
fit: %32
in: %32
the: %32
char: %32
type
;: %32
the: %32
main: %32
intent: %32
in: %32
adding: %32
wchar
_
t: %32
was: %32
to: %32
accommodate: %32
Asian: %32
languages
.: %13
A
.
2
.
5
.
3: %32
Floating: %32
Constants: %13
A: %32
floating: %32
constant: %32
consists: %32
of: %32
an: %32
integer: %32
part
,: %32
a: %32
decimal: %32
part
,: %32
a: %32
fraction: %32
part
,: %32
an: %32
e: %32
or: %32
E
,: %32
an: %32
optionally: %13
signed: %32
integer: %32
exponent: %32
and: %32
an: %32
optional: %32
type: %32
suffix
,: %32
one: %32
of: %32
f
,: %32
F
,: %32
l
,: %32
or: %32
L
.: %32
The: %32
integer: %32
and: %32
fraction: %32
parts: %13
both: %32
consist: %32
of: %32
a: %32
sequence: %32
of: %32
digits
.: %32
Either: %32
the: %32
integer: %32
part
,: %32
or: %32
the: %32
fraction: %32
part: %32
(
not: %32
both
): %32
may: %32
be: %13
missing
;: %32
either: %32
the: %32
decimal: %32
point: %32
or: %32
the: %32
e: %32
and: %32
the: %32
exponent: %32
(
not: %32
both
): %32
may: %32
be: %32
missing
.: %32
The: %32
type: %32
is: %13
determined: %32
by: %32
the: %32
suffix
;: %32
F: %32
or: %32
f: %32
makes: %32
it: %32
float
,: %32
L: %32
or: %32
l: %32
makes: %32
it: %32
long: %32
double
,: %32
otherwise: %32
it: %32
is: %13
double
.: %13
A
2
.
5
.
4: %32
Enumeration: %32
Constants: %13
Identifiers: %32
declared: %32
as: %32
enumerators: %32
(
see: %32
Par
.
A
.
8
.
4
): %32
are: %32
constants: %32
of: %32
type: %32
int
.: %13
A
.
2
.
6: %32
String: %32
Literals: %13
A: %32
string: %32
literal
,: %32
also: %32
called: %32
a: %32
string: %32
constant
,: %32
is: %32
a: %32
sequence: %32
of: %32
characters: %32
surrounded: %32
by: %32
double: %32
quotes: %32
as: %13
in: %32
"
.
.
.
"
.: %32
A: %32
string: %32
has: %32
type: %32
`
`
array: %32
of: %32
characters
'
': %32
and: %32
storage: %32
class: %32
static: %32
(
see: %32
Par
.
A
.
3: %32
below
): %32
and: %32
is: %13
initialized: %32
with: %32
the: %32
given: %32
characters
.: %32
Whether: %32
identical: %32
string: %32
literals: %32
are: %32
distinct: %32
is: %32
implementation
-: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
defined
,: %32
and: %32
the: %32
behavior: %32
of: %32
a: %32
program: %32
that: %32
attempts: %32
to: %32
alter: %32
a: %32
string: %32
literal: %32
is: %32
undefined
.: %13
Adjacent: %32
string: %32
literals: %32
are: %32
concatenated: %32
into: %32
a: %32
single: %32
string
.: %32
After: %32
any: %32
concatenation
,: %32
a: %32
null: %32
byte: %32
\
0: %32
is: %13
appended: %32
to: %32
the: %32
string: %32
so: %32
that: %32
programs: %32
that: %32
scan: %32
the: %32
string: %32
can: %32
find: %32
its: %32
end
.: %32
String: %32
literals: %32
do: %32
not: %32
contain: %13
newline: %32
or: %32
double
-
quote: %32
characters
;: %32
in: %32
order: %32
to: %32
represent: %32
them
,: %32
the: %32
same: %32
escape: %32
sequences: %32
as: %32
for: %13
character: %32
constants: %32
are: %32
available
.: %13
As: %32
with: %32
character: %32
constants
,: %32
string: %32
literals: %32
in: %32
an: %32
extended: %32
character: %32
set: %32
are: %32
written: %32
with: %32
a: %32
preceding: %32
L
,: %32
as: %13
in: %32
L
"
.
.
.
"
.: %32
Wide
-
character: %32
string: %32
literals: %32
have: %32
type: %32
`
`
array: %32
of: %32
wchar
_
t
.
'
': %32
Concatenation: %32
of: %32
ordinary: %13
and: %32
wide: %32
string: %32
literals: %32
is: %32
undefined
.: %13
The: %32
specification: %32
that: %32
string: %32
literals: %32
need: %32
not: %32
be: %32
distinct
,: %32
and: %32
the: %32
prohibition: %32
against: %32
modifying: %32
them
,: %32
are: %32
new: %32
in: %13
the: %32
ANSI: %32
standard
,: %32
as: %32
is: %32
the: %32
concatenation: %32
of: %32
adjacent: %32
string: %32
literals
.: %32
Wide
-
character: %32
string: %32
literals: %32
are: %32
new
.: %13
A
.
3: %32
Syntax: %32
Notation: %13
In: %32
the: %32
syntax: %32
notation: %32
used: %32
in: %32
this: %32
manual
,: %32
syntactic: %32
categories: %32
are: %32
indicated: %32
by: %32
italic: %32
type
,: %32
and: %32
literal: %13
words: %32
and: %32
characters: %32
in: %32
typewriter: %32
style
.: %32
Alternative: %32
categories: %32
are: %32
usually: %32
listed: %32
on: %32
separate: %32
lines
;: %13
in: %32
a: %32
few: %32
cases
,: %32
a: %32
long: %32
set: %32
of: %32
narrow: %32
alternatives: %32
is: %32
presented: %32
on: %32
one: %32
line
,: %32
marked: %32
by: %32
the: %32
phrase: %32
`
`
one: %32
of
.
'
': %13
An: %32
optional: %32
terminal: %32
or: %32
nonterminal: %32
symbol: %32
carries: %32
the: %32
subscript: %32
`
`
opt
,
'
': %32
so: %32
that
,: %32
for: %32
example
,: %13
{: %32
expressionopt: %32
}: %13
means: %32
an: %32
optional: %32
expression
,: %32
enclosed: %32
in: %32
braces
.: %32
The: %32
syntax: %32
is: %32
summarized: %32
in: %32
Par
.
A
.
1
3
.: %13
Unlike: %32
the: %32
grammar: %32
given: %32
in: %32
the: %32
first: %32
edition: %32
of: %32
this: %32
book
,: %32
the: %32
one: %32
given: %32
here: %32
makes: %32
precedence: %32
and: %32
associativity: %13
of: %32
expression: %32
operators: %32
explicit
.: %13
A
.
4: %32
Meaning: %32
of: %32
Identifiers: %13
Identifiers
,: %32
or: %32
names
,: %32
refer: %32
to: %32
a: %32
variety: %32
of: %32
things
:: %32
functions
;: %32
tags: %32
of: %32
structures
,: %32
unions
,: %32
and: %32
enumerations
;: %13
members: %32
of: %32
structures: %32
or: %32
unions
;: %32
enumeration: %32
constants
;: %32
typedef: %32
names
;: %32
and: %32
objects
.: %32
An: %32
object
,: %13
sometimes: %32
called: %32
a: %32
variable
,: %32
is: %32
a: %32
location: %32
in: %32
storage
,: %32
and: %32
its: %32
interpretation: %32
depends: %32
on: %32
two: %32
main: %13
attributes
:: %32
its: %32
storage: %32
class: %32
and: %32
its: %32
type
.: %32
The: %32
storage: %32
class: %32
determines: %32
the: %32
lifetime: %32
of: %32
the: %32
storage: %13
associated: %32
with: %32
the: %32
identified: %32
object
;: %32
the: %32
type: %32
determines: %32
the: %32
meaning: %32
of: %32
the: %32
values: %32
found: %32
in: %32
the: %13
identified: %32
object
.: %32
A: %32
name: %32
also: %32
has: %32
a: %32
scope
,: %32
which: %32
is: %32
the: %32
region: %32
of: %32
the: %32
program: %32
in: %32
which: %32
it: %32
is: %32
known
,: %32
and: %32
a: %13
linkage
,: %32
which: %32
determines: %32
whether: %32
the: %32
same: %32
name: %32
in: %32
another: %32
scope: %32
refers: %32
to: %32
the: %32
same: %32
object: %32
or: %32
function
.: %13
Scope: %32
and: %32
linkage: %32
are: %32
discussed: %32
in: %32
Par
.
A
.
1
1
.: %13
A
.
4
.
1: %32
Storage: %32
Class: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
There: %32
are: %32
two: %32
storage: %32
classes
:: %32
automatic: %32
and: %32
static
.: %32
Several: %32
keywords
,: %32
together: %32
with: %32
the: %32
context: %32
of: %32
an: %13
object
'
s: %32
declaration
,: %32
specify: %32
its: %32
storage: %32
class
.: %32
Automatic: %32
objects: %32
are: %32
local: %32
to: %32
a: %32
block: %32
(
Par
.
9
.
3
)
,: %32
and: %32
are: %13
discarded: %32
on: %32
exit: %32
from: %32
the: %32
block
.: %32
Declarations: %32
within: %32
a: %32
block: %32
create: %32
automatic: %32
objects: %32
if: %32
no: %32
storage: %32
class: %13
specification: %32
is: %32
mentioned
,: %32
or: %32
if: %32
the: %32
auto: %32
specifier: %32
is: %32
used
.: %32
Objects: %32
declared: %32
register: %32
are: %32
automatic
,: %13
and: %32
are: %32
(
if: %32
possible
): %32
stored: %32
in: %32
fast: %32
registers: %32
of: %32
the: %32
machine
.: %13
Static: %32
objects: %32
may: %32
be: %32
local: %32
to: %32
a: %32
block: %32
or: %32
external: %32
to: %32
all: %32
blocks
,: %32
but: %32
in: %32
either: %32
case: %32
retain: %32
their: %32
values: %32
across: %13
exit: %32
from: %32
and: %32
reentry: %32
to: %32
functions: %32
and: %32
blocks
.: %32
Within: %32
a: %32
block
,: %32
including: %32
a: %32
block: %32
that: %32
provides: %32
the: %32
code: %13
for: %32
a: %32
function
,: %32
static: %32
objects: %32
are: %32
declared: %32
with: %32
the: %32
keyword: %32
static
.: %32
The: %32
objects: %32
declared: %32
outside: %32
all: %13
blocks
,: %32
at: %32
the: %32
same: %32
level: %32
as: %32
function: %32
definitions
,: %32
are: %32
always: %32
static
.: %32
They: %32
may: %32
be: %32
made: %32
local: %32
to: %32
a: %32
particular: %13
translation: %32
unit: %32
by: %32
use: %32
of: %32
the: %32
static: %32
keyword
;: %32
this: %32
gives: %32
them: %32
internal: %32
linkage
.: %32
They: %32
become: %32
global: %32
to: %13
an: %32
entire: %32
program: %32
by: %32
omitting: %32
an: %32
explicit: %32
storage: %32
class
,: %32
or: %32
by: %32
using: %32
the: %32
keyword: %32
extern
;: %32
this: %32
gives: %13
them: %32
external: %32
linkage
.: %13
A
.
4
.
2: %32
Basic: %32
Types: %13
There: %32
are: %32
several: %32
fundamental: %32
types
.: %32
The: %32
standard: %32
header: %32
<
limits
.
h
>: %32
described: %32
in: %32
Appendix: %32
B: %13
defines: %32
the: %32
largest: %32
and: %32
smallest: %32
values: %32
of: %32
each: %32
type: %32
in: %32
the: %32
local: %32
implementation
.: %32
The: %32
numbers: %32
given: %32
in: %13
Appendix: %32
B: %32
show: %32
the: %32
smallest: %32
acceptable: %32
magnitudes
.: %13
Objects: %32
declared: %32
as: %32
characters: %32
(
char
): %32
are: %32
large: %32
enough: %32
to: %32
store: %32
any: %32
member: %32
of: %32
the: %32
execution: %32
character: %13
set
.: %32
If: %32
a: %32
genuine: %32
character: %32
from: %32
that: %32
set: %32
is: %32
stored: %32
in: %32
a: %32
char: %32
object
,: %32
its: %32
value: %32
is: %32
equivalent: %32
to: %32
the: %32
integer: %13
code: %32
for: %32
the: %32
character
,: %32
and: %32
is: %32
non
-
negative
.: %32
Other: %32
quantities: %32
may: %32
be: %32
stored: %32
into: %32
char: %32
variables
,: %32
but: %32
the: %13
available: %32
range: %32
of: %32
values
,: %32
and: %32
especially: %32
whether: %32
the: %32
value: %32
is: %32
signed
,: %32
is: %32
implementation
-
dependent
.: %13
Unsigned: %32
characters: %32
declared: %32
unsigned: %32
char: %32
consume: %32
the: %32
same: %32
amount: %32
of: %32
space: %32
as: %32
plain: %32
characters
,: %13
but: %32
always: %32
appear: %32
non
-
negative
;: %32
explicitly: %32
signed: %32
characters: %32
declared: %32
signed: %32
char: %32
likewise: %32
take: %32
the: %13
same: %32
space: %32
as: %32
plain: %32
characters
.: %13
unsigned: %32
char: %32
type: %32
does: %32
not: %32
appear: %32
in: %32
the: %32
first: %32
edition: %32
of: %32
this: %32
book
,: %32
but: %32
is: %32
in: %32
common: %32
use
.: %32
signed: %32
char: %32
is: %13
new
.: %13
Besides: %32
the: %32
char: %32
types
,: %32
up: %32
to: %32
three: %32
sizes: %32
of: %32
integer
,: %32
declared: %32
short: %32
int
,: %32
int
,: %32
and: %32
long: %32
int
,: %32
are: %13
available
.: %32
Plain: %32
int: %32
objects: %32
have: %32
the: %32
natural: %32
size: %32
suggested: %32
by: %32
the: %32
host: %32
machine: %32
architecture
;: %32
the: %32
other: %13
sizes: %32
are: %32
provided: %32
to: %32
meet: %32
special: %32
needs
.: %32
Longer: %32
integers: %32
provide: %32
at: %32
least: %32
as: %32
much: %32
storage: %32
as: %32
shorter: %13
ones
,: %32
but: %32
the: %32
implementation: %32
may: %32
make: %32
plain: %32
integers: %32
equivalent: %32
to: %32
either: %32
short: %32
integers
,: %32
or: %32
long: %13
integers
.: %32
The: %32
int: %32
types: %32
all: %32
represent: %32
signed: %32
values: %32
unless: %32
specified: %32
otherwise
.: %13
Unsigned: %32
integers
,: %32
declared: %32
using: %32
the: %32
keyword: %32
unsigned
,: %32
obey: %32
the: %32
laws: %32
of: %32
arithmetic: %32
modulo: %32
2
n: %13
where: %32
n: %32
is: %32
the: %32
number: %32
of: %32
bits: %32
in: %32
the: %32
representation
,: %32
and: %32
thus: %32
arithmetic: %32
on: %32
unsigned: %32
quantities: %32
can: %32
never: %13
overflow
.: %32
The: %32
set: %32
of: %32
non
-
negative: %32
values: %32
that: %32
can: %32
be: %32
stored: %32
in: %32
a: %32
signed: %32
object: %32
is: %32
a: %32
subset: %32
of: %32
the: %32
values: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
that: %32
can: %32
be: %32
stored: %32
in: %32
the: %32
corresponding: %32
unsigned: %32
object
,: %32
and: %32
the: %32
representation: %32
for: %32
the: %32
overlapping: %32
values: %13
is: %32
the: %32
same
.: %13
Any: %32
of: %32
single: %32
precision: %32
floating: %32
point: %32
(
float
)
,: %32
double: %32
precision: %32
floating: %32
point: %32
(
double
)
,: %32
and: %32
extra: %13
precision: %32
floating: %32
point: %32
(
long: %32
double
): %32
may: %32
be: %32
synonymous
,: %32
but: %32
the: %32
ones: %32
later: %32
in: %32
the: %32
list: %32
are: %32
at: %32
least: %32
as: %13
precise: %32
as: %32
those: %32
before
.: %13
long: %32
double: %32
is: %32
new
.: %32
The: %32
first: %32
edition: %32
made: %32
long: %32
float: %32
equivalent: %32
to: %32
double
;: %32
the: %32
locution: %32
has: %32
been: %13
withdrawn
.: %13
Enumerations: %32
are: %32
unique: %32
types: %32
that: %32
have: %32
integral: %32
values
;: %32
associated: %32
with: %32
each: %32
enumeration: %32
is: %32
a: %32
set: %32
of: %13
named: %32
constants: %32
(
Par
.
A
.
8
.
4
)
.: %32
Enumerations: %32
behave: %32
like: %32
integers
,: %32
but: %32
it: %32
is: %32
common: %32
for: %32
a: %32
compiler: %32
to: %32
issue: %13
a: %32
warning: %32
when: %32
an: %32
object: %32
of: %32
a: %32
particular: %32
enumeration: %32
is: %32
assigned: %32
something: %32
other: %32
than: %32
one: %32
of: %32
its: %13
constants
,: %32
or: %32
an: %32
expression: %32
of: %32
its: %32
type
.: %13
Because: %32
objects: %32
of: %32
these: %32
types: %32
can: %32
be: %32
interpreted: %32
as: %32
numbers
,: %32
they: %32
will: %32
be: %32
referred: %32
to: %32
as: %32
arithmetic: %32
types
.: %13
Types: %32
char
,: %32
and: %32
int: %32
of: %32
all: %32
sizes
,: %32
each: %32
with: %32
or: %32
without: %32
sign
,: %32
and: %32
also: %32
enumeration: %32
types
,: %32
will: %13
collectively: %32
be: %32
called: %32
integral: %32
types
.: %32
The: %32
types: %32
float
,: %32
double
,: %32
and: %32
long: %32
double: %32
will: %32
be: %32
called: %13
floating: %32
types
.: %13
The: %32
void: %32
type: %32
specifies: %32
an: %32
empty: %32
set: %32
of: %32
values
.: %32
It: %32
is: %32
used: %32
as: %32
the: %32
type: %32
returned: %32
by: %32
functions: %32
that: %32
generate: %13
no: %32
value
.: %13
A
.
4
.
3: %32
Derived: %32
types: %13
Beside: %32
the: %32
basic: %32
types
,: %32
there: %32
is: %32
a: %32
conceptually: %32
infinite: %32
class: %32
of: %32
derived: %32
types: %32
constructed: %32
from: %32
the: %13
fundamental: %32
types: %32
in: %32
the: %32
following: %32
ways
:: %13
arrays: %32
of: %32
objects: %32
of: %32
a: %32
given: %32
type
;: %13
functions: %32
returning: %32
objects: %32
of: %32
a: %32
given: %32
type
;: %13
pointers: %32
to: %32
objects: %32
of: %32
a: %32
given: %32
type
;: %13
structures: %32
containing: %32
a: %32
sequence: %32
of: %32
objects: %32
of: %32
various: %32
types
;: %13
unions: %32
capable: %32
of: %32
containing: %32
any: %32
of: %32
one: %32
of: %32
several: %32
objects: %32
of: %32
various: %32
types
.: %13
In: %32
general: %32
these: %32
methods: %32
of: %32
constructing: %32
objects: %32
can: %32
be: %32
applied: %32
recursively
.: %13
A
.
4
.
4: %32
Type: %32
Qualifiers: %13
An: %32
object
'
s: %32
type: %32
may: %32
have: %32
additional: %32
qualifiers
.: %32
Declaring: %32
an: %32
object: %32
const: %32
announces: %32
that: %32
its: %32
value: %32
will: %13
not: %32
be: %32
changed
;: %32
declaring: %32
it: %32
volatile: %32
announces: %32
that: %32
it: %32
has: %32
special: %32
properties: %32
relevant: %32
to: %32
optimization
.: %13
Neither: %32
qualifier: %32
affects: %32
the: %32
range: %32
of: %32
values: %32
or: %32
arithmetic: %32
properties: %32
of: %32
the: %32
object
.: %32
Qualifiers: %32
are: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
discussed: %32
in: %32
Par
.
A
.
8
.
2
.: %13
A
.
5: %32
Objects: %32
and: %32
Lvalues: %13
An: %32
Object: %32
is: %32
a: %32
named: %32
region: %32
of: %32
storage
;: %32
an: %32
lvalue: %32
is: %32
an: %32
expression: %32
referring: %32
to: %32
an: %32
object
.: %32
An: %32
obvious: %13
example: %32
of: %32
an: %32
lvalue: %32
expression: %32
is: %32
an: %32
identifier: %32
with: %32
suitable: %32
type: %32
and: %32
storage: %32
class
.: %32
There: %32
are: %32
operators: %13
that: %32
yield: %32
lvalues
,: %32
if: %32
E: %32
is: %32
an: %32
expression: %32
of: %32
pointer: %32
type
,: %32
then: %32
*
E: %32
is: %32
an: %32
lvalue: %32
expression: %32
referring: %32
to: %32
the: %13
object: %32
to: %32
which: %32
E: %32
points
.: %32
The: %32
name: %32
`
`
lvalue
'
': %32
comes: %32
from: %32
the: %32
assignment: %32
expression: %32
E
1: %32
=: %32
E
2: %32
in: %32
which: %13
the: %32
left: %32
operand: %32
E
1: %32
must: %32
be: %32
an: %32
lvalue: %32
expression
.: %32
The: %32
discussion: %32
of: %32
each: %32
operator: %32
specifies: %32
whether: %32
it: %13
expects: %32
lvalue: %32
operands: %32
and: %32
whether: %32
it: %32
yields: %32
an: %32
lvalue
.: %13
A
.
6: %32
Conversions: %13
Some: %32
operators: %32
may
,: %32
depending: %32
on: %32
their: %32
operands
,: %32
cause: %32
conversion: %32
of: %32
the: %32
value: %32
of: %32
an: %32
operand: %32
from: %32
one: %13
type: %32
to: %32
another
.: %32
This: %32
section: %32
explains: %32
the: %32
result: %32
to: %32
be: %32
expected: %32
from: %32
such: %32
conversions
.: %32
Par
.
6
.
5: %13
summarizes: %32
the: %32
conversions: %32
demanded: %32
by: %32
most: %32
ordinary: %32
operators
;: %32
it: %32
will: %32
be: %32
supplemented: %32
as: %32
required: %13
by: %32
the: %32
discussion: %32
of: %32
each: %32
operator
.: %13
A
.
6
.
1: %32
Integral: %32
Promotion: %13
A: %32
character
,: %32
a: %32
short: %32
integer
,: %32
or: %32
an: %32
integer: %32
bit
-
field
,: %32
all: %32
either: %32
signed: %32
or: %32
not
,: %32
or: %32
an: %32
object: %32
of: %32
enumeration: %13
type
,: %32
may: %32
be: %32
used: %32
in: %32
an: %32
expression: %32
wherever: %32
an: %32
integer: %32
may: %32
be: %32
used
.: %32
If: %32
an: %32
int: %32
can: %32
represent: %32
all: %32
the: %13
values: %32
of: %32
the: %32
original: %32
type
,: %32
then: %32
the: %32
value: %32
is: %32
converted: %32
to: %32
int
;: %32
otherwise: %32
the: %32
value: %32
is: %32
converted: %32
to: %13
unsigned: %32
int
.: %32
This: %32
process: %32
is: %32
called: %32
integral: %32
promotion
.: %13
A
.
6
.
2: %32
Integral: %32
Conversions: %13
Any: %32
integer: %32
is: %32
converted: %32
to: %32
a: %32
given: %32
unsigned: %32
type: %32
by: %32
finding: %32
the: %32
smallest: %32
non
-
negative: %32
value: %32
that: %32
is: %13
congruent: %32
to: %32
that: %32
integer
,: %32
modulo: %32
one: %32
more: %32
than: %32
the: %32
largest: %32
value: %32
that: %32
can: %32
be: %32
represented: %32
in: %32
the: %32
unsigned: %13
type
.: %32
In: %32
a: %32
two
'
s: %32
complement: %32
representation
,: %32
this: %32
is: %32
equivalent: %32
to: %32
left
-
truncation: %32
if: %32
the: %32
bit: %32
pattern: %32
of: %32
the: %13
unsigned: %32
type: %32
is: %32
narrower
,: %32
and: %32
to: %32
zero
-
filling: %32
unsigned: %32
values: %32
and: %32
sign
-
extending: %32
signed: %32
values: %32
if: %32
the: %13
unsigned: %32
type: %32
is: %32
wider
.: %13
When: %32
any: %32
integer: %32
is: %32
converted: %32
to: %32
a: %32
signed: %32
type
,: %32
the: %32
value: %32
is: %32
unchanged: %32
if: %32
it: %32
can: %32
be: %32
represented: %32
in: %32
the: %32
new: %13
type: %32
and: %32
is: %32
implementation
-
defined: %32
otherwise
.: %13
A
.
6
.
3: %32
Integer: %32
and: %32
Floating: %13
When: %32
a: %32
value: %32
of: %32
floating: %32
type: %32
is: %32
converted: %32
to: %32
integral: %32
type
,: %32
the: %32
fractional: %32
part: %32
is: %32
discarded
;: %32
if: %32
the: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
resulting: %32
value: %32
cannot: %32
be: %32
represented: %32
in: %32
the: %32
integral: %32
type
,: %32
the: %32
behavior: %32
is: %32
undefined
.: %32
In: %32
particular
,: %32
the: %13
result: %32
of: %32
converting: %32
negative: %32
floating: %32
values: %32
to: %32
unsigned: %32
integral: %32
types: %32
is: %32
not: %32
specified
.: %13
When: %32
a: %32
value: %32
of: %32
integral: %32
type: %32
is: %32
converted: %32
to: %32
floating
,: %32
and: %32
the: %32
value: %32
is: %32
in: %32
the: %32
representable: %32
range: %32
but: %32
is: %13
not: %32
exactly: %32
representable
,: %32
then: %32
the: %32
result: %32
may: %32
be: %32
either: %32
the: %32
next: %32
higher: %32
or: %32
next: %32
lower: %32
representable: %32
value
.: %13
If: %32
the: %32
result: %32
is: %32
out: %32
of: %32
range
,: %32
the: %32
behavior: %32
is: %32
undefined
.: %13
A
.
6
.
4: %32
Floating: %32
Types: %13
When: %32
a: %32
less: %32
precise: %32
floating: %32
value: %32
is: %32
converted: %32
to: %32
an: %32
equally: %32
or: %32
more: %32
precise: %32
floating: %32
type
,: %32
the: %32
value: %32
is: %13
unchanged
.: %32
When: %32
a: %32
more: %32
precise: %32
floating: %32
value: %32
is: %32
converted: %32
to: %32
a: %32
less: %32
precise: %32
floating: %32
type
,: %32
and: %32
the: %32
value: %13
is: %32
within: %32
representable: %32
range
,: %32
the: %32
result: %32
may: %32
be: %32
either: %32
the: %32
next: %32
higher: %32
or: %32
the: %32
next: %32
lower: %32
representable: %13
value
.: %32
If: %32
the: %32
result: %32
is: %32
out: %32
of: %32
range
,: %32
the: %32
behavior: %32
is: %32
undefined
.: %13
A
.
6
.
5: %32
Arithmetic: %32
Conversions: %13
Many: %32
operators: %32
cause: %32
conversions: %32
and: %32
yield: %32
result: %32
types: %32
in: %32
a: %32
similar: %32
way
.: %32
The: %32
effect: %32
is: %32
to: %32
bring: %32
operands: %13
into: %32
a: %32
common: %32
type
,: %32
which: %32
is: %32
also: %32
the: %32
type: %32
of: %32
the: %32
result
.: %32
This: %32
pattern: %32
is: %32
called: %32
the: %32
usual: %32
arithmetic: %13
conversions
.: %13
q: %13
q: %13
q: %13
q: %13
q: %13
q: %13
q: %13
q: %13
First
,: %32
if: %32
either: %32
operand: %32
is: %32
long: %32
double
,: %32
the: %32
other: %32
is: %32
converted: %32
to: %32
long: %32
double
.: %13
Otherwise
,: %32
if: %32
either: %32
operand: %32
is: %32
double
,: %32
the: %32
other: %32
is: %32
converted: %32
to: %32
double
.: %13
Otherwise
,: %32
if: %32
either: %32
operand: %32
is: %32
float
,: %32
the: %32
other: %32
is: %32
converted: %32
to: %32
float
.: %13
Otherwise
,: %32
the: %32
integral: %32
promotions: %32
are: %32
performed: %32
on: %32
both: %32
operands
;: %32
then
,: %32
if: %32
either: %32
operand: %32
is: %13
unsigned: %32
long: %32
int
,: %32
the: %32
other: %32
is: %32
converted: %32
to: %32
unsigned: %32
long: %32
int
.: %13
Otherwise
,: %32
if: %32
one: %32
operand: %32
is: %32
long: %32
int: %32
and: %32
the: %32
other: %32
is: %32
unsigned: %32
int
,: %32
the: %32
effect: %32
depends: %32
on: %13
whether: %32
a: %32
long: %32
int: %32
can: %32
represent: %32
all: %32
values: %32
of: %32
an: %32
unsigned: %32
int
;: %32
if: %32
so
,: %32
the: %32
unsigned: %13
int: %32
operand: %32
is: %32
converted: %32
to: %32
long: %32
int
;: %32
if: %32
not
,: %32
both: %32
are: %32
converted: %32
to: %32
unsigned: %32
long: %32
int
.: %13
Otherwise
,: %32
if: %32
one: %32
operand: %32
is: %32
long: %32
int
,: %32
the: %32
other: %32
is: %32
converted: %32
to: %32
long: %32
int
.: %13
Otherwise
,: %32
if: %32
either: %32
operand: %32
is: %32
unsigned: %32
int
,: %32
the: %32
other: %32
is: %32
converted: %32
to: %32
unsigned: %32
int
.: %13
Otherwise
,: %32
both: %32
operands: %32
have: %32
type: %32
int
.: %13
There: %32
are: %32
two: %32
changes: %32
here
.: %32
First
,: %32
arithmetic: %32
on: %32
float: %32
operands: %32
may: %32
be: %32
done: %32
in: %32
single: %32
precision
,: %32
rather: %32
than: %13
double
;: %32
the: %32
first: %32
edition: %32
specified: %32
that: %32
all: %32
floating: %32
arithmetic: %32
was: %32
double: %32
precision
.: %32
Second
,: %32
shorter: %32
unsigned: %32
types
,: %13
when: %32
combined: %32
with: %32
a: %32
larger: %32
signed: %32
type
,: %32
do: %32
not: %32
propagate: %32
the: %32
unsigned: %32
property: %32
to: %32
the: %32
result: %32
type
;: %32
in: %32
the: %32
first: %13
edition
,: %32
the: %32
unsigned: %32
always: %32
dominated
.: %32
The: %32
new: %32
rules: %32
are: %32
slightly: %32
more: %32
complicated
,: %32
but: %32
reduce: %32
somewhat: %32
the: %13
surprises: %32
that: %32
may: %32
occur: %32
when: %32
an: %32
unsigned: %32
quantity: %32
meets: %32
signed
.: %32
Unexpected: %32
results: %32
may: %32
still: %32
occur: %32
when: %32
an: %13
unsigned: %32
expression: %32
is: %32
compared: %32
to: %32
a: %32
signed: %32
expression: %32
of: %32
the: %32
same: %32
size
.: %13
A
.
6
.
6: %32
Pointers: %32
and: %32
Integers: %13
An: %32
expression: %32
of: %32
integral: %32
type: %32
may: %32
be: %32
added: %32
to: %32
or: %32
subtracted: %32
from: %32
a: %32
pointer
;: %32
in: %32
such: %32
a: %32
case: %32
the: %32
integral: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
expression: %32
is: %32
converted: %32
as: %32
specified: %32
in: %32
the: %32
discussion: %32
of: %32
the: %32
addition: %32
operator: %32
(
Par
.
A
.
7
.
7
)
.: %13
Two: %32
pointers: %32
to: %32
objects: %32
of: %32
the: %32
same: %32
type
,: %32
in: %32
the: %32
same: %32
array
,: %32
may: %32
be: %32
subtracted
;: %32
the: %32
result: %32
is: %32
converted: %32
to: %13
an: %32
integer: %32
as: %32
specified: %32
in: %32
the: %32
discussion: %32
of: %32
the: %32
subtraction: %32
operator: %32
(
Par
.
A
.
7
.
7
)
.: %13
An: %32
integral: %32
constant: %32
expression: %32
with: %32
value: %32
0
,: %32
or: %32
such: %32
an: %32
expression: %32
cast: %32
to: %32
type: %32
void: %32
*
,: %32
may: %32
be: %13
converted
,: %32
by: %32
a: %32
cast
,: %32
by: %32
assignment
,: %32
or: %32
by: %32
comparison
,: %32
to: %32
a: %32
pointer: %32
of: %32
any: %32
type
.: %32
This: %32
produces: %32
a: %32
null: %13
pointer: %32
that: %32
is: %32
equal: %32
to: %32
another: %32
null: %32
pointer: %32
of: %32
the: %32
same: %32
type
,: %32
but: %32
unequal: %32
to: %32
any: %32
pointer: %32
to: %32
a: %32
function: %32
or: %13
object
.: %13
Certain: %32
other: %32
conversions: %32
involving: %32
pointers: %32
are: %32
permitted
,: %32
but: %32
have: %32
implementation
-
defined: %32
aspects
.: %13
They: %32
must: %32
be: %32
specified: %32
by: %32
an: %32
explicit: %32
type
-
conversion: %32
operator
,: %32
or: %32
cast: %32
(
Pars
.
A
.
7
.
5: %32
and: %32
A
.
8
.
8
)
.: %13
A: %32
pointer: %32
may: %32
be: %32
converted: %32
to: %32
an: %32
integral: %32
type: %32
large: %32
enough: %32
to: %32
hold: %32
it
;: %32
the: %32
required: %32
size: %32
is: %13
implementation
-
dependent
.: %32
The: %32
mapping: %32
function: %32
is: %32
also: %32
implementation
-
dependent
.: %13
A: %32
pointer: %32
to: %32
one: %32
type: %32
may: %32
be: %32
converted: %32
to: %32
a: %32
pointer: %32
to: %32
another: %32
type
.: %32
The: %32
resulting: %32
pointer: %32
may: %32
cause: %13
addressing: %32
exceptions: %32
if: %32
the: %32
subject: %32
pointer: %32
does: %32
not: %32
refer: %32
to: %32
an: %32
object: %32
suitably: %32
aligned: %32
in: %32
storage
.: %32
It: %32
is: %13
guaranteed: %32
that: %32
a: %32
pointer: %32
to: %32
an: %32
object: %32
may: %32
be: %32
converted: %32
to: %32
a: %32
pointer: %32
to: %32
an: %32
object: %32
whose: %32
type: %32
requires: %32
less: %13
or: %32
equally: %32
strict: %32
storage: %32
alignment: %32
and: %32
back: %32
again: %32
without: %32
change
;: %32
the: %32
notion: %32
of: %32
`
`
alignment
'
': %32
is: %13
implementation
-
dependent
,: %32
but: %32
objects: %32
of: %32
the: %32
char: %32
types: %32
have: %32
least: %32
strict: %32
alignment: %32
requirements
.: %32
As: %13
described: %32
in: %32
Par
.
A
.
6
.
8
,: %32
a: %32
pointer: %32
may: %32
also: %32
be: %32
converted: %32
to: %32
type: %32
void: %32
*: %32
and: %32
back: %32
again: %32
without: %32
change
.: %13
A: %32
pointer: %32
may: %32
be: %32
converted: %32
to: %32
another: %32
pointer: %32
whose: %32
type: %32
is: %32
the: %32
same: %32
except: %32
for: %32
the: %32
addition: %32
or: %32
removal: %13
of: %32
qualifiers: %32
(
Pars
.
A
.
4
.
4
,: %32
A
.
8
.
2
): %32
of: %32
the: %32
object: %32
type: %32
to: %32
which: %32
the: %32
pointer: %32
refers
.: %32
If: %32
qualifiers: %32
are: %32
added
,: %32
the: %13
new: %32
pointer: %32
is: %32
equivalent: %32
to: %32
the: %32
old: %32
except: %32
for: %32
restrictions: %32
implied: %32
by: %32
the: %32
new: %32
qualifiers
.: %32
If: %32
qualifiers: %32
are: %13
removed
,: %32
operations: %32
on: %32
the: %32
underlying: %32
object: %32
remain: %32
subject: %32
to: %32
the: %32
qualifiers: %32
in: %32
its: %32
actual: %32
declaration
.: %13
Finally
,: %32
a: %32
pointer: %32
to: %32
a: %32
function: %32
may: %32
be: %32
converted: %32
to: %32
a: %32
pointer: %32
to: %32
another: %32
function: %32
type
.: %32
Calling: %32
the: %13
function: %32
specified: %32
by: %32
the: %32
converted: %32
pointer: %32
is: %32
implementation
-
dependent
;: %32
however
,: %32
if: %32
the: %32
converted: %13
pointer: %32
is: %32
reconverted: %32
to: %32
its: %32
original: %32
type
,: %32
the: %32
result: %32
is: %32
identical: %32
to: %32
the: %32
original: %32
pointer
.: %13
A
.
6
.
7: %32
Void: %13
The: %32
(
nonexistent
): %32
value: %32
of: %32
a: %32
void: %32
object: %32
may: %32
not: %32
be: %32
used: %32
in: %32
any: %32
way
,: %32
and: %32
neither: %32
explicit: %32
nor: %32
implicit: %13
conversion: %32
to: %32
any: %32
non
-
void: %32
type: %32
may: %32
be: %32
applied
.: %32
Because: %32
a: %32
void: %32
expression: %32
denotes: %32
a: %32
nonexistent: %32
value
,: %13
such: %32
an: %32
expression: %32
may: %32
be: %32
used: %32
only: %32
where: %32
the: %32
value: %32
is: %32
not: %32
required
,: %32
for: %32
example: %32
as: %32
an: %32
expression: %13
statement: %32
(
Par
.
A
.
9
.
2
): %32
or: %32
as: %32
the: %32
left: %32
operand: %32
of: %32
a: %32
comma: %32
operator: %32
(
Par
.
A
.
7
.
1
8
)
.: %13
An: %32
expression: %32
may: %32
be: %32
converted: %32
to: %32
type: %32
void: %32
by: %32
a: %32
cast
.: %32
For: %32
example
,: %32
a: %32
void: %32
cast: %32
documents: %32
the: %13
discarding: %32
of: %32
the: %32
value: %32
of: %32
a: %32
function: %32
call: %32
used: %32
as: %32
an: %32
expression: %32
statement
.: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
void: %32
did: %32
not: %32
appear: %32
in: %32
the: %32
first: %32
edition: %32
of: %32
this: %32
book
,: %32
but: %32
has: %32
become: %32
common: %32
since
.: %13
A
.
6
.
8: %32
Pointers: %32
to: %32
Void: %13
Any: %32
pointer: %32
to: %32
an: %32
object: %32
may: %32
be: %32
converted: %32
to: %32
type: %32
void: %32
*: %32
without: %32
loss: %32
of: %32
information
.: %32
If: %32
the: %32
result: %32
is: %13
converted: %32
back: %32
to: %32
the: %32
original: %32
pointer: %32
type
,: %32
the: %32
original: %32
pointer: %32
is: %32
recovered
.: %32
Unlike: %32
the: %32
pointer
-
to
-: %13
pointer: %32
conversions: %32
discussed: %32
in: %32
Par
.
A
.
6
.
6
,: %32
which: %32
generally: %32
require: %32
an: %32
explicit: %32
cast
,: %32
pointers: %32
may: %32
be: %13
assigned: %32
to: %32
and: %32
from: %32
pointers: %32
of: %32
type: %32
void: %32
*
,: %32
and: %32
may: %32
be: %32
compared: %32
with: %32
them
.: %13
This: %32
interpretation: %32
of: %32
void: %32
*: %32
pointers: %32
is: %32
new
;: %32
previously
,: %32
char: %32
*: %32
pointers: %32
played: %32
the: %32
role: %32
of: %32
generic: %32
pointer
.: %13
The: %32
ANSI: %32
standard: %32
specifically: %32
blesses: %32
the: %32
meeting: %32
of: %32
void: %32
*: %32
pointers: %32
with: %32
object: %32
pointers: %32
in: %32
assignments: %32
and: %13
relationals
,: %32
while: %32
requiring: %32
explicit: %32
casts: %32
for: %32
other: %32
pointer: %32
mixtures
.: %13
A
.
7: %32
Expressions: %13
The: %32
precedence: %32
of: %32
expression: %32
operators: %32
is: %32
the: %32
same: %32
as: %32
the: %32
order: %32
of: %32
the: %32
major: %32
subsections: %32
of: %32
this: %32
section
,: %13
highest: %32
precedence: %32
first
.: %32
Thus
,: %32
for: %32
example
,: %32
the: %32
expressions: %32
referred: %32
to: %32
as: %32
the: %32
operands: %32
of: %32
+: %32
(
Par
.
A
.
7
.
7
): %13
are: %32
those: %32
expressions: %32
defined: %32
in: %32
Pars
.
A
.
7
.
1
-
A
.
7
.
6
.: %32
Within: %32
each: %32
subsection
,: %32
the: %32
operators: %32
have: %32
the: %32
same: %13
precedence
.: %32
Left
-: %32
or: %32
right
-
associativity: %32
is: %32
specified: %32
in: %32
each: %32
subsection: %32
for: %32
the: %32
operators: %32
discussed: %32
therein
.: %13
The: %32
grammar: %32
given: %32
in: %32
Par
.
1
3: %32
incorporates: %32
the: %32
precedence: %32
and: %32
associativity: %32
of: %32
the: %32
operators
.: %13
The: %32
precedence: %32
and: %32
associativity: %32
of: %32
operators: %32
is: %32
fully: %32
specified
,: %32
but: %32
the: %32
order: %32
of: %32
evaluation: %32
of: %13
expressions: %32
is
,: %32
with: %32
certain: %32
exceptions
,: %32
undefined
,: %32
even: %32
if: %32
the: %32
subexpressions: %32
involve: %32
side: %32
effects
.: %32
That: %13
is
,: %32
unless: %32
the: %32
definition: %32
of: %32
the: %32
operator: %32
guarantees: %32
that: %32
its: %32
operands: %32
are: %32
evaluated: %32
in: %32
a: %32
particular: %32
order
,: %32
the: %13
implementation: %32
is: %32
free: %32
to: %32
evaluate: %32
operands: %32
in: %32
any: %32
order
,: %32
or: %32
even: %32
to: %32
interleave: %32
their: %32
evaluation
.: %32
However
,: %13
each: %32
operator: %32
combines: %32
the: %32
values: %32
produced: %32
by: %32
its: %32
operands: %32
in: %32
a: %32
way: %32
compatible: %32
with: %32
the: %32
parsing: %32
of: %32
the: %13
expression: %32
in: %32
which: %32
it: %32
appears
.: %13
This: %32
rule: %32
revokes: %32
the: %32
previous: %32
freedom: %32
to: %32
reorder: %32
expressions: %32
with: %32
operators: %32
that: %32
are: %32
mathematically: %32
commutative: %13
and: %32
associative
,: %32
but: %32
can: %32
fail: %32
to: %32
be: %32
computationally: %32
associative
.: %32
The: %32
change: %32
affects: %32
only: %32
floating
-
point: %13
computations: %32
near: %32
the: %32
limits: %32
of: %32
their: %32
accuracy
,: %32
and: %32
situations: %32
where: %32
overflow: %32
is: %32
possible
.: %13
The: %32
handling: %32
of: %32
overflow
,: %32
divide: %32
check
,: %32
and: %32
other: %32
exceptions: %32
in: %32
expression: %32
evaluation: %32
is: %32
not: %32
defined: %32
by: %13
the: %32
language
.: %32
Most: %32
existing: %32
implementations: %32
of: %32
C: %32
ignore: %32
overflow: %32
in: %32
evaluation: %32
of: %32
signed: %32
integral: %13
expressions: %32
and: %32
assignments
,: %32
but: %32
this: %32
behavior: %32
is: %32
not: %32
guaranteed
.: %32
Treatment: %32
of: %32
division: %32
by: %32
0
,: %32
and: %32
all: %13
floating
-
point: %32
exceptions
,: %32
varies: %32
among: %32
implementations
;: %32
sometimes: %32
it: %32
is: %32
adjustable: %32
by: %32
a: %32
non
-
standard: %13
library: %32
function
.: %13
A
.
7
.
1: %32
Pointer: %32
Conversion: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
If: %32
the: %32
type: %32
of: %32
an: %32
expression: %32
or: %32
subexpression: %32
is: %32
`
`
array: %32
of: %32
T
,
'
': %32
for: %32
some: %32
type: %32
T
,: %32
then: %32
the: %32
value: %32
of: %32
the: %13
expression: %32
is: %32
a: %32
pointer: %32
to: %32
the: %32
first: %32
object: %32
in: %32
the: %32
array
,: %32
and: %32
the: %32
type: %32
of: %32
the: %32
expression: %32
is: %32
altered: %32
to: %32
`
`
pointer: %13
to: %32
T
.
'
': %32
This: %32
conversion: %32
does: %32
not: %32
take: %32
place: %32
if: %32
the: %32
expression: %32
is: %32
in: %32
the: %32
operand: %32
of: %32
the: %32
unary: %32
&: %32
operator
,: %32
or: %13
of: %32
+
+
,: %32
-
-
,: %32
sizeof
,: %32
or: %32
as: %32
the: %32
left: %32
operand: %32
of: %32
an: %32
assignment: %32
operator: %32
or: %32
the: %32
.: %32
operator
.: %32
Similarly
,: %32
an: %13
expression: %32
of: %32
type: %32
`
`
function: %32
returning: %32
T
,
'
': %32
except: %32
when: %32
used: %32
as: %32
the: %32
operand: %32
of: %32
the: %32
&: %32
operator
,: %32
is: %13
converted: %32
to: %32
`
`
pointer: %32
to: %32
function: %32
returning: %32
T
.
'
': %13
A
.
7
.
2: %32
Primary: %32
Expressions: %13
Primary: %32
expressions: %32
are: %32
identifiers
,: %32
constants
,: %32
strings
,: %32
or: %32
expressions: %32
in: %32
parentheses
.: %13
primary
-
expression: %13
identifier: %13
constant: %13
string: %13
(
expression
): %13
An: %32
identifier: %32
is: %32
a: %32
primary: %32
expression
,: %32
provided: %32
it: %32
has: %32
been: %32
suitably: %32
declared: %32
as: %32
discussed: %32
below
.: %32
Its: %32
type: %13
is: %32
specified: %32
by: %32
its: %32
declaration
.: %32
An: %32
identifier: %32
is: %32
an: %32
lvalue: %32
if: %32
it: %32
refers: %32
to: %32
an: %32
object: %32
(
Par
.
A
.
5
): %32
and: %32
if: %32
its: %32
type: %32
is: %13
arithmetic
,: %32
structure
,: %32
union
,: %32
or: %32
pointer
.: %13
A: %32
constant: %32
is: %32
a: %32
primary: %32
expression
.: %32
Its: %32
type: %32
depends: %32
on: %32
its: %32
form: %32
as: %32
discussed: %32
in: %32
Par
.
A
.
2
.
5
.: %13
A: %32
string: %32
literal: %32
is: %32
a: %32
primary: %32
expression
.: %32
Its: %32
type: %32
is: %32
originally: %32
`
`
array: %32
of: %32
char
'
': %32
(
for: %32
wide
-
char: %32
strings
,: %13
`
`
array: %32
of: %32
wchar
_
t
'
'
)
,: %32
but: %32
following: %32
the: %32
rule: %32
given: %32
in: %32
Par
.
A
.
7
.
1
,: %32
this: %32
is: %32
usually: %32
modified: %32
to: %32
`
`
pointer: %32
to: %13
char
'
': %32
(
wchar
_
t
): %32
and: %32
the: %32
result: %32
is: %32
a: %32
pointer: %32
to: %32
the: %32
first: %32
character: %32
in: %32
the: %32
string
.: %32
The: %32
conversion: %32
also: %32
does: %13
not: %32
occur: %32
in: %32
certain: %32
initializers
;: %32
see: %32
Par
.
A
.
8
.
7
.: %13
A: %32
parenthesized: %32
expression: %32
is: %32
a: %32
primary: %32
expression: %32
whose: %32
type: %32
and: %32
value: %32
are: %32
identical: %32
to: %32
those: %32
of: %32
the: %13
unadorned: %32
expression
.: %32
The: %32
precedence: %32
of: %32
parentheses: %32
does: %32
not: %32
affect: %32
whether: %32
the: %32
expression: %32
is: %32
an: %32
lvalue
.: %13
A
.
7
.
3: %32
Postfix: %32
Expressions: %13
The: %32
operators: %32
in: %32
postfix: %32
expressions: %32
group: %32
left: %32
to: %32
right
.: %13
postfix
-
expression
:: %13
primary
-
expression: %13
postfix
-
expression
[
expression
]: %13
postfix
-
expression
(
argument
-
expression
-
listopt
): %13
postfix
-
expression
.
identifier: %13
postfix
-
expression
-
>
identifier: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
postfix
-
expression
+
+: %13
postfix
-
expression
-
-: %13
argument
-
expression
-
list
:: %13
assignment
-
expression: %13
assignment
-
expression
-
list: %32
,: %32
assignment
-
expression: %13
A
.
7
.
3
.
1: %32
Array: %32
References: %13
A: %32
postfix: %32
expression: %32
followed: %32
by: %32
an: %32
expression: %32
in: %32
square: %32
brackets: %32
is: %32
a: %32
postfix: %32
expression: %32
denoting: %32
a: %13
subscripted: %32
array: %32
reference
.: %32
One: %32
of: %32
the: %32
two: %32
expressions: %32
must: %32
have: %32
type: %32
`
`
pointer: %32
to: %32
T
'
'
,: %32
where: %32
T: %32
is: %32
some: %13
type
,: %32
and: %32
the: %32
other: %32
must: %32
have: %32
integral: %32
type
;: %32
the: %32
type: %32
of: %32
the: %32
subscript: %32
expression: %32
is: %32
T
.: %32
The: %32
expression: %13
E
1
[
E
2
]: %32
is: %32
identical: %32
(
by: %32
definition
): %32
to: %32
*
(
(
E
1
)
+
(
E
2
)
)
.: %32
See: %32
Par
.
A
.
8
.
6
.
2: %32
for: %32
further: %32
discussion
.: %13
A
.
7
.
3
.
2: %32
Function: %32
Calls: %13
A: %32
function: %32
call: %32
is: %32
a: %32
postfix: %32
expression
,: %32
called: %32
the: %32
function: %32
designator
,: %32
followed: %32
by: %32
parentheses: %32
containing: %13
a: %32
possibly: %32
empty
,: %32
comma
-
separated: %32
list: %32
of: %32
assignment: %32
expressions: %32
(
Par
.
A
7
.
1
7
)
,: %32
which: %32
constitute: %32
the: %13
arguments: %32
to: %32
the: %32
function
.: %32
If: %32
the: %32
postfix: %32
expression: %32
consists: %32
of: %32
an: %32
identifier: %32
for: %32
which: %32
no: %32
declaration: %13
exists: %32
in: %32
the: %32
current: %32
scope
,: %32
the: %32
identifier: %32
is: %32
implicitly: %32
declared: %32
as: %32
if: %32
the: %32
declaration: %13
extern: %32
int: %32
identifier
(
)
;: %13
had: %32
been: %32
given: %32
in: %32
the: %32
innermost: %32
block: %32
containing: %32
the: %32
function: %32
call
.: %32
The: %32
postfix: %32
expression: %32
(
after: %32
possible: %13
explicit: %32
declaration: %32
and: %32
pointer: %32
generation
,: %32
Par
.
A
7
.
1
): %32
must: %32
be: %32
of: %32
type: %32
`
`
pointer: %32
to: %32
function: %32
returning: %32
T
,
'
': %13
for: %32
some: %32
type: %32
T
,: %32
and: %32
the: %32
value: %32
of: %32
the: %32
function: %32
call: %32
has: %32
type: %32
T
.: %13
In: %32
the: %32
first: %32
edition
,: %32
the: %32
type: %32
was: %32
restricted: %32
to: %32
`
`
function
,
'
': %32
and: %32
an: %32
explicit: %32
*: %32
operator: %32
was: %32
required: %32
to: %32
call: %32
through: %13
pointers: %32
to: %32
functions
.: %32
The: %32
ANSI: %32
standard: %32
blesses: %32
the: %32
practice: %32
of: %32
some: %32
existing: %32
compilers: %32
by: %32
permitting: %32
the: %32
same: %13
syntax: %32
for: %32
calls: %32
to: %32
functions: %32
and: %32
to: %32
functions: %32
specified: %32
by: %32
pointers
.: %32
The: %32
older: %32
syntax: %32
is: %32
still: %32
usable
.: %13
The: %32
term: %32
argument: %32
is: %32
used: %32
for: %32
an: %32
expression: %32
passed: %32
by: %32
a: %32
function: %32
call
;: %32
the: %32
term: %32
parameter: %32
is: %32
used: %32
for: %32
an: %13
input: %32
object: %32
(
or: %32
its: %32
identifier
): %32
received: %32
by: %32
a: %32
function: %32
definition
,: %32
or: %32
described: %32
in: %32
a: %32
function: %32
declaration
.: %13
The: %32
terms: %32
`
`
actual: %32
argument: %32
(
parameter
)
'
': %32
and: %32
`
`
formal: %32
argument: %32
(
parameter
)
'
': %32
respectively: %32
are: %13
sometimes: %32
used: %32
for: %32
the: %32
same: %32
distinction
.: %13
In: %32
preparing: %32
for: %32
the: %32
call: %32
to: %32
a: %32
function
,: %32
a: %32
copy: %32
is: %32
made: %32
of: %32
each: %32
argument
;: %32
all: %32
argument
-
passing: %32
is: %32
strictly: %13
by: %32
value
.: %32
A: %32
function: %32
may: %32
change: %32
the: %32
values: %32
of: %32
its: %32
parameter: %32
objects
,: %32
which: %32
are: %32
copies: %32
of: %32
the: %32
argument: %13
expressions
,: %32
but: %32
these: %32
changes: %32
cannot: %32
affect: %32
the: %32
values: %32
of: %32
the: %32
arguments
.: %32
However
,: %32
it: %32
is: %32
possible: %32
to: %32
pass: %32
a: %13
pointer: %32
on: %32
the: %32
understanding: %32
that: %32
the: %32
function: %32
may: %32
change: %32
the: %32
value: %32
of: %32
the: %32
object: %32
to: %32
which: %32
the: %32
pointer: %13
points
.: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
There: %32
are: %32
two: %32
styles: %32
in: %32
which: %32
functions: %32
may: %32
be: %32
declared
.: %32
In: %32
the: %32
new: %32
style
,: %32
the: %32
types: %32
of: %32
parameters: %32
are: %13
explicit: %32
and: %32
are: %32
part: %32
of: %32
the: %32
type: %32
of: %32
the: %32
function
;: %32
such: %32
a: %32
declaration: %32
os: %32
also: %32
called: %32
a: %32
function: %32
prototype
.: %32
In: %13
the: %32
old: %32
style
,: %32
parameter: %32
types: %32
are: %32
not: %32
specified
.: %32
Function: %32
declaration: %32
is: %32
issued: %32
in: %32
Pars
.
A
.
8
.
6
.
3: %32
and: %32
A
.
1
0
.
1
.: %13
If: %32
the: %32
function: %32
declaration: %32
in: %32
scope: %32
for: %32
a: %32
call: %32
is: %32
old
-
style
,: %32
then: %32
default: %32
argument: %32
promotion: %32
is: %32
applied: %32
to: %13
each: %32
argument: %32
as: %32
follows
:: %32
integral: %32
promotion: %32
(
Par
.
A
.
6
.
1
): %32
is: %32
performed: %32
on: %32
each: %32
argument: %32
of: %32
integral: %32
type
,: %13
and: %32
each: %32
float: %32
argument: %32
is: %32
converted: %32
to: %32
double
.: %32
The: %32
effect: %32
of: %32
the: %32
call: %32
is: %32
undefined: %32
if: %32
the: %32
number: %32
of: %13
arguments: %32
disagrees: %32
with: %32
the: %32
number: %32
of: %32
parameters: %32
in: %32
the: %32
definition: %32
of: %32
the: %32
function
,: %32
or: %32
if: %32
the: %32
type: %32
of: %32
an: %13
argument: %32
after: %32
promotion: %32
disagrees: %32
with: %32
that: %32
of: %32
the: %32
corresponding: %32
parameter
.: %32
Type: %32
agreement: %32
depends: %13
on: %32
whether: %32
the: %32
function
'
s: %32
definition: %32
is: %32
new
-
style: %32
or: %32
old
-
style
.: %32
If: %32
it: %32
is: %32
old
-
style
,: %32
then: %32
the: %32
comparison: %32
is: %13
between: %32
the: %32
promoted: %32
type: %32
of: %32
the: %32
arguments: %32
of: %32
the: %32
call
,: %32
and: %32
the: %32
promoted: %32
type: %32
of: %32
the: %32
parameter
,: %32
if: %32
the: %13
definition: %32
is: %32
new
-
style
,: %32
the: %32
promoted: %32
type: %32
of: %32
the: %32
argument: %32
must: %32
be: %32
that: %32
of: %32
the: %32
parameter: %32
itself
,: %32
without: %13
promotion
.: %13
If: %32
the: %32
function: %32
declaration: %32
in: %32
scope: %32
for: %32
a: %32
call: %32
is: %32
new
-
style
,: %32
then: %32
the: %32
arguments: %32
are: %32
converted
,: %32
as: %32
if: %32
by: %13
assignment
,: %32
to: %32
the: %32
types: %32
of: %32
the: %32
corresponding: %32
parameters: %32
of: %32
the: %32
function
'
s: %32
prototype
.: %32
The: %32
number: %32
of: %13
arguments: %32
must: %32
be: %32
the: %32
same: %32
as: %32
the: %32
number: %32
of: %32
explicitly: %32
described: %32
parameters
,: %32
unless: %32
the: %32
declaration
'
s: %13
parameter: %32
list: %32
ends: %32
with: %32
the: %32
ellipsis: %32
notation: %32
(
,: %32
.
.
.
)
.: %32
In: %32
that: %32
case
,: %32
the: %32
number: %32
of: %32
arguments: %32
must: %13
equal: %32
or: %32
exceed: %32
the: %32
number: %32
of: %32
parameters
;: %32
trailing: %32
arguments: %32
beyond: %32
the: %32
explicitly: %32
typed: %32
parameters: %13
suffer: %32
default: %32
argument: %32
promotion: %32
as: %32
described: %32
in: %32
the: %32
preceding: %32
paragraph
.: %32
If: %32
the: %32
definition: %32
of: %32
the: %13
function: %32
is: %32
old
-
style
,: %32
then: %32
the: %32
type: %32
of: %32
each: %32
parameter: %32
in: %32
the: %32
definition
,: %32
after: %32
the: %32
definition: %32
parameter
'
s: %13
type: %32
has: %32
undergone: %32
argument: %32
promotion
.: %13
These: %32
rules: %32
are: %32
especially: %32
complicated: %32
because: %32
they: %32
must: %32
cater: %32
to: %32
a: %32
mixture: %32
of: %32
old
-: %32
and: %32
new
-
style: %32
functions
.: %13
Mixtures: %32
are: %32
to: %32
be: %32
avoided: %32
if: %32
possible
.: %13
The: %32
order: %32
of: %32
evaluation: %32
of: %32
arguments: %32
is: %32
unspecified
;: %32
take: %32
note: %32
that: %32
various: %32
compilers: %32
differ
.: %32
However
,: %13
the: %32
arguments: %32
and: %32
the: %32
function: %32
designator: %32
are: %32
completely: %32
evaluated
,: %32
including: %32
all: %32
side: %32
effects
,: %32
before: %32
the: %13
function: %32
is: %32
entered
.: %32
Recursive: %32
calls: %32
to: %32
any: %32
function: %32
are: %32
permitted
.: %13
A
.
7
.
3
.
3: %32
Structure: %32
References: %13
A: %32
postfix: %32
expression: %32
followed: %32
by: %32
a: %32
dot: %32
followed: %32
by: %32
an: %32
identifier: %32
is: %32
a: %32
postfix: %32
expression
.: %32
The: %32
first: %32
operand: %13
expression: %32
must: %32
be: %32
a: %32
structure: %32
or: %32
a: %32
union
,: %32
and: %32
the: %32
identifier: %32
must: %32
name: %32
a: %32
member: %32
of: %32
the: %32
structure: %32
or: %13
union
.: %32
The: %32
value: %32
is: %32
the: %32
named: %32
member: %32
of: %32
the: %32
structure: %32
or: %32
union
,: %32
and: %32
its: %32
type: %32
is: %32
the: %32
type: %32
of: %32
the: %32
member
.: %13
The: %32
expression: %32
is: %32
an: %32
lvalue: %32
if: %32
the: %32
first: %32
expression: %32
is: %32
an: %32
lvalue
,: %32
and: %32
if: %32
the: %32
type: %32
of: %32
the: %32
second: %32
expression: %32
is: %13
not: %32
an: %32
array: %32
type
.: %13
A: %32
postfix: %32
expression: %32
followed: %32
by: %32
an: %32
arrow: %32
(
built: %32
from: %32
-: %32
and: %32
>
): %32
followed: %32
by: %32
an: %32
identifier: %32
is: %32
a: %32
postfix: %13
expression
.: %32
The: %32
first: %32
operand: %32
expression: %32
must: %32
be: %32
a: %32
pointer: %32
to: %32
a: %32
structure: %32
or: %32
union
,: %32
and: %32
the: %32
identifier: %32
must: %13
name: %32
a: %32
member: %32
of: %32
the: %32
structure: %32
or: %32
union
.: %32
The: %32
result: %32
refers: %32
to: %32
the: %32
named: %32
member: %32
of: %32
the: %32
structure: %32
or: %32
union: %13
to: %32
which: %32
the: %32
pointer: %32
expression: %32
points
,: %32
and: %32
the: %32
type: %32
is: %32
the: %32
type: %32
of: %32
the: %32
member
;: %32
the: %32
result: %32
is: %32
an: %32
lvalue: %32
if: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
the: %32
type: %32
is: %32
not: %32
an: %32
array: %32
type
.: %13
Thus: %32
the: %32
expression: %32
E
1
-
>
MOS: %32
is: %32
the: %32
same: %32
as: %32
(
*
E
1
)
.
MOS
.: %32
Structures: %32
and: %32
unions: %32
are: %32
discussed: %32
in: %13
Par
.
A
.
8
.
3
.: %13
In: %32
the: %32
first: %32
edition: %32
of: %32
this: %32
book
,: %32
it: %32
was: %32
already: %32
the: %32
rule: %32
that: %32
a: %32
member: %32
name: %32
in: %32
such: %32
an: %32
expression: %32
had: %32
to: %32
belong: %32
to: %13
the: %32
structure: %32
or: %32
union: %32
mentioned: %32
in: %32
the: %32
postfix: %32
expression
;: %32
however
,: %32
a: %32
note: %32
admitted: %32
that: %32
this: %32
rule: %32
was: %32
not: %32
firmly: %13
enforced
.: %32
Recent: %32
compilers
,: %32
and: %32
ANSI
,: %32
do: %32
enforce: %32
it
.: %13
A
.
7
.
3
.
4: %32
Postfix: %32
Incrementation: %13
A: %32
postfix: %32
expression: %32
followed: %32
by: %32
a: %32
+
+: %32
or: %32
-
-: %32
operator: %32
is: %32
a: %32
postfix: %32
expression
.: %32
The: %32
value: %32
of: %32
the: %13
expression: %32
is: %32
the: %32
value: %32
of: %32
the: %32
operand
.: %32
After: %32
the: %32
value: %32
is: %32
noted
,: %32
the: %32
operand: %32
is: %32
incremented: %32
+
+: %32
or: %13
decremented: %32
-
-: %32
by: %32
1
.: %32
The: %32
operand: %32
must: %32
be: %32
an: %32
lvalue
;: %32
see: %32
the: %32
discussion: %32
of: %32
additive: %32
operators: %13
(
Par
.
A
.
7
.
7
): %32
and: %32
assignment: %32
(
Par
.
A
.
7
.
1
7
): %32
for: %32
further: %32
constraints: %32
on: %32
the: %32
operand: %32
and: %32
details: %32
of: %32
the: %13
operation
.: %32
The: %32
result: %32
is: %32
not: %32
an: %32
lvalue
.: %13
A
.
7
.
4: %32
Unary: %32
Operators: %13
Expressions: %32
with: %32
unary: %32
operators: %32
group: %32
right
-
to
-
left
.: %13
unary
-
expression
:: %13
postfix: %32
expression: %13
+
+
unary: %32
expression: %13
-
-
unary: %32
expression: %13
unary
-
operator: %32
cast
-
expression: %13
sizeof: %32
unary
-
expression: %13
sizeof
(
type
-
name
): %13
unary: %32
operator
:: %32
one: %32
of: %13
&: %32
*: %32
+: %32
-: %32
~: %32
!: %13
A
.
7
.
4
.
1: %32
Prefix: %32
Incrementation: %32
Operators: %13
A: %32
unary: %32
expression: %32
followed: %32
by: %32
a: %32
+
+: %32
or: %32
-
-: %32
operator: %32
is: %32
a: %32
unary: %32
expression
.: %32
The: %32
operand: %32
is: %32
incremented: %13
+
+: %32
or: %32
decremented: %32
-
-: %32
by: %32
1
.: %32
The: %32
value: %32
of: %32
the: %32
expression: %32
is: %32
the: %32
value: %32
after: %32
the: %32
incrementation: %13
(
decrementation
)
.: %32
The: %32
operand: %32
must: %32
be: %32
an: %32
lvalue
;: %32
see: %32
the: %32
discussion: %32
of: %32
additive: %32
operators: %32
(
Par
.
A
.
7
.
7
): %32
and: %13
assignment: %32
(
Par
.
A
.
7
.
1
7
): %32
for: %32
further: %32
constraints: %32
on: %32
the: %32
operands: %32
and: %32
details: %32
of: %32
the: %32
operation
.: %32
The: %32
result: %32
is: %13
not: %32
an: %32
lvalue
.: %13
A
.
7
.
4
.
2: %32
Address: %32
Operator: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
The: %32
unary: %32
operator: %32
&: %32
takes: %32
the: %32
address: %32
of: %32
its: %32
operand
.: %32
The: %32
operand: %32
must: %32
be: %32
an: %32
lvalue: %32
referring: %32
neither: %32
to: %13
a: %32
bit
-
field: %32
nor: %32
to: %32
an: %32
object: %32
declared: %32
as: %32
register
,: %32
or: %32
must: %32
be: %32
of: %32
function: %32
type
.: %32
The: %32
result: %32
is: %32
a: %32
pointer: %32
to: %13
the: %32
object: %32
or: %32
function: %32
referred: %32
to: %32
by: %32
the: %32
lvalue
.: %32
If: %32
the: %32
type: %32
of: %32
the: %32
operand: %32
is: %32
T
,: %32
the: %32
type: %32
of: %32
the: %32
result: %32
is: %13
`
`
pointer: %32
to: %32
T
.
'
': %13
A
.
7
.
4
.
3: %32
Indirection: %32
Operator: %13
The: %32
unary: %32
*: %32
operator: %32
denotes: %32
indirection
,: %32
and: %32
returns: %32
the: %32
object: %32
or: %32
function: %32
to: %32
which: %32
its: %32
operand: %32
points
.: %13
It: %32
is: %32
an: %32
lvalue: %32
if: %32
the: %32
operand: %32
is: %32
a: %32
pointer: %32
to: %32
an: %32
object: %32
of: %32
arithmetic
,: %32
structure
,: %32
union
,: %32
or: %32
pointer: %32
type
.: %32
If: %32
the: %13
type: %32
of: %32
the: %32
expression: %32
is: %32
`
`
pointer: %32
to: %32
T
,
'
': %32
the: %32
type: %32
of: %32
the: %32
result: %32
is: %32
T
.: %13
A
.
7
.
4
.
4: %32
Unary: %32
Plus: %32
Operator: %13
The: %32
operand: %32
of: %32
the: %32
unary: %32
+: %32
operator: %32
must: %32
have: %32
arithmetic: %32
type
,: %32
and: %32
the: %32
result: %32
is: %32
the: %32
value: %32
of: %32
the: %32
operand
.: %13
An: %32
integral: %32
operand: %32
undergoes: %32
integral: %32
promotion
.: %32
The: %32
type: %32
of: %32
the: %32
result: %32
is: %32
the: %32
type: %32
of: %32
the: %32
promoted: %13
operand
.: %13
The: %32
unary: %32
+: %32
is: %32
new: %32
with: %32
the: %32
ANSI: %32
standard
.: %32
It: %32
was: %32
added: %32
for: %32
symmetry: %32
with: %32
the: %32
unary: %32
-
.: %13
A
.
7
.
4
.
5: %32
Unary: %32
Minus: %32
Operator: %13
The: %32
operand: %32
of: %32
the: %32
unary: %32
-: %32
operator: %32
must: %32
have: %32
arithmetic: %32
type
,: %32
and: %32
the: %32
result: %32
is: %32
the: %32
negative: %32
of: %32
its: %13
operand
.: %32
An: %32
integral: %32
operand: %32
undergoes: %32
integral: %32
promotion
.: %32
The: %32
negative: %32
of: %32
an: %32
unsigned: %32
quantity: %32
is: %13
computed: %32
by: %32
subtracting: %32
the: %32
promoted: %32
value: %32
from: %32
the: %32
largest: %32
value: %32
of: %32
the: %32
promoted: %32
type: %32
and: %32
adding: %32
one
;: %13
but: %32
negative: %32
zero: %32
is: %32
zero
.: %32
The: %32
type: %32
of: %32
the: %32
result: %32
is: %32
the: %32
type: %32
of: %32
the: %32
promoted: %32
operand
.: %13
A
.
7
.
4
.
6: %32
One
'
s: %32
Complement: %32
Operator: %13
The: %32
operand: %32
of: %32
the: %32
~: %32
operator: %32
must: %32
have: %32
integral: %32
type
,: %32
and: %32
the: %32
result: %32
is: %32
the: %32
one
'
s: %32
complement: %32
of: %32
its: %13
operand
.: %32
The: %32
integral: %32
promotions: %32
are: %32
performed
.: %32
If: %32
the: %32
operand: %32
is: %32
unsigned
,: %32
the: %32
result: %32
is: %32
computed: %32
by: %13
subtracting: %32
the: %32
value: %32
from: %32
the: %32
largest: %32
value: %32
of: %32
the: %32
promoted: %32
type
.: %32
If: %32
the: %32
operand: %32
is: %32
signed
,: %32
the: %32
result: %32
is: %13
computed: %32
by: %32
converting: %32
the: %32
promoted: %32
operand: %32
to: %32
the: %32
corresponding: %32
unsigned: %32
type
,: %32
applying: %32
~
,: %32
and: %13
converting: %32
back: %32
to: %32
the: %32
signed: %32
type
.: %32
The: %32
type: %32
of: %32
the: %32
result: %32
is: %32
the: %32
type: %32
of: %32
the: %32
promoted: %32
operand
.: %13
A
.
7
.
4
.
7: %32
Logical: %32
Negation: %32
Operator: %13
The: %32
operand: %32
of: %32
the: %32
!: %32
operator: %32
must: %32
have: %32
arithmetic: %32
type: %32
or: %32
be: %32
a: %32
pointer
,: %32
and: %32
the: %32
result: %32
is: %32
1: %32
if: %32
the: %32
value: %32
of: %13
its: %32
operand: %32
compares: %32
equal: %32
to: %32
0
,: %32
and: %32
0: %32
otherwise
.: %32
The: %32
type: %32
of: %32
the: %32
result: %32
is: %32
int
.: %13
A
.
7
.
4
.
8: %32
Sizeof: %32
Operator: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
The: %32
sizeof: %32
operator: %32
yields: %32
the: %32
number: %32
of: %32
bytes: %32
required: %32
to: %32
store: %32
an: %32
object: %32
of: %32
the: %32
type: %32
of: %32
its: %32
operand
.: %13
The: %32
operand: %32
is: %32
either: %32
an: %32
expression
,: %32
which: %32
is: %32
not: %32
evaluated
,: %32
or: %32
a: %32
parenthesized: %32
type: %32
name
.: %32
When: %13
sizeof: %32
is: %32
applied: %32
to: %32
a: %32
char
,: %32
the: %32
result: %32
is: %32
1
;: %32
when: %32
applied: %32
to: %32
an: %32
array
,: %32
the: %32
result: %32
is: %32
the: %32
total: %32
number: %32
of: %13
bytes: %32
in: %32
the: %32
array
.: %32
When: %32
applied: %32
to: %32
a: %32
structure: %32
or: %32
union
,: %32
the: %32
result: %32
is: %32
the: %32
number: %32
of: %32
bytes: %32
in: %32
the: %32
object
,: %13
including: %32
any: %32
padding: %32
required: %32
to: %32
make: %32
the: %32
object: %32
tile: %32
an: %32
array
:: %32
the: %32
size: %32
of: %32
an: %32
array: %32
of: %32
n: %32
elements: %32
is: %32
n: %13
times: %32
the: %32
size: %32
of: %32
one: %32
element
.: %32
The: %32
operator: %32
may: %32
not: %32
be: %32
applied: %32
to: %32
an: %32
operand: %32
of: %32
function: %32
type
,: %32
or: %32
of: %13
incomplete: %32
type
,: %32
or: %32
to: %32
a: %32
bit
-
field
.: %32
The: %32
result: %32
is: %32
an: %32
unsigned: %32
integral: %32
constant
;: %32
the: %32
particular: %32
type: %32
is: %13
implementation
-
defined
.: %32
The: %32
standard: %32
header: %32
<
stddef
.
h
>: %32
(
See: %32
appendix: %32
B
): %32
defines: %32
this: %32
type: %32
as: %13
size
_
t
.: %13
A
.
7
.
5: %32
Casts: %13
A: %32
unary: %32
expression: %32
preceded: %32
by: %32
the: %32
parenthesized: %32
name: %32
of: %32
a: %32
type: %32
causes: %32
conversion: %32
of: %32
the: %32
value: %32
of: %32
the: %13
expression: %32
to: %32
the: %32
named: %32
type
.: %13
cast
-
expression
:: %13
unary: %32
expression: %13
(
type
-
name
): %32
cast
-
expression: %13
This: %32
construction: %32
is: %32
called: %32
a: %32
cast
.: %32
The: %32
names: %32
are: %32
described: %32
in: %32
Par
.
A
.
8
.
8
.: %32
The: %32
effects: %32
of: %32
conversions: %32
are: %13
described: %32
in: %32
Par
.
A
.
6
.: %32
An: %32
expression: %32
with: %32
a: %32
cast: %32
is: %32
not: %32
an: %32
lvalue
.: %13
A
.
7
.
6: %32
Multiplicative: %32
Operators: %13
The: %32
multiplicative: %32
operators: %32
*
,: %32
/
,: %32
and: %32
%: %32
group: %32
left
-
to
-
right
.: %13
multiplicative
-
expression
:: %13
multiplicative
-
expression: %32
*: %32
cast
-
expression: %13
multiplicative
-
expression: %32
/: %32
cast
-
expression: %13
multiplicative
-
expression: %32
%: %32
cast
-
expression: %13
The: %32
operands: %32
of: %32
*: %32
and: %32
/: %32
must: %32
have: %32
arithmetic: %32
type
;: %32
the: %32
operands: %32
of: %32
%: %32
must: %32
have: %32
integral: %32
type
.: %32
The: %32
usual: %13
arithmetic: %32
conversions: %32
are: %32
performed: %32
on: %32
the: %32
operands
,: %32
and: %32
predict: %32
the: %32
type: %32
of: %32
the: %32
result
.: %13
The: %32
binary: %32
*: %32
operator: %32
denotes: %32
multiplication
.: %13
The: %32
binary: %32
/: %32
operator: %32
yields: %32
the: %32
quotient
,: %32
and: %32
the: %32
%: %32
operator: %32
the: %32
remainder
,: %32
of: %32
the: %32
division: %32
of: %32
the: %32
first: %13
operand: %32
by: %32
the: %32
second
;: %32
if: %32
the: %32
second: %32
operand: %32
is: %32
0
,: %32
the: %32
result: %32
is: %32
undefined
.: %32
Otherwise
,: %32
it: %32
is: %32
always: %32
true: %32
that: %13
(
a
/
b
)
*
b: %32
+: %32
a
%:
b: %32
is: %32
equal: %32
to: %32
a
.: %32
If: %32
both: %32
operands: %32
are: %32
non
-
negative
,: %32
then: %32
the: %32
remainder: %32
is: %32
non
-
negative: %13
and: %32
smaller: %32
than: %32
the: %32
divisor
,: %32
if: %32
not
,: %32
it: %32
is: %32
guaranteed: %32
only: %32
that: %32
the: %32
absolute: %32
value: %32
of: %32
the: %32
remainder: %32
is: %13
smaller: %32
than: %32
the: %32
absolute: %32
value: %32
of: %32
the: %32
divisor
.: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
A
.
7
.
7: %32
Additive: %32
Operators: %13
The: %32
additive: %32
operators: %32
+: %32
and: %32
-: %32
group: %32
left
-
to
-
right
.: %32
If: %32
the: %32
operands: %32
have: %32
arithmetic: %32
type
,: %32
the: %32
usual: %13
arithmetic: %32
conversions: %32
are: %32
performed
.: %32
There: %32
are: %32
some: %32
additional: %32
type: %32
possibilities: %32
for: %32
each: %32
operator
.: %13
additive
-
expression
:: %13
multiplicative
-
expression: %13
additive
-
expression: %32
+: %32
multiplicative
-
expression: %13
additive
-
expression: %32
-: %32
multiplicative
-
expression: %13
The: %32
result: %32
of: %32
the: %32
+: %32
operator: %32
is: %32
the: %32
sum: %32
of: %32
the: %32
operands
.: %32
A: %32
pointer: %32
to: %32
an: %32
object: %32
in: %32
an: %32
array: %32
and: %32
a: %32
value: %32
of: %13
any: %32
integral: %32
type: %32
may: %32
be: %32
added
.: %32
The: %32
latter: %32
is: %32
converted: %32
to: %32
an: %32
address: %32
offset: %32
by: %32
multiplying: %32
it: %32
by: %32
the: %32
size: %13
of: %32
the: %32
object: %32
to: %32
which: %32
the: %32
pointer: %32
points
.: %32
The: %32
sum: %32
is: %32
a: %32
pointer: %32
of: %32
the: %32
same: %32
type: %32
as: %32
the: %32
original: %32
pointer
,: %13
and: %32
points: %32
to: %32
another: %32
object: %32
in: %32
the: %32
same: %32
array
,: %32
appropriately: %32
offset: %32
from: %32
the: %32
original: %32
object
.: %32
Thus: %32
if: %32
P: %32
is: %32
a: %13
pointer: %32
to: %32
an: %32
object: %32
in: %32
an: %32
array
,: %32
the: %32
expression: %32
P
+
1: %32
is: %32
a: %32
pointer: %32
to: %32
the: %32
next: %32
object: %32
in: %32
the: %32
array
.: %32
If: %32
the: %32
sum: %13
pointer: %32
points: %32
outside: %32
the: %32
bounds: %32
of: %32
the: %32
array
,: %32
except: %32
at: %32
the: %32
first: %32
location: %32
beyond: %32
the: %32
high: %32
end
,: %32
the: %32
result: %13
is: %32
undefined
.: %13
The: %32
provision: %32
for: %32
pointers: %32
just: %32
beyond: %32
the: %32
end: %32
of: %32
an: %32
array: %32
is: %32
new
.: %32
It: %32
legitimizes: %32
a: %32
common: %32
idiom: %32
for: %32
looping: %32
over: %13
the: %32
elements: %32
of: %32
an: %32
array
.: %13
The: %32
result: %32
of: %32
the: %32
-: %32
operator: %32
is: %32
the: %32
difference: %32
of: %32
the: %32
operands
.: %32
A: %32
value: %32
of: %32
any: %32
integral: %32
type: %32
may: %32
be: %13
subtracted: %32
from: %32
a: %32
pointer
,: %32
and: %32
then: %32
the: %32
same: %32
conversions: %32
and: %32
conditions: %32
as: %32
for: %32
addition: %32
apply
.: %13
If: %32
two: %32
pointers: %32
to: %32
objects: %32
of: %32
the: %32
same: %32
type: %32
are: %32
subtracted
,: %32
the: %32
result: %32
is: %32
a: %32
signed: %32
integral: %32
value: %32
representing: %13
the: %32
displacement: %32
between: %32
the: %32
pointed
-
to: %32
objects
;: %32
pointers: %32
to: %32
successive: %32
objects: %32
differ: %32
by: %32
1
.: %32
The: %32
type: %32
of: %13
the: %32
result: %32
is: %32
defined: %32
as: %32
ptrdiff
_
t: %32
in: %32
the: %32
standard: %32
header: %32
<
stddef
.
h
>
.: %32
The: %32
value: %32
is: %32
undefined: %32
unless: %13
the: %32
pointers: %32
point: %32
to: %32
objects: %32
within: %32
the: %32
same: %32
array
;: %32
however
,: %32
if: %32
P: %32
points: %32
to: %32
the: %32
last: %32
member: %32
of: %32
an: %32
array
,: %13
then: %32
(
P
+
1
)
-
P: %32
has: %32
value: %32
1
.: %13
A
.
7
.
8: %32
Shift: %32
Operators: %13
The: %32
shift: %32
operators: %32
<
<: %32
and: %32
>
>: %32
group: %32
left
-
to
-
right
.: %32
For: %32
both: %32
operators
,: %32
each: %32
operand: %32
must: %32
be: %32
integral
,: %32
and: %13
is: %32
subject: %32
to: %32
integral: %32
the: %32
promotions
.: %32
The: %32
type: %32
of: %32
the: %32
result: %32
is: %32
that: %32
of: %32
the: %32
promoted: %32
left: %32
operand
.: %32
The: %13
result: %32
is: %32
undefined: %32
if: %32
the: %32
right: %32
operand: %32
is: %32
negative
,: %32
or: %32
greater: %32
than: %32
or: %32
equal: %32
to: %32
the: %32
number: %32
of: %32
bits: %32
in: %32
the: %13
left: %32
expression
'
s: %32
type
.: %13
shift
-
expression
:: %13
additive
-
expression: %13
shift
-
expression: %32
<
<: %32
additive
-
expression: %13
shift
-
expression: %32
>
>: %32
additive
-
expression: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
The: %32
value: %32
of: %32
E
1
<
<
E
2: %32
is: %32
E
1: %32
(
interpreted: %32
as: %32
a: %32
bit: %32
pattern
): %32
left
-
shifted: %32
E
2: %32
bits
;: %32
in: %32
the: %32
absence: %32
of: %32
overflow
,: %13
this: %32
is: %32
equivalent: %32
to: %32
multiplication: %32
by: %32
2
E
2
.: %32
The: %32
value: %32
of: %32
E
1
>
>
E
2: %32
is: %32
E
1: %32
right
-
shifted: %32
E
2: %32
bit: %32
positions
.: %32
The: %13
right: %32
shift: %32
is: %32
equivalent: %32
to: %32
division: %32
by: %32
2
E
2: %32
if: %32
E
1: %32
is: %32
unsigned: %32
or: %32
it: %32
has: %32
a: %32
non
-
negative: %32
value
;: %32
otherwise: %32
the: %13
result: %32
is: %32
implementation
-
defined
.: %13
A
.
7
.
9: %32
Relational: %32
Operators: %13
The: %32
relational: %32
operators: %32
group: %32
left
-
to
-
right
,: %32
but: %32
this: %32
fact: %32
is: %32
not: %32
useful
;: %32
a
<
b
<
c: %32
is: %32
parsed: %32
as: %32
(
a
<
b
)
<
c
,: %32
and: %13
evaluates: %32
to: %32
either: %32
0: %32
or: %32
1
.: %13
relational
-
expression
:: %13
shift
-
expression: %13
relational
-
expression: %32
<: %32
shift
-
expression: %13
relational
-
expression: %32
>: %32
shift
-
expression: %13
relational
-
expression: %32
<
=: %32
shift
-
expression: %13
relational
-
expression: %32
>
=: %32
shift
-
expression: %13
The: %32
operators: %32
<: %32
(
less
)
,: %32
>: %32
(
greater
)
,: %32
<
=: %32
(
less: %32
or: %32
equal
): %32
and: %32
>
=: %32
(
greater: %32
or: %32
equal
): %32
all: %32
yield: %32
0: %32
if: %32
the: %32
specified: %13
relation: %32
is: %32
false: %32
and: %32
1: %32
if: %32
it: %32
is: %32
true
.: %32
The: %32
type: %32
of: %32
the: %32
result: %32
is: %32
int
.: %32
The: %32
usual: %32
arithmetic: %32
conversions: %32
are: %13
performed: %32
on: %32
arithmetic: %32
operands
.: %32
Pointers: %32
to: %32
objects: %32
of: %32
the: %32
same: %32
type: %32
(
ignoring: %32
any: %32
qualifiers
): %32
may: %32
be: %13
compared
;: %32
the: %32
result: %32
depends: %32
on: %32
the: %32
relative: %32
locations: %32
in: %32
the: %32
address: %32
space: %32
of: %32
the: %32
pointed
-
to: %32
objects
.: %13
Pointer: %32
comparison: %32
is: %32
defined: %32
only: %32
for: %32
parts: %32
of: %32
the: %32
same: %32
object
;: %32
if: %32
two: %32
pointers: %32
point: %32
to: %32
the: %32
same: %32
simple: %13
object
,: %32
they: %32
compare: %32
equal
;: %32
if: %32
the: %32
pointers: %32
are: %32
to: %32
members: %32
of: %32
the: %32
same: %32
structure
,: %32
pointers: %32
to: %32
objects: %13
declared: %32
later: %32
in: %32
the: %32
structure: %32
compare: %32
higher
;: %32
if: %32
the: %32
pointers: %32
refer: %32
to: %32
members: %32
of: %32
an: %32
array
,: %32
the: %13
comparison: %32
is: %32
equivalent: %32
to: %32
comparison: %32
of: %32
the: %32
the: %32
corresponding: %32
subscripts
.: %32
If: %32
P: %32
points: %32
to: %32
the: %32
last: %13
member: %32
of: %32
an: %32
array
,: %32
then: %32
P
+
1: %32
compares: %32
higher: %32
than: %32
P
,: %32
even: %32
though: %32
P
+
1: %32
points: %32
outside: %32
the: %32
array
.: %13
Otherwise
,: %32
pointer: %32
comparison: %32
is: %32
undefined
.: %13
These: %32
rules: %32
slightly: %32
liberalize: %32
the: %32
restrictions: %32
stated: %32
in: %32
the: %32
first: %32
edition
,: %32
by: %32
permitting: %32
comparison: %32
of: %32
pointers: %32
to: %13
different: %32
members: %32
of: %32
a: %32
structure: %32
or: %32
union
.: %32
They: %32
also: %32
legalize: %32
comparison: %32
with: %32
a: %32
pointer: %32
just: %32
off: %32
the: %32
end: %32
of: %32
an: %13
array
.: %13
A
.
7
.
1
0: %32
Equality: %32
Operators: %13
equality
-
expression
:: %13
relational
-
expression: %13
equality
-
expression: %32
=
=: %32
relational
-
expression: %13
equality
-
expression: %32
!
=: %32
relational
-
expression: %13
The: %32
=
=: %32
(
equal: %32
to
): %32
and: %32
the: %32
!
=: %32
(
not: %32
equal: %32
to
): %32
operators: %32
are: %32
analogous: %32
to: %32
the: %32
relational: %32
operators: %32
except: %32
for: %13
their: %32
lower: %32
precedence
.: %32
(
Thus: %32
a
<
b: %32
=
=: %32
c
<
d: %32
is: %32
1: %32
whenever: %32
a
<
b: %32
and: %32
c
<
d: %32
have: %32
the: %32
same: %32
truth
-
value
.
): %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
The: %32
equality: %32
operators: %32
follow: %32
the: %32
same: %32
rules: %32
as: %32
the: %32
relational: %32
operators
,: %32
but: %32
permit: %32
additional: %13
possibilities
:: %32
a: %32
pointer: %32
may: %32
be: %32
compared: %32
to: %32
a: %32
constant: %32
integral: %32
expression: %32
with: %32
value: %32
0
,: %32
or: %32
to: %32
a: %32
pointer: %32
to: %13
void
.: %32
See: %32
Par
.
A
.
6
.
6
.: %13
A
.
7
.
1
1: %32
Bitwise: %32
AND: %32
Operator: %13
AND
-
expression
:: %13
equality
-
expression: %13
AND
-
expression: %32
&: %32
equality
-
expression: %13
The: %32
usual: %32
arithmetic: %32
conversions: %32
are: %32
performed
;: %32
the: %32
result: %32
is: %32
the: %32
bitwise: %32
AND: %32
function: %32
of: %32
the: %32
operands
.: %13
The: %32
operator: %32
applies: %32
only: %32
to: %32
integral: %32
operands
.: %13
A
.
7
.
1
2: %32
Bitwise: %32
Exclusive: %32
OR: %32
Operator: %13
exclusive
-
OR
-
expression
:: %13
AND
-
expression: %13
exclusive
-
OR
-
expression: %32
^: %32
AND
-
expression: %13
The: %32
usual: %32
arithmetic: %32
conversions: %32
are: %32
performed
;: %32
the: %32
result: %32
is: %32
the: %32
bitwise: %32
exclusive: %32
OR: %32
function: %32
of: %32
the: %13
operands
.: %32
The: %32
operator: %32
applies: %32
only: %32
to: %32
integral: %32
operands
.: %13
A
.
7
.
1
3: %32
Bitwise: %32
Inclusive: %32
OR: %32
Operator: %13
inclusive
-
OR
-
expression
:: %13
exclusive
-
OR
-
expression: %13
inclusive
-
OR
-
expression: %32
|: %32
exclusive
-
OR
-
expression: %13
The: %32
usual: %32
arithmetic: %32
conversions: %32
are: %32
performed
;: %32
the: %32
result: %32
is: %32
the: %32
bitwise: %32
inclusive: %32
OR: %32
function: %32
of: %32
the: %13
operands
.: %32
The: %32
operator: %32
applies: %32
only: %32
to: %32
integral: %32
operands
.: %13
A
.
7
.
1
4: %32
Logical: %32
AND: %32
Operator: %13
logical
-
AND
-
expression
:: %13
inclusive
-
OR
-
expression: %13
logical
-
AND
-
expression: %32
&
&: %32
inclusive
-
OR
-
expression: %13
The: %32
&
&: %32
operator: %32
groups: %32
left
-
to
-
right
.: %32
It: %32
returns: %32
1: %32
if: %32
both: %32
its: %32
operands: %32
compare: %32
unequal: %32
to: %32
zero
,: %32
0: %13
otherwise
.: %32
Unlike: %32
&
,: %32
&
&: %32
guarantees: %32
left
-
to
-
right: %32
evaluation
:: %32
the: %32
first: %32
operand: %32
is: %32
evaluated
,: %32
including: %32
all: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
side: %32
effects
;: %32
if: %32
it: %32
is: %32
equal: %32
to: %32
0
,: %32
the: %32
value: %32
of: %32
the: %32
expression: %32
is: %32
0
.: %32
Otherwise
,: %32
the: %32
right: %32
operand: %32
is: %32
evaluated
,: %13
and: %32
if: %32
it: %32
is: %32
equal: %32
to: %32
0
,: %32
the: %32
expression
'
s: %32
value: %32
is: %32
0
,: %32
otherwise: %32
1
.: %13
The: %32
operands: %32
need: %32
not: %32
have: %32
the: %32
same: %32
type
,: %32
but: %32
each: %32
must: %32
have: %32
arithmetic: %32
type: %32
or: %32
be: %32
a: %32
pointer
.: %32
The: %32
result: %13
is: %32
int
.: %13
A
.
7
.
1
5: %32
Logical: %32
OR: %32
Operator: %13
logical
-
OR
-
expression
:: %13
logical
-
AND
-
expression: %13
logical
-
OR
-
expression: %32
|
|: %32
logical
-
AND
-
expression: %13
The: %32
|
|: %32
operator: %32
groups: %32
left
-
to
-
right
.: %32
It: %32
returns: %32
1: %32
if: %32
either: %32
of: %32
its: %32
operands: %32
compare: %32
unequal: %32
to: %32
zero
,: %32
and: %32
0: %13
otherwise
.: %32
Unlike: %32
|
,: %32
|
|: %32
guarantees: %32
left
-
to
-
right: %32
evaluation
:: %32
the: %32
first: %32
operand: %32
is: %32
evaluated
,: %32
including: %32
all: %13
side: %32
effects
;: %32
if: %32
it: %32
is: %32
unequal: %32
to: %32
0
,: %32
the: %32
value: %32
of: %32
the: %32
expression: %32
is: %32
1
.: %32
Otherwise
,: %32
the: %32
right: %32
operand: %32
is: %13
evaluated
,: %32
and: %32
if: %32
it: %32
is: %32
unequal: %32
to: %32
0
,: %32
the: %32
expression
'
s: %32
value: %32
is: %32
1
,: %32
otherwise: %32
0
.: %13
The: %32
operands: %32
need: %32
not: %32
have: %32
the: %32
same: %32
type
,: %32
but: %32
each: %32
must: %32
have: %32
arithmetic: %32
type: %32
or: %32
be: %32
a: %32
pointer
.: %32
The: %32
result: %13
is: %32
int
.: %13
A
.
7
.
1
6: %32
Conditional: %32
Operator: %13
conditional
-
expression
:: %13
logical
-
OR
-
expression: %13
logical
-
OR
-
expression: %32
?: %32
expression: %32
:: %32
conditional
-
expression: %13
The: %32
first: %32
expression: %32
is: %32
evaluated
,: %32
including: %32
all: %32
side: %32
effects
;: %32
if: %32
it: %32
compares: %32
unequal: %32
to: %32
0
,: %32
the: %32
result: %32
is: %32
the: %13
value: %32
of: %32
the: %32
second: %32
expression
,: %32
otherwise: %32
that: %32
of: %32
the: %32
third: %32
expression
.: %32
Only: %32
one: %32
of: %32
the: %32
second: %32
and: %32
third: %13
operands: %32
is: %32
evaluated
.: %32
If: %32
the: %32
second: %32
and: %32
third: %32
operands: %32
are: %32
arithmetic
,: %32
the: %32
usual: %32
arithmetic: %32
conversions: %13
are: %32
performed: %32
to: %32
bring: %32
them: %32
to: %32
a: %32
common: %32
type
,: %32
and: %32
that: %32
type: %32
is: %32
the: %32
type: %32
of: %32
the: %32
result
.: %32
If: %32
both: %32
are: %32
void
,: %13
or: %32
structures: %32
or: %32
unions: %32
of: %32
the: %32
same: %32
type
,: %32
or: %32
pointers: %32
to: %32
objects: %32
of: %32
the: %32
same: %32
type
,: %32
the: %32
result: %32
has: %32
the: %13
common: %32
type
.: %32
If: %32
one: %32
is: %32
a: %32
pointer: %32
and: %32
the: %32
other: %32
the: %32
constant: %32
0
,: %32
the: %32
0: %32
is: %32
converted: %32
to: %32
the: %32
pointer: %32
type
,: %32
and: %13
the: %32
result: %32
has: %32
that: %32
type
.: %32
If: %32
one: %32
is: %32
a: %32
pointer: %32
to: %32
void: %32
and: %32
the: %32
other: %32
is: %32
another: %32
pointer
,: %32
the: %32
other: %32
pointer: %32
is: %13
converted: %32
to: %32
a: %32
pointer: %32
to: %32
void
,: %32
and: %32
that: %32
is: %32
the: %32
type: %32
of: %32
the: %32
result
.: %13
In: %32
the: %32
type: %32
comparison: %32
for: %32
pointers
,: %32
any: %32
type: %32
qualifiers: %32
(
Par
.
A
.
8
.
2
): %32
in: %32
the: %32
type: %32
to: %32
which: %32
the: %32
pointer: %32
points: %13
are: %32
insignificant
,: %32
but: %32
the: %32
result: %32
type: %32
inherits: %32
qualifiers: %32
from: %32
both: %32
arms: %32
of: %32
the: %32
conditional
.: %13
A
.
7
.
1
7: %32
Assignment: %32
Expressions: %13
There: %32
are: %32
several: %32
assignment: %32
operators
;: %32
all: %32
group: %32
right
-
to
-
left
.: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
assignment
-
expression
:: %13
conditional
-
expression: %13
unary
-
expression: %32
assignment
-
operator: %32
assignment
-
expression: %13
assignment
-
operator
:: %32
one: %32
of: %13
=: %32
*
=: %32
/
=: %32
%:
=: %32
+
=: %32
-
=: %32
<
<
=: %32
>
>
=: %32
&
=: %32
^
=: %32
|
=: %13
All: %32
require: %32
an: %32
lvalue: %32
as: %32
left: %32
operand
,: %32
and: %32
the: %32
lvalue: %32
must: %32
be: %32
modifiable
:: %32
it: %32
must: %32
not: %32
be: %32
an: %32
array
,: %32
and: %32
must: %13
not: %32
have: %32
an: %32
incomplete: %32
type
,: %32
or: %32
be: %32
a: %32
function
.: %32
Also
,: %32
its: %32
type: %32
must: %32
not: %32
be: %32
qualified: %32
with: %32
const
;: %32
if: %32
it: %32
is: %32
a: %13
structure: %32
or: %32
union
,: %32
it: %32
must: %32
not: %32
have: %32
any: %32
member: %32
or
,: %32
recursively
,: %32
submember: %32
qualified: %32
with: %32
const
.: %32
The: %13
type: %32
of: %32
an: %32
assignment: %32
expression: %32
is: %32
that: %32
of: %32
its: %32
left: %32
operand
,: %32
and: %32
the: %32
value: %32
is: %32
the: %32
value: %32
stored: %32
in: %32
the: %32
left: %13
operand: %32
after: %32
the: %32
assignment: %32
has: %32
taken: %32
place
.: %13
In: %32
the: %32
simple: %32
assignment: %32
with: %32
=
,: %32
the: %32
value: %32
of: %32
the: %32
expression: %32
replaces: %32
that: %32
of: %32
the: %32
object: %32
referred: %32
to: %32
by: %32
the: %13
lvalue
.: %32
One: %32
of: %32
the: %32
following: %32
must: %32
be: %32
true
:: %32
both: %32
operands: %32
have: %32
arithmetic: %32
type
,: %32
in: %32
which: %32
case: %32
the: %32
right: %13
operand: %32
is: %32
converted: %32
to: %32
the: %32
type: %32
of: %32
the: %32
left: %32
by: %32
the: %32
assignment
;: %32
or: %32
both: %32
operands: %32
are: %32
structures: %32
or: %32
unions: %13
of: %32
the: %32
same: %32
type
;: %32
or: %32
one: %32
operand: %32
is: %32
a: %32
pointer: %32
and: %32
the: %32
other: %32
is: %32
a: %32
pointer: %32
to: %32
void
,: %32
or: %32
the: %32
left: %32
operand: %32
is: %32
a: %13
pointer: %32
and: %32
the: %32
right: %32
operand: %32
is: %32
a: %32
constant: %32
expression: %32
with: %32
value: %32
0
;: %32
or: %32
both: %32
operands: %32
are: %32
pointers: %32
to: %13
functions: %32
or: %32
objects: %32
whose: %32
types: %32
are: %32
the: %32
same: %32
except: %32
for: %32
the: %32
possible: %32
absence: %32
of: %32
const: %32
or: %32
volatile: %13
in: %32
the: %32
right: %32
operand
.: %13
An: %32
expression: %32
of: %32
the: %32
form: %32
E
1: %32
op
=: %32
E
2: %32
is: %32
equivalent: %32
to: %32
E
1: %32
=: %32
E
1: %32
op: %32
(
E
2
): %32
except: %32
that: %32
E
1: %32
is: %13
evaluated: %32
only: %32
once
.: %13
A
.
7
.
1
8: %32
Comma: %32
Operator: %13
expression
:: %13
assignment
-
expression: %13
expression: %32
,: %32
assignment
-
expression: %13
A: %32
pair: %32
of: %32
expressions: %32
separated: %32
by: %32
a: %32
comma: %32
is: %32
evaluated: %32
left
-
to
-
right
,: %32
and: %32
the: %32
value: %32
of: %32
the: %32
left: %32
expression: %13
is: %32
discarded
.: %32
The: %32
type: %32
and: %32
value: %32
of: %32
the: %32
result: %32
are: %32
the: %32
type: %32
and: %32
value: %32
of: %32
the: %32
right: %32
operand
.: %32
All: %32
side: %32
effects: %13
from: %32
the: %32
evaluation: %32
of: %32
the: %32
left
-
operand: %32
are: %32
completed: %32
before: %32
beginning: %32
the: %32
evaluation: %32
of: %32
the: %32
right: %13
operand
.: %32
In: %32
contexts: %32
where: %32
comma: %32
is: %32
given: %32
a: %32
special: %32
meaning
,: %32
for: %32
example: %32
in: %32
lists: %32
of: %32
function: %32
arguments: %13
(
Par
.
A
.
7
.
3
.
2
): %32
and: %32
lists: %32
of: %32
initializers: %32
(
Par
.
A
.
8
.
7
)
,: %32
the: %32
required: %32
syntactic: %32
unit: %32
is: %32
an: %32
assignment: %32
expression
,: %13
so: %32
the: %32
comma: %32
operator: %32
appears: %32
only: %32
in: %32
a: %32
parenthetical: %32
grouping
,: %32
for: %32
example
,: %13
f
(
a
,: %32
(
t
=
3
,: %32
t
+
2
)
,: %32
c
): %13
has: %32
three: %32
arguments
,: %32
the: %32
second: %32
of: %32
which: %32
has: %32
the: %32
value: %32
5
.: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
A
.
7
.
1
9: %32
Constant: %32
Expressions: %13
Syntactically
,: %32
a: %32
constant: %32
expression: %32
is: %32
an: %32
expression: %32
restricted: %32
to: %32
a: %32
subset: %32
of: %32
operators
:: %13
constant
-
expression
:: %13
conditional
-
expression: %13
Expressions: %32
that: %32
evaluate: %32
to: %32
a: %32
constant: %32
are: %32
required: %32
in: %32
several: %32
contexts
:: %32
after: %32
case
,: %32
as: %32
array: %32
bounds: %32
and: %13
bit
-
field: %32
lengths
,: %32
as: %32
the: %32
value: %32
of: %32
an: %32
enumeration: %32
constant
,: %32
in: %32
initializers
,: %32
and: %32
in: %32
certain: %32
preprocessor: %13
expressions
.: %13
Constant: %32
expressions: %32
may: %32
not: %32
contain: %32
assignments
,: %32
increment: %32
or: %32
decrement: %32
operators
,: %32
function: %32
calls
,: %32
or: %13
comma: %32
operators
;: %32
except: %32
in: %32
an: %32
operand: %32
of: %32
sizeof
.: %32
If: %32
the: %32
constant: %32
expression: %32
is: %32
required: %32
to: %32
be: %32
integral
,: %13
its: %32
operands: %32
must: %32
consist: %32
of: %32
integer
,: %32
enumeration
,: %32
character
,: %32
and: %32
floating: %32
constants
;: %32
casts: %32
must: %32
specify: %32
an: %13
integral: %32
type
,: %32
and: %32
any: %32
floating: %32
constants: %32
must: %32
be: %32
cast: %32
to: %32
integer
.: %32
This: %32
necessarily: %32
rules: %32
out: %32
arrays
,: %13
indirection
,: %32
address
-
of
,: %32
and: %32
structure: %32
member: %32
operations
.: %32
(
However
,: %32
any: %32
operand: %32
is: %32
permitted: %32
for: %13
sizeof
.
): %13
More: %32
latitude: %32
is: %32
permitted: %32
for: %32
the: %32
constant: %32
expressions: %32
of: %32
initializers
;: %32
the: %32
operands: %32
may: %32
be: %32
any: %32
type: %32
of: %13
constant
,: %32
and: %32
the: %32
unary: %32
&: %32
operator: %32
may: %32
be: %32
applied: %32
to: %32
external: %32
or: %32
static: %32
objects
,: %32
and: %32
to: %32
external: %32
and: %32
static: %13
arrays: %32
subscripted: %32
with: %32
a: %32
constant: %32
expression
.: %32
The: %32
unary: %32
&: %32
operator: %32
can: %32
also: %32
be: %32
applied: %32
implicitly: %32
by: %13
appearance: %32
of: %32
unsubscripted: %32
arrays: %32
and: %32
functions
.: %32
Initializers: %32
must: %32
evaluate: %32
either: %32
to: %32
a: %32
constant: %32
or: %32
to: %32
the: %13
address: %32
of: %32
a: %32
previously: %32
declared: %32
external: %32
or: %32
static: %32
object: %32
plus: %32
or: %32
minus: %32
a: %32
constant
.: %13
Less: %32
latitude: %32
is: %32
allowed: %32
for: %32
the: %32
integral: %32
constant: %32
expressions: %32
after: %32
#
if
;: %32
sizeof: %32
expressions
,: %13
enumeration: %32
constants
,: %32
and: %32
casts: %32
are: %32
not: %32
permitted
.: %32
See: %32
Par
.
A
.
1
2
.
5
.: %13
A
.
8: %32
Declarations: %13
Declarations: %32
specify: %32
the: %32
interpretation: %32
given: %32
to: %32
each: %32
identifier
;: %32
they: %32
do: %32
not: %32
necessarily: %32
reserve: %32
storage: %13
associated: %32
with: %32
the: %32
identifier
.: %32
Declarations: %32
that: %32
reserve: %32
storage: %32
are: %32
called: %32
definitions
.: %32
Declarations: %32
have: %13
the: %32
form: %13
declaration
:: %13
declaration
-
specifiers: %32
init
-
declarator
-
listopt
;: %13
The: %32
declarators: %32
in: %32
the: %32
init
-
declarator: %32
list: %32
contain: %32
the: %32
identifiers: %32
being: %32
declared
;: %32
the: %32
declaration
-
specifiers: %13
consist: %32
of: %32
a: %32
sequence: %32
of: %32
type: %32
and: %32
storage: %32
class: %32
specifiers
.: %13
declaration
-
specifiers
:: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
storage
-
class
-
specifier: %32
declaration
-
specifiersopt: %13
type
-
specifier: %32
declaration
-
specifiersopt: %13
type
-
qualifier: %32
declaration
-
specifiersopt: %13
init
-
declarator
-
list
:: %13
init
-
declarator: %13
init
-
declarator
-
list: %32
,: %32
init
-
declarator: %13
init
-
declarator
:: %13
declarator: %13
declarator: %32
=: %32
initializer: %13
Declarators: %32
will: %32
be: %32
discussed: %32
later: %32
(
Par
.
A
.
8
.
5
)
;: %32
they: %32
contain: %32
the: %32
names: %32
being: %32
declared
.: %32
A: %32
declaration: %13
must: %32
have: %32
at: %32
least: %32
one: %32
declarator
,: %32
or: %32
its: %32
type: %32
specifier: %32
must: %32
declare: %32
a: %32
structure: %32
tag
,: %32
a: %32
union: %32
tag
,: %32
or: %32
the: %13
members: %32
of: %32
an: %32
enumeration
;: %32
empty: %32
declarations: %32
are: %32
not: %32
permitted
.: %13
A
.
8
.
1: %32
Storage: %32
Class: %32
Specifiers: %13
The: %32
storage: %32
class: %32
specifiers: %32
are
:: %13
storage
-
class: %32
specifier
:: %13
auto: %13
register: %13
static: %13
extern: %13
typedef: %13
The: %32
meaning: %32
of: %32
the: %32
storage: %32
classes: %32
were: %32
discussed: %32
in: %32
Par
.
A
.
4
.
4
.: %13
The: %32
auto: %32
and: %32
register: %32
specifiers: %32
give: %32
the: %32
declared: %32
objects: %32
automatic: %32
storage: %32
class
,: %32
and: %32
may: %32
be: %32
used: %13
only: %32
within: %32
functions
.: %32
Such: %32
declarations: %32
also: %32
serve: %32
as: %32
definitions: %32
and: %32
cause: %32
storage: %32
to: %32
be: %32
reserved
.: %32
A: %13
register: %32
declaration: %32
is: %32
equivalent: %32
to: %32
an: %32
auto: %32
declaration
,: %32
but: %32
hints: %32
that: %32
the: %32
declared: %32
objects: %32
will: %32
be: %13
accessed: %32
frequently
.: %32
Only: %32
a: %32
few: %32
objects: %32
are: %32
actually: %32
placed: %32
into: %32
registers
,: %32
and: %32
only: %32
certain: %32
types: %32
are: %13
eligible
;: %32
the: %32
restrictions: %32
are: %32
implementation
-
dependent
.: %32
However
,: %32
if: %32
an: %32
object: %32
is: %32
declared: %32
register
,: %13
the: %32
unary: %32
&: %32
operator: %32
may: %32
not: %32
be: %32
applied: %32
to: %32
it
,: %32
explicitly: %32
or: %32
implicitly
.: %13
The: %32
rule: %32
that: %32
it: %32
is: %32
illegal: %32
to: %32
calculate: %32
the: %32
address: %32
of: %32
an: %32
object: %32
declared: %32
register
,: %32
but: %32
actually: %32
taken: %32
to: %32
be: %32
auto
,: %13
is: %32
new
.: %13
The: %32
static: %32
specifier: %32
gives: %32
the: %32
declared: %32
objects: %32
static: %32
storage: %32
class
,: %32
and: %32
may: %32
be: %32
used: %32
either: %32
inside: %32
or: %13
outside: %32
functions
.: %32
Inside: %32
a: %32
function
,: %32
this: %32
specifier: %32
causes: %32
storage: %32
to: %32
be: %32
allocated
,: %32
and: %32
serves: %32
as: %32
a: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
definition
;: %32
for: %32
its: %32
effect: %32
outside: %32
a: %32
function
,: %32
see: %32
Par
.
A
.
1
1
.
2
.: %13
A: %32
declaration: %32
with: %32
extern
,: %32
used: %32
inside: %32
a: %32
function
,: %32
specifies: %32
that: %32
the: %32
storage: %32
for: %32
the: %32
declared: %32
objects: %32
is: %13
defined: %32
elsewhere
;: %32
for: %32
its: %32
effects: %32
outside: %32
a: %32
function
,: %32
see: %32
Par
.
A
.
1
1
.
2
.: %13
The: %32
typedef: %32
specifier: %32
does: %32
not: %32
reserve: %32
storage: %32
and: %32
is: %32
called: %32
a: %32
storage: %32
class: %32
specifier: %32
only: %32
for: %32
syntactic: %13
convenience
;: %32
it: %32
is: %32
discussed: %32
in: %32
Par
.
A
.
8
.
9
.: %13
At: %32
most: %32
one: %32
storage: %32
class: %32
specifier: %32
may: %32
be: %32
given: %32
in: %32
a: %32
declaration
.: %32
If: %32
none: %32
is: %32
given
,: %32
these: %32
rules: %32
are: %32
used
:: %13
objects: %32
declared: %32
inside: %32
a: %32
function: %32
are: %32
taken: %32
to: %32
be: %32
auto
;: %32
functions: %32
declared: %32
within: %32
a: %32
function: %32
are: %32
taken: %32
to: %13
be: %32
extern
;: %32
objects: %32
and: %32
functions: %32
declared: %32
outside: %32
a: %32
function: %32
are: %32
taken: %32
to: %32
be: %32
static
,: %32
with: %32
external: %13
linkage
.: %32
See: %32
Pars
.: %32
A
.
1
0
-
A
.
1
1
.: %13
A
.
8
.
2: %32
Type: %32
Specifiers: %13
The: %32
type
-
specifiers: %32
are: %13
type: %32
specifier
:: %13
void: %13
char: %13
short: %13
int: %13
long: %13
float: %13
double: %13
signed: %13
unsigned: %13
struct
-
or
-
union
-
specifier: %13
enum
-
specifier: %13
typedef
-
name: %13
At: %32
most: %32
one: %32
of: %32
the: %32
words: %32
long: %32
or: %32
short: %32
may: %32
be: %32
specified: %32
together: %32
with: %32
int
;: %32
the: %32
meaning: %32
is: %32
the: %32
same: %13
if: %32
int: %32
is: %32
not: %32
mentioned
.: %32
The: %32
word: %32
long: %32
may: %32
be: %32
specified: %32
together: %32
with: %32
double
.: %32
At: %32
most: %32
one: %32
of: %13
signed: %32
or: %32
unsigned: %32
may: %32
be: %32
specified: %32
together: %32
with: %32
int: %32
or: %32
any: %32
of: %32
its: %32
short: %32
or: %32
long: %32
varieties
,: %32
or: %13
with: %32
char
.: %32
Either: %32
may: %32
appear: %32
alone: %32
in: %32
which: %32
case: %32
int: %32
is: %32
understood
.: %32
The: %32
signed: %32
specifier: %32
is: %32
useful: %13
for: %32
forcing: %32
char: %32
objects: %32
to: %32
carry: %32
a: %32
sign
;: %32
it: %32
is: %32
permissible: %32
but: %32
redundant: %32
with: %32
other: %32
integral: %32
types
.: %13
Otherwise
,: %32
at: %32
most: %32
one: %32
type
-
specifier: %32
may: %32
be: %32
given: %32
in: %32
a: %32
declaration
.: %32
If: %32
the: %32
type
-
specifier: %32
is: %32
missing: %32
from: %13
a: %32
declaration
,: %32
it: %32
is: %32
taken: %32
to: %32
be: %32
int
.: %13
Types: %32
may: %32
also: %32
be: %32
qualified
,: %32
to: %32
indicate: %32
special: %32
properties: %32
of: %32
the: %32
objects: %32
being: %32
declared
.: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
type
-
qualifier
:: %13
const: %13
volatile: %13
Type: %32
qualifiers: %32
may: %32
appear: %32
with: %32
any: %32
type: %32
specifier
.: %32
A: %32
const: %32
object: %32
may: %32
be: %32
initialized
,: %32
but: %32
not: %13
thereafter: %32
assigned: %32
to
.: %32
There: %32
are: %32
no: %32
implementation
-
dependent: %32
semantics: %32
for: %32
volatile: %32
objects
.: %13
The: %32
const: %32
and: %32
volatile: %32
properties: %32
are: %32
new: %32
with: %32
the: %32
ANSI: %32
standard
.: %32
The: %32
purpose: %32
of: %32
const: %32
is: %32
to: %32
announce: %13
objects: %32
that: %32
may: %32
be: %32
placed: %32
in: %32
read
-
only: %32
memory
,: %32
and: %32
perhaps: %32
to: %32
increase: %32
opportunities: %32
for: %32
optimization
.: %32
The: %13
purpose: %32
of: %32
volatile: %32
is: %32
to: %32
force: %32
an: %32
implementation: %32
to: %32
suppress: %32
optimization: %32
that: %32
could: %32
otherwise: %32
occur
.: %32
For: %13
example
,: %32
for: %32
a: %32
machine: %32
with: %32
memory
-
mapped: %32
input
/
output
,: %32
a: %32
pointer: %32
to: %32
a: %32
device: %32
register: %32
might: %32
be: %32
declared: %32
as: %32
a: %13
pointer: %32
to: %32
volatile
,: %32
in: %32
order: %32
to: %32
prevent: %32
the: %32
compiler: %32
from: %32
removing: %32
apparently: %32
redundant: %32
references: %32
through: %13
the: %32
pointer
.: %32
Except: %32
that: %32
it: %32
should: %32
diagnose: %32
explicit: %32
attempts: %32
to: %32
change: %32
const: %32
objects
,: %32
a: %32
compiler: %32
may: %32
ignore: %13
these: %32
qualifiers
.: %13
A
.
8
.
3: %32
Structure: %32
and: %32
Union: %32
Declarations: %13
A: %32
structure: %32
is: %32
an: %32
object: %32
consisting: %32
of: %32
a: %32
sequence: %32
of: %32
named: %32
members: %32
of: %32
various: %32
types
.: %32
A: %32
union: %32
is: %32
an: %13
object: %32
that: %32
contains
,: %32
at: %32
different: %32
times
,: %32
any: %32
of: %32
several: %32
members: %32
of: %32
various: %32
types
.: %32
Structure: %32
and: %32
union: %13
specifiers: %32
have: %32
the: %32
same: %32
form
.: %13
struct
-
or
-
union
-
specifier
:: %13
struct
-
or
-
union: %32
identifieropt
{: %32
struct
-
declaration
-
list: %32
}: %13
struct
-
or
-
union: %32
identifier: %13
struct
-
or
-
union
:: %13
struct: %13
union: %13
A: %32
struct
-
declaration
-
list: %32
is: %32
a: %32
sequence: %32
of: %32
declarations: %32
for: %32
the: %32
members: %32
of: %32
the: %32
structure: %32
or: %32
union
:: %13
struct
-
declaration
-
list
:: %13
struct: %32
declaration: %13
struct
-
declaration
-
list: %32
struct: %32
declaration: %13
struct
-
declaration
:: %13
specifier
-
qualifier
-
list: %32
struct
-
declarator
-
list
;: %13
specifier
-
qualifier
-
list
:: %13
type
-
specifier: %32
specifier
-
qualifier
-
listopt: %13
type
-
qualifier: %32
specifier
-
qualifier
-
listopt: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
struct
-
declarator
-
list
:: %13
struct
-
declarator: %13
struct
-
declarator
-
list: %32
,: %32
struct
-
declarator: %13
Usually
,: %32
a: %32
struct
-
declarator: %32
is: %32
just: %32
a: %32
declarator: %32
for: %32
a: %32
member: %32
of: %32
a: %32
structure: %32
or: %32
union
.: %32
A: %32
structure: %32
member: %13
may: %32
also: %32
consist: %32
of: %32
a: %32
specified: %32
number: %32
of: %32
bits
.: %32
Such: %32
a: %32
member: %32
is: %32
also: %32
called: %32
a: %32
bit
-
field
;: %32
its: %32
length: %32
is: %32
set: %13
off: %32
from: %32
the: %32
declarator: %32
for: %32
the: %32
field: %32
name: %32
by: %32
a: %32
colon
.: %13
struct
-
declarator
:: %13
declarator: %13
declaratoropt: %32
:: %32
constant
-
expression: %13
A: %32
type: %32
specifier: %32
of: %32
the: %32
form: %13
struct
-
or
-
union: %32
identifier: %32
{: %32
struct
-
declaration
-
list: %32
}: %13
declares: %32
the: %32
identifier: %32
to: %32
be: %32
the: %32
tag: %32
of: %32
the: %32
structure: %32
or: %32
union: %32
specified: %32
by: %32
the: %32
list
.: %32
A: %32
subsequent: %13
declaration: %32
in: %32
the: %32
same: %32
or: %32
an: %32
inner: %32
scope: %32
may: %32
refer: %32
to: %32
the: %32
same: %32
type: %32
by: %32
using: %32
the: %32
tag: %32
in: %32
a: %32
specifier: %13
without: %32
the: %32
list
:: %13
struct
-
or
-
union: %32
identifier: %13
If: %32
a: %32
specifier: %32
with: %32
a: %32
tag: %32
but: %32
without: %32
a: %32
list: %32
appears: %32
when: %32
the: %32
tag: %32
is: %32
not: %32
declared
,: %32
an: %32
incomplete: %32
type: %32
is: %13
specified
.: %32
Objects: %32
with: %32
an: %32
incomplete: %32
structure: %32
or: %32
union: %32
type: %32
may: %32
be: %32
mentioned: %32
in: %32
contexts: %32
where: %32
their: %13
size: %32
is: %32
not: %32
needed
,: %32
for: %32
example: %32
in: %32
declarations: %32
(
not: %32
definitions
)
,: %32
for: %32
specifying: %32
a: %32
pointer
,: %32
or: %32
for: %32
creating: %32
a: %13
typedef
,: %32
but: %32
not: %32
otherwise
.: %32
The: %32
type: %32
becomes: %32
complete: %32
on: %32
occurrence: %32
of: %32
a: %32
subsequent: %32
specifier: %32
with: %13
that: %32
tag
,: %32
and: %32
containing: %32
a: %32
declaration: %32
list
.: %32
Even: %32
in: %32
specifiers: %32
with: %32
a: %32
list
,: %32
the: %32
structure: %32
or: %32
union: %32
type: %32
being: %13
declared: %32
is: %32
incomplete: %32
within: %32
the: %32
list
,: %32
and: %32
becomes: %32
complete: %32
only: %32
at: %32
the: %32
}: %32
terminating: %32
the: %32
specifier
.: %13
A: %32
structure: %32
may: %32
not: %32
contain: %32
a: %32
member: %32
of: %32
incomplete: %32
type
.: %32
Therefore
,: %32
it: %32
is: %32
impossible: %32
to: %32
declare: %32
a: %13
structure: %32
or: %32
union: %32
containing: %32
an: %32
instance: %32
of: %32
itself
.: %32
However
,: %32
besides: %32
giving: %32
a: %32
name: %32
to: %32
the: %32
structure: %32
or: %13
union: %32
type
,: %32
tags: %32
allow: %32
definition: %32
of: %32
self
-
referential: %32
structures
;: %32
a: %32
structure: %32
or: %32
union: %32
may: %32
contain: %32
a: %32
pointer: %13
to: %32
an: %32
instance: %32
of: %32
itself
,: %32
because: %32
pointers: %32
to: %32
incomplete: %32
types: %32
may: %32
be: %32
declared
.: %13
A: %32
very: %32
special: %32
rule: %32
applies: %32
to: %32
declarations: %32
of: %32
the: %32
form: %13
struct
-
or
-
union: %32
identifier
;: %13
that: %32
declare: %32
a: %32
structure: %32
or: %32
union
,: %32
but: %32
have: %32
no: %32
declaration: %32
list: %32
and: %32
no: %32
declarators
.: %32
Even: %32
if: %32
the: %32
identifier: %32
is: %32
a: %13
structure: %32
or: %32
union: %32
tag: %32
already: %32
declared: %32
in: %32
an: %32
outer: %32
scope: %32
(
Par
.
A
.
1
1
.
1
)
,: %32
this: %32
declaration: %32
makes: %32
the: %13
identifier: %32
the: %32
tag: %32
of: %32
a: %32
new
,: %32
incompletely
-
typed: %32
structure: %32
or: %32
union: %32
in: %32
the: %32
current: %32
scope
.: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
This: %32
recondite: %32
is: %32
new: %32
with: %32
ANSI
.: %32
It: %32
is: %32
intended: %32
to: %32
deal: %32
with: %32
mutually
-
recursive: %32
structures: %32
declared: %32
in: %32
an: %32
inner: %13
scope
,: %32
but: %32
whose: %32
tags: %32
might: %32
already: %32
be: %32
declared: %32
in: %32
the: %32
outer: %32
scope
.: %13
A: %32
structure: %32
or: %32
union: %32
specifier: %32
with: %32
a: %32
list: %32
but: %32
no: %32
tag: %32
creates: %32
a: %32
unique: %32
type
;: %32
it: %32
can: %32
be: %32
referred: %32
to: %32
directly: %13
only: %32
in: %32
the: %32
declaration: %32
of: %32
which: %32
it: %32
is: %32
a: %32
part
.: %13
The: %32
names: %32
of: %32
members: %32
and: %32
tags: %32
do: %32
not: %32
conflict: %32
with: %32
each: %32
other: %32
or: %32
with: %32
ordinary: %32
variables
.: %32
A: %32
member: %13
name: %32
may: %32
not: %32
appear: %32
twice: %32
in: %32
the: %32
same: %32
structure: %32
or: %32
union
,: %32
but: %32
the: %32
same: %32
member: %32
name: %32
may: %32
be: %32
used: %32
in: %13
different: %32
structures: %32
or: %32
unions
.: %13
In: %32
the: %32
first: %32
edition: %32
of: %32
this: %32
book
,: %32
the: %32
names: %32
of: %32
structure: %32
and: %32
union: %32
members: %32
were: %32
not: %32
associated: %32
with: %32
their: %32
parent
.: %13
However
,: %32
this: %32
association: %32
became: %32
common: %32
in: %32
compilers: %32
well: %32
before: %32
the: %32
ANSI: %32
standard
.: %13
A: %32
non
-
field: %32
member: %32
of: %32
a: %32
structure: %32
or: %32
union: %32
may: %32
have: %32
any: %32
object: %32
type
.: %32
A: %32
field: %32
member: %32
(
which: %32
need: %32
not: %13
have: %32
a: %32
declarator: %32
and: %32
thus: %32
may: %32
be: %32
unnamed
): %32
has: %32
type: %32
int
,: %32
unsigned: %32
int
,: %32
or: %32
signed: %32
int
,: %32
and: %32
is: %13
interpreted: %32
as: %32
an: %32
object: %32
of: %32
integral: %32
type: %32
of: %32
the: %32
specified: %32
length: %32
in: %32
bits
;: %32
whether: %32
an: %32
int: %32
field: %32
is: %32
treated: %32
as: %13
signed: %32
is: %32
implementation
-
dependent
.: %32
Adjacent: %32
field: %32
members: %32
of: %32
structures: %32
are: %32
packed: %32
into: %13
implementation
-
dependent: %32
storage: %32
units: %32
in: %32
an: %32
implementation
-
dependent: %32
direction
.: %32
When: %32
a: %32
field: %13
following: %32
another: %32
field: %32
will: %32
not: %32
fit: %32
into: %32
a: %32
partially
-
filled: %32
storage: %32
unit
,: %32
it: %32
may: %32
be: %32
split: %32
between: %32
units
,: %32
or: %32
the: %13
unit: %32
may: %32
be: %32
padded
.: %32
An: %32
unnamed: %32
field: %32
with: %32
width: %32
0: %32
forces: %32
this: %32
padding
,: %32
so: %32
that: %32
the: %32
next: %32
field: %32
will: %32
begin: %13
at: %32
the: %32
edge: %32
of: %32
the: %32
next: %32
allocation: %32
unit
.: %13
The: %32
ANSI: %32
standard: %32
makes: %32
fields: %32
even: %32
more: %32
implementation
-
dependent: %32
than: %32
did: %32
the: %32
first: %32
edition
.: %32
It: %32
is: %32
advisable: %32
to: %13
read: %32
the: %32
language: %32
rules: %32
for: %32
storing: %32
bit
-
fields: %32
as: %32
`
`
implementation
-
dependent
'
': %32
without: %32
qualification
.: %32
Structures: %32
with: %13
bit
-
fields: %32
may: %32
be: %32
used: %32
as: %32
a: %32
portable: %32
way: %32
of: %32
attempting: %32
to: %32
reduce: %32
the: %32
storage: %32
required: %32
for: %32
a: %32
structure: %32
(
with: %32
the: %13
probable: %32
cost: %32
of: %32
increasing: %32
the: %32
instruction: %32
space
,: %32
and: %32
time
,: %32
needed: %32
to: %32
access: %32
the: %32
fields
)
,: %32
or: %32
as: %32
a: %32
non
-
portable: %32
way: %13
to: %32
describe: %32
a: %32
storage: %32
layout: %32
known: %32
at: %32
the: %32
bit
-
level
.: %32
In: %32
the: %32
second: %32
case
,: %32
it: %32
is: %32
necessary: %32
to: %32
understand: %32
the: %32
rules: %32
of: %32
the: %13
local: %32
implementation
.: %13
The: %32
members: %32
of: %32
a: %32
structure: %32
have: %32
addresses: %32
increasing: %32
in: %32
the: %32
order: %32
of: %32
their: %32
declarations
.: %32
A: %32
non
-
field: %13
member: %32
of: %32
a: %32
structure: %32
is: %32
aligned: %32
at: %32
an: %32
addressing: %32
boundary: %32
depending: %32
on: %32
its: %32
type
;: %32
therefore
,: %32
there: %32
may: %32
be: %13
unnamed: %32
holes: %32
in: %32
a: %32
structure
.: %32
If: %32
a: %32
pointer: %32
to: %32
a: %32
structure: %32
is: %32
cast: %32
to: %32
the: %32
type: %32
of: %32
a: %32
pointer: %32
to: %32
its: %32
first: %32
member
,: %13
the: %32
result: %32
refers: %32
to: %32
the: %32
first: %32
member
.: %13
A: %32
union: %32
may: %32
be: %32
thought: %32
of: %32
as: %32
a: %32
structure: %32
all: %32
of: %32
whose: %32
members: %32
begin: %32
at: %32
offset: %32
0: %32
and: %32
whose: %32
size: %32
is: %13
sufficient: %32
to: %32
contain: %32
any: %32
of: %32
its: %32
members
.: %32
At: %32
most: %32
one: %32
of: %32
the: %32
members: %32
can: %32
be: %32
stored: %32
in: %32
a: %32
union: %32
at: %32
any: %13
time
.: %32
If: %32
a: %32
pointr: %32
to: %32
a: %32
union: %32
is: %32
cast: %32
to: %32
the: %32
type: %32
of: %32
a: %32
pointer: %32
to: %32
a: %32
member
,: %32
the: %32
result: %32
refers: %32
to: %32
that: %32
member
.: %13
A: %32
simple: %32
example: %32
of: %32
a: %32
structure: %32
declaration: %32
is: %13
struct: %32
tnode: %32
{: %13
char: %32
tword
[
2
0
]
;: %13
int: %32
count
;: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
struct: %32
tnode: %32
*
left
;: %13
struct: %32
tnode: %32
*
right
;: %13
}: %13
which: %32
contains: %32
an: %32
array: %32
of: %32
2
0: %32
characters
,: %32
an: %32
integer
,: %32
and: %32
two: %32
pointers: %32
to: %32
similar: %32
structures
.: %32
Once: %32
this: %13
declaration: %32
has: %32
bene: %32
given
,: %32
the: %32
declaration: %13
struct: %32
tnode: %32
s
,: %32
*
sp
;: %13
declares: %32
s: %32
to: %32
be: %32
a: %32
structure: %32
of: %32
the: %32
given: %32
sort
,: %32
and: %32
sp: %32
to: %32
be: %32
a: %32
pointer: %32
to: %32
a: %32
structure: %32
of: %32
the: %32
given: %32
sort
.: %32
With: %13
these: %32
declarations
,: %32
the: %32
expression: %13
sp
-
>
count: %13
refers: %32
to: %32
the: %32
count: %32
field: %32
of: %32
the: %32
structure: %32
to: %32
which: %32
sp: %32
points
;: %13
s
.
left: %13
refers: %32
to: %32
the: %32
left: %32
subtree: %32
pointer: %32
of: %32
the: %32
structure: %32
s
,: %32
and: %13
s
.
right
-
>
tword
[
0
]: %13
refers: %32
to: %32
the: %32
first: %32
character: %32
of: %32
the: %32
tword: %32
member: %32
of: %32
the: %32
right: %32
subtree: %32
of: %32
s
.: %13
In: %32
general
,: %32
a: %32
member: %32
of: %32
a: %32
union: %32
may: %32
not: %32
be: %32
inspected: %32
unless: %32
the: %32
value: %32
of: %32
the: %32
union: %32
has: %32
been: %32
assigned: %13
using: %32
the: %32
same: %32
member
.: %32
However
,: %32
one: %32
special: %32
guarantee: %32
simplifies: %32
the: %32
use: %32
of: %32
unions
:: %32
if: %32
a: %32
union: %32
contains: %13
several: %32
structures: %32
that: %32
share: %32
a: %32
common: %32
initial: %32
sequence
,: %32
and: %32
the: %32
union: %32
currently: %32
contains: %32
one: %32
of: %32
these: %13
structures
,: %32
it: %32
is: %32
permitted: %32
to: %32
refer: %32
to: %32
the: %32
common: %32
initial: %32
part: %32
of: %32
any: %32
of: %32
the: %32
contained: %32
structures
.: %32
For: %13
example
,: %32
the: %32
following: %32
is: %32
a: %32
legal: %32
fragment
:: %13
union: %32
{: %13
struct: %32
{: %13
int: %32
type
;: %13
}: %32
n
;: %13
struct: %32
{: %13
int: %32
type
;: %13
int: %32
intnode
;: %13
}: %32
ni
;: %13
struct: %32
{: %13
int: %32
type
;: %13
float: %32
floatnode
;: %13
}: %32
nf
;: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
}: %32
u
;: %13
.
.
.: %13
u
.
nf
.
type: %32
=: %32
FLOAT
;: %13
u
.
nf
.
floatnode: %32
=: %32
3
.
1
4
;: %13
.
.
.: %13
if: %32
(
u
.
n
.
type: %32
=
=: %32
FLOAT
): %13
.
.
.: %32
sin
(
u
.
nf
.
floatnode
): %32
.
.
.: %13
A
.
8
.
4: %32
Enumerations: %13
Enumerations: %32
are: %32
unique: %32
types: %32
with: %32
values: %32
ranging: %32
over: %32
a: %32
set: %32
of: %32
named: %32
constants: %32
called: %32
enumerators
.: %13
The: %32
form: %32
of: %32
an: %32
enumeration: %32
specifier: %32
borrows: %32
from: %32
that: %32
of: %32
structures: %32
and: %32
unions
.: %13
enum
-
specifier
:: %13
enum: %32
identifieropt: %32
{: %32
enumerator
-
list: %32
}: %13
enum: %32
identifier: %13
enumerator
-
list
:: %13
enumerator: %13
enumerator
-
list: %32
,: %32
enumerator: %13
enumerator
:: %13
identifier: %13
identifier: %32
=: %32
constant
-
expression: %13
The: %32
identifiers: %32
in: %32
an: %32
enumerator: %32
list: %32
are: %32
declared: %32
as: %32
constants: %32
of: %32
type: %32
int
,: %32
and: %32
may: %32
appear: %32
wherever: %13
constants: %32
are: %32
required
.: %32
If: %32
no: %32
enumerations: %32
with: %32
=: %32
appear
,: %32
then: %32
the: %32
values: %32
of: %32
the: %32
corresponding: %32
constants: %13
begin: %32
at: %32
0: %32
and: %32
increase: %32
by: %32
1: %32
as: %32
the: %32
declaration: %32
is: %32
read: %32
from: %32
left: %32
to: %32
right
.: %32
An: %32
enumerator: %32
with: %32
=: %32
gives: %32
the: %13
associated: %32
identifier: %32
the: %32
value: %32
specified
;: %32
subsequent: %32
identifiers: %32
continue: %32
the: %32
progression: %32
from: %32
the: %13
assigned: %32
value
.: %13
Enumerator: %32
names: %32
in: %32
the: %32
same: %32
scope: %32
must: %32
all: %32
be: %32
distinct: %32
from: %32
each: %32
other: %32
and: %32
from: %32
ordinary: %32
variable: %13
names
,: %32
but: %32
the: %32
values: %32
need: %32
not: %32
be: %32
distinct
.: %13
The: %32
role: %32
of: %32
the: %32
identifier: %32
in: %32
the: %32
enum
-
specifier: %32
is: %32
analogous: %32
to: %32
that: %32
of: %32
the: %32
structure: %32
tag: %32
in: %32
a: %32
struct
-: %13
specifier
;: %32
it: %32
names: %32
a: %32
particular: %32
enumeration
.: %32
The: %32
rules: %32
for: %32
enum
-
specifiers: %32
with: %32
and: %32
without: %32
tags: %32
and: %32
lists: %13
are: %32
the: %32
same: %32
as: %32
those: %32
for: %32
structure: %32
or: %32
union: %32
specifiers
,: %32
except: %32
that: %32
incomplete: %32
enumeration: %32
types: %32
do: %32
not: %13
exist
;: %32
the: %32
tag: %32
of: %32
an: %32
enum
-
specifier: %32
without: %32
an: %32
enumerator: %32
list: %32
must: %32
refer: %32
to: %32
an: %32
in
-
scope: %32
specifier: %32
with: %32
a: %13
list
.: %13
Enumerations: %32
are: %32
new: %32
since: %32
the: %32
first: %32
edition: %32
of: %32
this: %32
book
,: %32
but: %32
have: %32
been: %32
part: %32
of: %32
the: %32
language: %32
for: %32
some: %32
years
.: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
A
.
8
.
5: %32
Declarators: %13
Declarators: %32
have: %32
the: %32
syntax
:: %13
declarator
:: %13
pointeropt: %32
direct
-
declarator: %13
direct
-
declarator
:: %13
identifier: %13
(
declarator
): %13
direct
-
declarator: %32
[: %32
constant
-
expressionopt: %32
]: %13
direct
-
declarator: %32
(: %32
parameter
-
type
-
list: %32
): %13
direct
-
declarator: %32
(: %32
identifier
-
listopt: %32
): %13
pointer
:: %13
*: %32
type
-
qualifier
-
listopt: %13
*: %32
type
-
qualifier
-
listopt: %32
pointer: %13
type
-
qualifier
-
list
:: %13
type
-
qualifier: %13
type
-
qualifier
-
list: %32
type
-
qualifier: %13
The: %32
structure: %32
of: %32
declarators: %32
resembles: %32
that: %32
of: %32
indirection
,: %32
function
,: %32
and: %32
array: %32
expressions
;: %32
the: %32
grouping: %32
is: %13
the: %32
same
.: %13
A
.
8
.
6: %32
Meaning: %32
of: %32
Declarators: %13
A: %32
list: %32
of: %32
declarators: %32
appears: %32
after: %32
a: %32
sequence: %32
of: %32
type: %32
and: %32
storage: %32
class: %32
specifiers
.: %32
Each: %32
declarator: %13
declares: %32
a: %32
unique: %32
main: %32
identifier
,: %32
the: %32
one: %32
that: %32
appears: %32
as: %32
the: %32
first: %32
alternative: %32
of: %32
the: %32
production: %32
for: %32
direct
-: %13
declarator
.: %32
The: %32
storage: %32
class: %32
specifiers: %32
apply: %32
directly: %32
to: %32
this: %32
identifier
,: %32
but: %32
its: %32
type: %32
depends: %32
on: %32
the: %32
form: %13
of: %32
its: %32
declarator
.: %32
A: %32
declarator: %32
is: %32
read: %32
as: %32
an: %32
assertion: %32
that: %32
when: %32
its: %32
identifier: %32
appears: %32
in: %32
an: %32
expression: %32
of: %13
the: %32
same: %32
form: %32
as: %32
the: %32
declarator
,: %32
it: %32
yields: %32
an: %32
object: %32
of: %32
the: %32
specified: %32
type
.: %13
Considering: %32
only: %32
the: %32
type: %32
parts: %32
of: %32
the: %32
declaration: %32
specifiers: %32
(
Par
.: %32
A
.
8
.
2
): %32
and: %32
a: %32
particular: %32
declarator
,: %32
a: %13
declaration: %32
has: %32
the: %32
form: %32
`
`
T: %32
D
,
'
': %32
where: %32
T: %32
is: %32
a: %32
type: %32
and: %32
D: %32
is: %32
a: %32
declarator
.: %32
The: %32
type: %32
attributed: %32
to: %32
the: %13
identifier: %32
in: %32
the: %32
various: %32
forms: %32
of: %32
declarator: %32
is: %32
described: %32
inductively: %32
using: %32
this: %32
notation
.: %13
In: %32
a: %32
declaration: %32
T: %32
D: %32
where: %32
D: %32
is: %32
an: %32
unadored: %32
identifier
,: %32
the: %32
type: %32
of: %32
the: %32
identifier: %32
is: %32
T
.: %13
In: %32
a: %32
declaration: %32
T: %32
D: %32
where: %32
D: %32
has: %32
the: %32
form: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
(: %32
D
1: %32
): %13
then: %32
the: %32
type: %32
of: %32
the: %32
identifier: %32
in: %32
D
1: %32
is: %32
the: %32
same: %32
as: %32
that: %32
of: %32
D
.: %32
The: %32
parentheses: %32
do: %32
not: %32
alter: %32
the: %32
type
,: %32
but: %13
may: %32
change: %32
the: %32
binding: %32
of: %32
complex: %32
declarators
.: %13
A
.
8
.
6
.
1: %32
Pointer: %32
Declarators: %13
In: %32
a: %32
declaration: %32
T: %32
D: %32
where: %32
D: %32
has: %32
the: %32
form: %13
*: %32
type
-
qualifier
-
listopt: %32
D
1: %13
and: %32
the: %32
type: %32
of: %32
the: %32
identifier: %32
in: %32
the: %32
declaration: %32
T: %32
D
1: %32
is: %32
`
`
type
-
modifier: %32
T
,
'
': %32
the: %32
type: %32
of: %32
the: %32
identifier: %32
of: %32
D: %13
is: %32
`
`
type
-
modifier: %32
type
-
qualifier
-
list: %32
pointer: %32
to: %32
T
.
'
': %32
Qualifiers: %32
following: %32
*: %32
apply: %32
to: %32
pointer: %32
itself
,: %32
rather: %13
than: %32
to: %32
the: %32
object: %32
to: %32
which: %32
the: %32
pointer: %32
points
.: %13
For: %32
example
,: %32
consider: %32
the: %32
declaration: %13
int: %32
*
ap
[
]
;: %13
Here
,: %32
ap
[
]: %32
plays: %32
the: %32
role: %32
of: %32
D
1
;: %32
a: %32
declaration: %32
`
`
int: %32
ap
[
]
'
': %32
(
below
): %32
would: %32
give: %32
ap: %32
the: %32
type: %32
`
`
array: %32
of: %13
int
,
'
': %32
the: %32
type
-
qualifier: %32
list: %32
is: %32
empty
,: %32
and: %32
the: %32
type
-
modifier: %32
is: %32
`
`
array: %32
of
.
'
': %32
Hence: %32
the: %32
actual: %32
declaration: %13
gives: %32
ap: %32
the: %32
type: %32
`
`
array: %32
to: %32
pointers: %32
to: %32
int
.
'
': %13
As: %32
other: %32
examples
,: %32
the: %32
declarations: %13
int: %32
i
,: %32
*
pi
,: %32
*
const: %32
cpi: %32
=: %32
&
i
;: %13
const: %32
int: %32
ci: %32
=: %32
3
,: %32
*
pci
;: %13
declare: %32
an: %32
integer: %32
i: %32
and: %32
a: %32
pointer: %32
to: %32
an: %32
integer: %32
pi
.: %32
The: %32
value: %32
of: %32
the: %32
constant: %32
pointer: %32
cpi: %32
may: %32
not: %32
be: %13
changed
;: %32
it: %32
will: %32
always: %32
point: %32
to: %32
the: %32
same: %32
location
,: %32
although: %32
the: %32
value: %32
to: %32
which: %32
it: %32
refers: %32
may: %32
be: %32
altered
.: %13
The: %32
integer: %32
ci: %32
is: %32
constant
,: %32
and: %32
may: %32
not: %32
be: %32
changed: %32
(
though: %32
it: %32
may: %32
be: %32
initialized
,: %32
as: %32
here
.
): %32
The: %32
type: %32
of: %13
pci: %32
is: %32
`
`
pointer: %32
to: %32
const: %32
int
,
'
': %32
and: %32
pci: %32
itself: %32
may: %32
be: %32
changed: %32
to: %32
point: %32
to: %32
another: %32
place
,: %32
but: %32
the: %32
value: %13
to: %32
which: %32
it: %32
points: %32
may: %32
not: %32
be: %32
altered: %32
by: %32
assigning: %32
through: %32
pci
.: %13
A
.
8
.
6
.
2: %32
Array: %32
Declarators: %13
In: %32
a: %32
declaration: %32
T: %32
D: %32
where: %32
D: %32
has: %32
the: %32
form: %13
D
1: %32
[
constant
-
expressionopt
]: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
and: %32
the: %32
type: %32
of: %32
the: %32
identifier: %32
in: %32
the: %32
declaration: %32
T: %32
D
1: %32
is: %32
`
`
type
-
modifier: %32
T
,
'
': %32
the: %32
type: %32
of: %32
the: %32
identifier: %32
of: %32
D: %13
is: %32
`
`
type
-
modifier: %32
array: %32
of: %32
T
.
'
': %32
If: %32
the: %32
constant
-
expression: %32
is: %32
present
,: %32
it: %32
must: %32
have: %32
integral: %32
type
,: %32
and: %32
value: %13
greater: %32
than: %32
0
.: %32
If: %32
the: %32
constant: %32
expression: %32
specifying: %32
the: %32
bound: %32
is: %32
missing
,: %32
the: %32
array: %32
has: %32
an: %32
incomplete: %13
type
.: %13
An: %32
array: %32
may: %32
be: %32
constructed: %32
from: %32
an: %32
arithmetic: %32
type
,: %32
from: %32
a: %32
pointer
,: %32
from: %32
a: %32
structure: %32
or: %32
union
,: %32
or: %32
from: %13
another: %32
array: %32
(
to: %32
generate: %32
a: %32
multi
-
dimensional: %32
array
)
.: %32
Any: %32
type: %32
from: %32
which: %32
an: %32
array: %32
is: %32
constructed: %32
must: %13
be: %32
complete
;: %32
it: %32
must: %32
not: %32
be: %32
an: %32
array: %32
of: %32
structure: %32
of: %32
incomplete: %32
type
.: %32
This: %32
implies: %32
that: %32
for: %32
a: %32
multi
-: %13
dimensional: %32
array
,: %32
only: %32
the: %32
first: %32
dimension: %32
may: %32
be: %32
missing
.: %32
The: %32
type: %32
of: %32
an: %32
object: %32
of: %32
incomplete: %32
aray: %13
type: %32
is: %32
completed: %32
by: %32
another
,: %32
complete
,: %32
declaration: %32
for: %32
the: %32
object: %32
(
Par
.
A
.
1
0
.
2
)
,: %32
or: %32
by: %32
initializing: %32
it: %13
(
Par
.
A
.
8
.
7
)
.: %32
For: %32
example
,: %13
float: %32
fa
[
1
7
]
,: %32
*
afp
[
1
7
]
;: %13
declares: %32
an: %32
array: %32
of: %32
float: %32
numbers: %32
and: %32
an: %32
array: %32
of: %32
pointers: %32
to: %32
float: %32
numbers
.: %32
Also
,: %13
static: %32
int: %32
x
3
d
[
3
]
[
5
]
[
7
]
;: %13
declares: %32
a: %32
static: %32
three
-
dimensional: %32
array: %32
of: %32
integers
,: %32
with: %32
rank: %32
3: %32
X: %32
5: %32
X: %32
7
.: %32
In: %32
complete: %32
detail
,: %32
x
3
d: %32
is: %32
an: %13
array: %32
of: %32
three: %32
items
:: %32
each: %32
item: %32
is: %32
an: %32
array: %32
of: %32
five: %32
arrays
;: %32
each: %32
of: %32
the: %32
latter: %32
arrays: %32
is: %32
an: %32
array: %32
of: %32
seven: %13
integers
.: %32
Any: %32
of: %32
the: %32
expressions: %32
x
3
d
,: %32
x
3
d
[
i
]
,: %32
x
3
d
[
i
]
[
j
]
,: %32
x
3
d
[
i
]
[
j
]
[
k
]: %32
may: %32
reasonably: %32
appear: %13
in: %32
an: %32
expression
.: %32
The: %32
first: %32
three: %32
have: %32
type: %32
`
`
array
,
'
'
,: %32
the: %32
last: %32
has: %32
type: %32
int
.: %32
More: %32
specifically
,: %13
x
3
d
[
i
]
[
j
]: %32
is: %32
an: %32
array: %32
of: %32
7: %32
integers
,: %32
and: %32
x
3
d
[
i
]: %32
is: %32
an: %32
array: %32
of: %32
5: %32
arrays: %32
of: %32
7: %32
integers
.: %13
The: %32
array: %32
subscripting: %32
operation: %32
is: %32
defined: %32
so: %32
that: %32
E
1
[
E
2
]: %32
is: %32
identical: %32
to: %32
*
(
E
1
+
E
2
)
.: %32
Therefore
,: %13
despite: %32
its: %32
asymmetric: %32
appearance
,: %32
subscripting: %32
is: %32
a: %32
commutative: %32
operation
.: %32
Because: %32
of: %32
the: %32
conversion: %13
rules: %32
that: %32
apply: %32
to: %32
+: %32
and: %32
to: %32
arrays: %32
(
Pars
.
A
6
.
6
,: %32
A
.
7
.
1
,: %32
A
.
7
.
7
)
,: %32
if: %32
E
1: %32
is: %32
an: %32
array: %32
and: %32
E
2: %32
an: %32
integer
,: %32
then: %13
E
1
[
E
2
]: %32
refers: %32
to: %32
the: %32
E
2
-
th: %32
member: %32
of: %32
E
1
.: %13
In: %32
the: %32
example
,: %32
x
3
d
[
i
]
[
j
]
[
k
]: %32
is: %32
equivalent: %32
to: %32
*
(
x
3
d
[
i
]
[
j
]: %32
+: %32
k
)
.: %32
The: %32
first: %32
subexpression: %13
x
3
d
[
i
]
[
j
]: %32
is: %32
converted: %32
by: %32
Par
.
A
.
7
.
1: %32
to: %32
type: %32
`
`
pointer: %32
to: %32
array: %32
of: %32
integers
,
'
': %32
by: %32
Par
.
A
.
7
.
7
,: %32
the: %32
addition: %13
involves: %32
multiplication: %32
by: %32
the: %32
size: %32
of: %32
an: %32
integer
.: %32
It: %32
follows: %32
from: %32
the: %32
rules: %32
that: %32
arrays: %32
are: %32
stored: %32
by: %32
rows: %13
(
last: %32
subscript: %32
varies: %32
fastest
): %32
and: %32
that: %32
the: %32
first: %32
subscript: %32
in: %32
the: %32
declaration: %32
helps: %32
determine: %32
the: %32
amount: %32
of: %13
storage: %32
consumed: %32
by: %32
an: %32
array
,: %32
but: %32
plays: %32
no: %32
other: %32
part: %32
in: %32
subscript: %32
calculations
.: %13
A
.
8
.
6
.
3: %32
Function: %32
Declarators: %13
In: %32
a: %32
new
-
style: %32
function: %32
declaration: %32
T: %32
D: %32
where: %32
D: %32
has: %32
the: %32
form: %13
D
1: %32
(
parameter
-
type
-
list
): %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
and: %32
the: %32
type: %32
of: %32
the: %32
identifier: %32
in: %32
the: %32
declaration: %32
T: %32
D
1: %32
is: %32
`
`
type
-
modifier: %32
T
,
'
': %32
the: %32
type: %32
of: %32
the: %32
identifier: %32
of: %32
D: %13
is: %32
`
`
type
-
modifier: %32
function: %32
with: %32
arguments: %32
parameter
-
type
-
list: %32
returning: %32
T
.
'
': %13
The: %32
syntax: %32
of: %32
the: %32
parameters: %32
is: %13
parameter
-
type
-
list
:: %13
parameter
-
list: %13
parameter
-
list: %32
,: %32
.
.
.: %13
parameter
-
list
:: %13
parameter
-
declaration: %13
parameter
-
list: %32
,: %32
parameter
-
declaration: %13
parameter
-
declaration
:: %13
declaration
-
specifiers: %32
declarator: %13
declaration
-
specifiers: %32
abstract
-
declaratoropt: %13
In: %32
the: %32
new
-
style: %32
declaration
,: %32
the: %32
parameter: %32
list: %32
specifies: %32
the: %32
types: %32
of: %32
the: %32
parameters
.: %32
As: %32
a: %32
special: %32
case
,: %13
the: %32
declarator: %32
for: %32
a: %32
new
-
style: %32
function: %32
with: %32
no: %32
parameters: %32
has: %32
a: %32
parameter: %32
list: %32
consisting: %32
soley: %32
of: %32
the: %13
keyword: %32
void
.: %32
If: %32
the: %32
parameter: %32
list: %32
ends: %32
with: %32
an: %32
ellipsis: %32
`
`
,: %32
.
.
.
'
'
,: %32
then: %32
the: %32
function: %32
may: %32
accept: %32
more: %13
arguments: %32
than: %32
the: %32
number: %32
of: %32
parameters: %32
explicitly: %32
described
,: %32
see: %32
Par
.
A
.
7
.
3
.
2
.: %13
The: %32
types: %32
of: %32
parameters: %32
that: %32
are: %32
arrays: %32
or: %32
functions: %32
are: %32
altered: %32
to: %32
pointers
,: %32
in: %32
accordance: %32
with: %32
the: %32
rules: %13
for: %32
parameter: %32
conversions
;: %32
see: %32
Par
.
A
.
1
0
.
1
.: %32
The: %32
only: %32
storage: %32
class: %32
specifier: %32
permitted: %32
in: %32
a: %32
parameter
'
s: %13
declaration: %32
is: %32
register
,: %32
and: %32
this: %32
specifier: %32
is: %32
ignored: %32
unless: %32
the: %32
function: %32
declarator: %32
heads: %32
a: %32
function: %13
definition
.: %32
Similarly
,: %32
if: %32
the: %32
declarators: %32
in: %32
the: %32
parameter: %32
declarations: %32
contain: %32
identifiers: %32
and: %32
the: %32
function: %13
declarator: %32
does: %32
not: %32
head: %32
a: %32
function: %32
definition
,: %32
the: %32
identifiers: %32
go: %32
out: %32
of: %32
scope: %32
immediately
.: %32
Abstract: %13
declarators
,: %32
which: %32
do: %32
not: %32
mention: %32
the: %32
identifiers
,: %32
are: %32
discussed: %32
in: %32
Par
.
A
.
8
.
8
.: %13
In: %32
an: %32
old
-
style: %32
function: %32
declaration: %32
T: %32
D: %32
where: %32
D: %32
has: %32
the: %32
form: %13
D
1
(
identifier
-
listopt
): %13
and: %32
the: %32
type: %32
of: %32
the: %32
identifier: %32
in: %32
the: %32
declaration: %32
T: %32
D
1: %32
is: %32
`
`
type
-
modifier: %32
T
,
'
': %32
the: %32
type: %32
of: %32
the: %32
identifier: %32
of: %32
D: %13
is: %32
`
`
type
-
modifier: %32
function: %32
of: %32
unspecified: %32
arguments: %32
returning: %32
T
.
'
': %32
The: %32
parameters: %32
(
if: %32
present
): %32
have: %32
the: %13
form: %13
identifier
-
list
:: %13
identifier: %13
identifier
-
list: %32
,: %32
identifier: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
In: %32
the: %32
old
-
style: %32
declarator
,: %32
the: %32
identifier: %32
list: %32
must: %32
be: %32
absent: %32
unless: %32
the: %32
declarator: %32
is: %32
used: %32
in: %32
the: %32
head: %32
of: %32
a: %13
function: %32
definition: %32
(
Par
.
A
.
1
0
.
1
)
.: %32
No: %32
information: %32
about: %32
the: %32
types: %32
of: %32
the: %32
parameters: %32
is: %32
supplied: %32
by: %32
the: %13
declaration
.: %13
For: %32
example
,: %32
the: %32
declaration: %13
int: %32
f
(
)
,: %32
*
fpi
(
)
,: %32
(
*
pfi
)
(
)
;: %13
declares: %32
a: %32
function: %32
f: %32
returning: %32
an: %32
integer
,: %32
a: %32
function: %32
fpi: %32
returning: %32
a: %32
pointer: %32
to: %32
an: %32
integer
,: %32
and: %32
a: %32
pointer: %13
pfi: %32
to: %32
a: %32
function: %32
returning: %32
an: %32
integer
.: %32
In: %32
none: %32
of: %32
these: %32
are: %32
the: %32
parameter: %32
types: %32
specified
;: %32
they: %32
are: %32
old
-: %13
style
.: %13
In: %32
the: %32
new
-
style: %32
declaration: %13
int: %32
strcpy
(
char: %32
*
dest
,: %32
const: %32
char: %32
*
source
)
,: %32
rand
(
void
)
;: %13
strcpy: %32
is: %32
a: %32
function: %32
returning: %32
int
,: %32
with: %32
two: %32
arguments
,: %32
the: %32
first: %32
a: %32
character: %32
pointer
,: %32
and: %32
the: %32
second: %32
a: %13
pointer: %32
to: %32
constant: %32
characters
.: %32
The: %32
parameter: %32
names: %32
are: %32
effectively: %32
comments
.: %32
The: %32
second: %32
function: %13
rand: %32
takes: %32
no: %32
arguments: %32
and: %32
returns: %32
int
.: %13
Function: %32
declarators: %32
with: %32
parameter: %32
prototypes: %32
are
,: %32
by: %32
far
,: %32
the: %32
most: %32
important: %32
language: %32
change: %32
introduced: %32
by: %32
the: %13
ANSI: %32
standard
.: %32
They: %32
offer: %32
an: %32
advantage: %32
over: %32
the: %32
`
`
old
-
style
'
': %32
declarators: %32
of: %32
the: %32
first: %32
edition: %32
by: %32
providing: %32
error
-: %13
detection: %32
and: %32
coercion: %32
of: %32
arguments: %32
across: %32
function: %32
calls
,: %32
but: %32
at: %32
a: %32
cost
:: %32
turmoil: %32
and: %32
confusion: %32
during: %32
their: %13
introduction
,: %32
and: %32
the: %32
necessity: %32
of: %32
accomodating: %32
both: %32
forms
.: %32
Some: %32
syntactic: %32
ugliness: %32
was: %32
required: %32
for: %32
the: %32
sake: %32
of: %13
compatibility
,: %32
namely: %32
void: %32
as: %32
an: %32
explicit: %32
marker: %32
of: %32
new
-
style: %32
functions: %32
without: %32
parameters
.: %13
The: %32
ellipsis: %32
notation: %32
`
`
,: %32
.
.
.
'
': %32
for: %32
variadic: %32
functions: %32
is: %32
also: %32
new
,: %32
and
,: %32
together: %32
with: %32
the: %32
macros: %32
in: %32
the: %32
standard: %13
header: %32
<
stdarg
.
h
>
,: %32
formalizes: %32
a: %32
mechanism: %32
that: %32
was: %32
officially: %32
forbidden: %32
but: %32
unofficially: %32
condoned: %32
in: %32
the: %32
first: %13
edition
.: %13
These: %32
notations: %32
were: %32
adapted: %32
from: %32
the: %32
C
+
+: %32
language
.: %13
A
.
8
.
7: %32
Initialization: %13
When: %32
an: %32
object: %32
is: %32
declared
,: %32
its: %32
init
-
declarator: %32
may: %32
specify: %32
an: %32
initial: %32
value: %32
for: %32
the: %32
identifier: %32
being: %13
declared
.: %32
The: %32
initializer: %32
is: %32
preceded: %32
by: %32
=
,: %32
and: %32
is: %32
either: %32
an: %32
expression
,: %32
or: %32
a: %32
list: %32
of: %32
initializers: %32
nested: %32
in: %13
braces
.: %32
A: %32
list: %32
may: %32
end: %32
with: %32
a: %32
comma
,: %32
a: %32
nicety: %32
for: %32
neat: %32
formatting
.: %13
initializer
:: %13
assignment
-
expression: %13
{: %32
initializer
-
list: %32
}: %13
{: %32
initializer
-
list: %32
,: %32
}: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
initializer
-
list
:: %13
initializer: %13
initializer
-
list: %32
,: %32
initializer: %13
All: %32
the: %32
expressions: %32
in: %32
the: %32
initializer: %32
for: %32
a: %32
static: %32
object: %32
or: %32
array: %32
must: %32
be: %32
constant: %32
expressions: %32
as: %32
described: %13
in: %32
Par
.
A
.
7
.
1
9
.: %32
The: %32
expressions: %32
in: %32
the: %32
initializer: %32
for: %32
an: %32
auto: %32
or: %32
register: %32
object: %32
or: %32
array: %32
must: %32
likewise: %13
be: %32
constant: %32
expressions: %32
if: %32
the: %32
initializer: %32
is: %32
a: %32
brace
-
enclosed: %32
list
.: %32
However
,: %32
if: %32
the: %32
initializer: %32
for: %32
an: %13
automatic: %32
object: %32
is: %32
a: %32
single: %32
expression
,: %32
it: %32
need: %32
not: %32
be: %32
a: %32
constant: %32
expression
,: %32
but: %32
must: %32
merely: %32
have: %13
appropriate: %32
type: %32
for: %32
assignment: %32
to: %32
the: %32
object
.: %13
The: %32
first: %32
edition: %32
did: %32
not: %32
countenance: %32
initialization: %32
of: %32
automatic: %32
structures
,: %32
unions
,: %32
or: %32
arrays
.: %32
The: %32
ANSI: %32
standard: %13
allows: %32
it
,: %32
but: %32
only: %32
by: %32
constant: %32
constructions: %32
unless: %32
the: %32
initializer: %32
can: %32
be: %32
expressed: %32
by: %32
a: %32
simple: %32
expression
.: %13
A: %32
static: %32
object: %32
not: %32
explicitly: %32
initialized: %32
is: %32
initialized: %32
as: %32
if: %32
it: %32
(
or: %32
its: %32
members
): %32
were: %32
assigned: %32
the: %32
constant: %13
0
.: %32
The: %32
initial: %32
value: %32
of: %32
an: %32
automatic: %32
object: %32
not: %32
explicitly: %32
intialized: %32
is: %32
undefined
.: %13
The: %32
initializer: %32
for: %32
a: %32
pointer: %32
or: %32
an: %32
object: %32
of: %32
arithmetic: %32
type: %32
is: %32
a: %32
single: %32
expression
,: %32
perhaps: %32
in: %32
braces
.: %32
The: %13
expression: %32
is: %32
assigned: %32
to: %32
the: %32
object
.: %13
The: %32
initializer: %32
for: %32
a: %32
structure: %32
is: %32
either: %32
an: %32
expression: %32
of: %32
the: %32
same: %32
type
,: %32
or: %32
a: %32
brace
-
enclosed: %32
list: %32
of: %13
initializers: %32
for: %32
its: %32
members: %32
in: %32
order
.: %32
Unnamed: %32
bit
-
field: %32
members: %32
are: %32
ignored
,: %32
and: %32
are: %32
not: %32
initialized
.: %32
If: %13
there: %32
are: %32
fewer: %32
initializers: %32
in: %32
the: %32
list: %32
than: %32
members: %32
of: %32
the: %32
structure
,: %32
the: %32
trailing: %32
members: %32
are: %32
initialized: %13
with: %32
0
.: %32
There: %32
may: %32
not: %32
be: %32
more: %32
initializers: %32
than: %32
members
.: %32
Unnamed: %32
bit
-
field: %32
members: %32
are: %32
ignored
,
and: %13
are: %32
not: %32
initialized
.: %13
The: %32
initializer: %32
for: %32
an: %32
array: %32
is: %32
a: %32
brace
-
enclosed: %32
list: %32
of: %32
initializers: %32
for: %32
its: %32
members
.: %32
If: %32
the: %32
array: %32
has: %13
unknown: %32
size
,: %32
the: %32
number: %32
of: %32
initializers: %32
determines: %32
the: %32
size: %32
of: %32
the: %32
array
,: %32
and: %32
its: %32
type: %32
becomes: %32
complete
.: %13
If: %32
the: %32
array: %32
has: %32
fixed: %32
size
,: %32
the: %32
number: %32
of: %32
initializers: %32
may: %32
not: %32
exceed: %32
the: %32
number: %32
of: %32
members: %32
of: %32
the: %32
array
;: %13
if: %32
there: %32
are: %32
fewer
,: %32
the: %32
trailing: %32
members: %32
are: %32
initialized: %32
with: %32
0
.: %13
As: %32
a: %32
special: %32
case
,: %32
a: %32
character: %32
array: %32
may: %32
be: %32
initialized: %32
by: %32
a: %32
string: %32
literal
;: %32
successive: %32
characters: %32
of: %32
the: %13
string: %32
initialize: %32
successive: %32
members: %32
of: %32
the: %32
array
.: %32
Similarly
,: %32
a: %32
wide: %32
character: %32
literal: %32
(
Par
.
A
.
2
.
6
): %32
may: %13
initialize: %32
an: %32
array: %32
of: %32
type: %32
wchar
_
t
.: %32
If: %32
the: %32
array: %32
has: %32
unknown: %32
size
,: %32
the: %32
number: %32
of: %32
characters: %32
in: %32
the: %13
string
,: %32
including: %32
the: %32
terminating: %32
null: %32
character
,: %32
determines: %32
its: %32
size
;: %32
if: %32
its: %32
size: %32
is: %32
fixed
,: %32
the: %32
number: %32
of: %13
characters: %32
in: %32
the: %32
string
,: %32
not: %32
counting: %32
the: %32
terminating: %32
null: %32
character
,: %32
must: %32
not: %32
exceed: %32
the: %32
size: %32
of: %32
the: %32
array
.: %13
The: %32
initializer: %32
for: %32
a: %32
union: %32
is: %32
either: %32
a: %32
single: %32
expression: %32
of: %32
the: %32
same: %32
type
,: %32
or: %32
a: %32
brace
-
enclosed: %32
initializer: %32
for: %13
the: %32
first: %32
member: %32
of: %32
the: %32
union
.: %13
The: %32
first: %32
edition: %32
did: %32
not: %32
allow: %32
initialization: %32
of: %32
unions
.: %32
The: %32
`
`
first
-
member
'
': %32
rule: %32
is: %32
clumsy
,: %32
but: %32
is: %32
hard: %32
to: %32
generalize: %13
without: %32
new: %32
syntax
.: %32
Besides: %32
allowing: %32
unions: %32
to: %32
be: %32
explicitly: %32
initialized: %32
in: %32
at: %32
least: %32
a: %32
primitive: %32
way
,: %32
this: %32
ANSI: %32
rule: %13
makes: %32
definite: %32
the: %32
semantics: %32
of: %32
static: %32
unions: %32
not: %32
explicitly: %32
initialized
.: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
An: %32
aggregate: %32
is: %32
a: %32
structure: %32
or: %32
array
.: %32
If: %32
an: %32
aggregate: %32
contains: %32
members: %32
of: %32
aggregate: %32
type
,: %32
the: %13
initialization: %32
rules: %32
apply: %32
recursively
.: %32
Braces: %32
may: %32
be: %32
elided: %32
in: %32
the: %32
initialization: %32
as: %32
follows
:: %32
if: %32
the: %13
initializer: %32
for: %32
an: %32
aggregate
'
s: %32
member: %32
that: %32
itself: %32
is: %32
an: %32
aggregate: %32
begins: %32
with: %32
a: %32
left: %32
brace
,: %32
then: %32
the: %13
succeding: %32
comma
-
separated: %32
list: %32
of: %32
initializers: %32
initializes: %32
the: %32
members: %32
of: %32
the: %32
subaggregate
;: %32
it: %32
is: %32
erroneous: %13
for: %32
there: %32
to: %32
be: %32
more: %32
initializers: %32
than: %32
members
.: %32
If
,: %32
however
,: %32
the: %32
initializer: %32
for: %32
a: %32
subaggregate: %32
does: %32
not: %13
begin: %32
with: %32
a: %32
left: %32
brace
,: %32
then: %32
only: %32
enough: %32
elements: %32
from: %32
the: %32
list: %32
are: %32
taken: %32
into: %32
account: %32
for: %32
the: %32
members: %32
of: %13
the: %32
subaggregate
;: %32
any: %32
remaining: %32
members: %32
are: %32
left: %32
to: %32
initialize: %32
the: %32
next: %32
member: %32
of: %32
the: %32
aggregate: %32
of: %32
which: %13
the: %32
subaggregate: %32
is: %32
a: %32
part
.: %13
For: %32
example
,: %13
int: %32
x
[
]: %32
=: %32
{: %32
1
,: %32
3
,: %32
5: %32
}
;: %13
declares: %32
and: %32
initializes: %32
x: %32
as: %32
a: %32
1
-
dimensional: %32
array: %32
with: %32
three: %32
members
,: %32
since: %32
no: %32
size: %32
was: %32
specified: %32
and: %13
there: %32
are: %32
three: %32
initializers
.: %13
float: %13
{: %13
{: %13
{: %13
}
;: %13
y
[
4
]
[
3
]: %13
1
,: %32
3
,: %32
5: %13
2
,: %32
4
,: %32
6: %13
3
,: %32
5
,: %32
7: %13
=: %32
{: %13
}
,: %13
}
,: %13
}
,: %13
is: %32
a: %32
completely
-
bracketed: %32
initialization
:: %32
1
,: %32
3: %32
and: %32
5: %32
initialize: %32
the: %32
first: %32
row: %32
of: %32
the: %32
array: %32
y
[
0
]
,: %32
namely: %13
y
[
0
]
[
0
]
,: %32
y
[
0
]
[
1
]
,: %32
and: %32
y
[
0
]
[
2
]
.: %32
Likewise: %32
the: %32
next: %32
two: %32
lines: %32
initialize: %32
y
[
1
]: %32
and: %32
y
[
2
]
.: %32
The: %13
initializer: %32
ends: %32
early
,: %32
and: %32
therefore: %32
the: %32
elements: %32
of: %32
y
[
3
]: %32
are: %32
initialized: %32
with: %32
0
.: %32
Precisely: %32
the: %32
same: %32
effect: %13
could: %32
have: %32
been: %32
achieved: %32
by: %13
float: %32
y
[
4
]
[
3
]: %32
=: %32
{: %13
1
,: %32
3
,: %32
5
,: %32
2
,: %32
4
,: %32
6
,: %32
3
,: %32
5
,: %32
7: %13
}
;: %13
The: %32
initializer: %32
for: %32
y: %32
begins: %32
with: %32
a: %32
left: %32
brace
,: %32
but: %32
that: %32
for: %32
y
[
0
]: %32
does: %32
not
;: %32
therefore: %32
three: %32
elements: %32
from: %13
the: %32
list: %32
are: %32
used
.: %32
Likewise: %32
the: %32
next: %32
three: %32
are: %32
taken: %32
successively: %32
for: %32
y
[
1
]: %32
and: %32
for: %32
y
[
2
]
.: %32
Also
,: %13
float: %32
y
[
4
]
[
3
]: %32
=: %32
{: %13
{: %32
1: %32
}
,: %32
{: %32
2: %32
}
,: %32
{: %32
3: %32
}
,: %32
{: %32
4: %32
}: %13
}
;: %13
initializes: %32
the: %32
first: %32
column: %32
of: %32
y: %32
(
regarded: %32
as: %32
a: %32
two
-
dimensional: %32
array
): %32
and: %32
leaves: %32
the: %32
rest: %32
0
.: %13
Finally
,: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
char: %32
msg
[
]: %32
=: %32
"
Syntax: %32
error: %32
on: %32
line: %32
%:
s
\
n
"
;: %13
shows: %32
a: %32
character: %32
array: %32
whose: %32
members: %32
are: %32
initialized: %32
with: %32
a: %32
string
;: %32
its: %32
size: %32
includes: %32
the: %32
terminating: %32
null: %13
character
.: %13
A
.
8
.
8: %32
Type: %32
names: %13
In: %32
several: %32
contexts: %32
(
to: %32
specify: %32
type: %32
conversions: %32
explicitly: %32
with: %32
a: %32
cast
,: %32
to: %32
declare: %32
parameter: %32
types: %32
in: %13
function: %32
declarators
,: %32
and: %32
as: %32
argument: %32
of: %32
sizeof
): %32
it: %32
is: %32
necessary: %32
to: %32
supply: %32
the: %32
name: %32
of: %32
a: %32
data: %32
type
.: %32
This: %13
is: %32
accomplished: %32
using: %32
a: %32
type: %32
name
,: %32
which: %32
is: %32
syntactically: %32
a: %32
declaration: %32
for: %32
an: %32
object: %32
of: %32
that: %32
type: %32
omitting: %13
the: %32
name: %32
of: %32
the: %32
object
.: %13
type
-
name
:: %13
specifier
-
qualifier
-
list: %32
abstract
-
declaratoropt: %13
abstract
-
declarator
:: %13
pointer: %13
pointeropt: %32
direct
-
abstract
-
declarator: %13
direct
-
abstract
-
declarator
:: %13
(: %32
abstract
-
declarator: %32
): %13
direct
-
abstract
-
declaratoropt: %32
[
constant
-
expressionopt
]: %13
direct
-
abstract
-
declaratoropt: %32
(
parameter
-
type
-
listopt
): %13
It: %32
is: %32
possible: %32
to: %32
identify: %32
uniquely: %32
the: %32
location: %32
in: %32
the: %32
abstract
-
declarator: %32
where: %32
the: %32
identifier: %32
would: %32
appear: %13
if: %32
the: %32
construction: %32
were: %32
a: %32
declarator: %32
in: %32
a: %32
declaration
.: %32
The: %32
named: %32
type: %32
is: %32
then: %32
the: %32
same: %32
as: %32
the: %32
type: %32
of: %32
the: %13
hypothetical: %32
identifier
.: %32
For: %32
example
,: %13
int: %13
int: %13
int: %13
int: %13
int: %13
int: %13
*: %13
*
[
3
]: %13
(
*
)
[
]: %13
*
(
): %13
(
*
[
]
)
(
void
): %13
name: %32
respectively: %32
the: %32
types: %32
`
`
integer
,
'
': %32
`
`
pointer: %32
to: %32
integer
,
'
': %32
`
`
array: %32
of: %32
3: %32
pointers: %32
to: %32
integers
,
'
': %32
`
`
pointer: %32
to: %13
an: %32
unspecified: %32
number: %32
of: %32
integers
,
'
': %32
`
`
function: %32
of: %32
unspecified: %32
parameters: %32
returning: %32
pointer: %32
to: %32
integer
,
'
': %13
and: %32
`
`
array
,: %32
of: %32
unspecified: %32
size
,: %32
of: %32
pointers: %32
to: %32
functions: %32
with: %32
no: %32
parameters: %32
each: %32
returning: %32
an: %32
integer
.
'
': %13
A
.
8
.
9: %32
Typedef: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
Declarations: %32
whose: %32
storage: %32
class: %32
specifier: %32
is: %32
typedef: %32
do: %32
not: %32
declare: %32
objects
;: %32
instead: %32
they: %32
define: %13
identifiers: %32
that: %32
name: %32
types
.: %32
These: %32
identifiers: %32
are: %32
called: %32
typedef: %32
names
.: %13
typedef
-
name
:: %13
identifier: %13
A: %32
typedef: %32
declaration: %32
attributes: %32
a: %32
type: %32
to: %32
each: %32
name: %32
among: %32
its: %32
declarators: %32
in: %32
the: %32
usual: %32
way: %32
(
see: %13
Par
.
A
.
8
.
6
)
.: %32
Thereafter
,: %32
each: %32
such: %32
typedef: %32
name: %32
is: %32
syntactically: %32
equivalent: %32
to: %32
a: %32
type: %32
specifier: %32
keyword: %32
for: %13
the: %32
associated: %32
type
.: %13
For: %32
example
,: %32
after: %13
typedef: %32
long: %32
Blockno
,: %32
*
Blockptr
;: %13
typedef: %32
struct: %32
{: %32
double: %32
r
,: %32
theta
;: %32
}: %32
Complex
;: %13
the: %32
constructions: %13
Blockno: %32
b
;: %13
extern: %32
Blockptr: %32
bp
;: %13
Complex: %32
z
,: %32
*
zp
;: %13
are: %32
legal: %32
declarations
.: %32
The: %32
type: %32
of: %32
b: %32
is: %32
long
,: %32
that: %32
of: %32
bp: %32
is: %32
`
`
pointer: %32
to: %32
long
,
'
': %32
and: %32
that: %32
of: %32
z: %32
is: %32
the: %13
specified: %32
structure
;: %32
zp: %32
is: %32
a: %32
pointer: %32
to: %32
such: %32
a: %32
structure
.: %13
typedef: %32
does: %32
not: %32
introduce: %32
new: %32
types
,: %32
only: %32
synonyms: %32
for: %32
types: %32
that: %32
could: %32
be: %32
specified: %32
in: %32
another: %32
way
.: %13
In: %32
the: %32
example
,: %32
b: %32
has: %32
the: %32
same: %32
type: %32
as: %32
any: %32
long: %32
object
.: %13
Typedef: %32
names: %32
may: %32
be: %32
redeclared: %32
in: %32
an: %32
inner: %32
scope
,: %32
but: %32
a: %32
non
-
empty: %32
set: %32
of: %32
type: %32
specifiers: %32
must: %32
be: %13
given
.: %32
For: %32
example
,: %13
extern: %32
Blockno
;: %13
does: %32
not: %32
redeclare: %32
Blockno
,: %32
but: %13
extern: %32
int: %32
Blockno
;: %13
does
.: %13
A
.
8
.
1
0: %32
Type: %32
Equivalence: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
Two: %32
type: %32
specifier: %32
lists: %32
are: %32
equivalent: %32
if: %32
they: %32
contain: %32
the: %32
same: %32
set: %32
of: %32
type: %32
specifiers
,: %32
taking: %32
into: %32
account: %13
that: %32
some: %32
specifiers: %32
can: %32
be: %32
implied: %32
by: %32
others: %32
(
for: %32
example
,: %32
long: %32
alone: %32
implies: %32
long: %32
int
)
.: %32
Structures
,: %13
unions
,: %32
and: %32
enumerations: %32
with: %32
different: %32
tags: %32
are: %32
distinct
,: %32
and: %32
a: %32
tagless: %32
union
,: %32
structure
,: %32
or: %32
enumeration: %13
specifies: %32
a: %32
unique: %32
type
.: %13
Two: %32
types: %32
are: %32
the: %32
same: %32
if: %32
their: %32
abstract: %32
declarators: %32
(
Par
.
A
.
8
.
8
)
,: %32
after: %32
expanding: %32
any: %32
typedef: %32
types
,: %13
and: %32
deleting: %32
any: %32
function: %32
parameter: %32
specifiers
,: %32
are: %32
the: %32
same: %32
up: %32
to: %32
the: %32
equivalence: %32
of: %32
type: %32
specifier: %32
lists
.: %13
Array: %32
sizes: %32
and: %32
function: %32
parameter: %32
types: %32
are: %32
significant
.: %13
A
.
9: %32
Statements: %13
Except: %32
as: %32
described
,: %32
statements: %32
are: %32
executed: %32
in: %32
sequence
.: %32
Statements: %32
are: %32
executed: %32
for: %32
their: %32
effect
,: %32
and: %32
do: %13
not: %32
have: %32
values
.: %32
They: %32
fall: %32
into: %32
several: %32
groups
.: %13
statement
:: %13
labeled
-
statement: %13
expression
-
statement: %13
compound
-
statement: %13
selection
-
statement: %13
iteration
-
statement: %13
jump
-
statement: %13
A
.
9
.
1: %32
Labeled: %32
Statements: %13
Statements: %32
may: %32
carry: %32
label: %32
prefixes
.: %13
labeled
-
statement
:: %13
identifier: %32
:: %32
statement: %13
case: %32
constant
-
expression: %32
:: %32
statement: %13
default: %32
:: %32
statement: %13
A: %32
label: %32
consisting: %32
of: %32
an: %32
identifier: %32
declares: %32
the: %32
identifier
.: %32
The: %32
only: %32
use: %32
of: %32
an: %32
identifier: %32
label: %32
is: %32
as: %32
a: %32
target: %13
of: %32
goto
.: %32
The: %32
scope: %32
of: %32
the: %32
identifier: %32
is: %32
the: %32
current: %32
function
.: %32
Because: %32
labels: %32
have: %32
their: %32
own: %32
name: %32
space
,: %13
they: %32
do: %32
not: %32
interfere: %32
with: %32
other: %32
identifiers: %32
and: %32
cannot: %32
be: %32
redeclared
.: %32
See: %32
Par
.
A
.
1
1
.
1
.: %13
Case: %32
labels: %32
and: %32
default: %32
labels: %32
are: %32
used: %32
with: %32
the: %32
switch: %32
statement: %32
(
Par
.
A
.
9
.
4
)
.: %32
The: %32
constant: %32
expression: %13
of: %32
case: %32
must: %32
have: %32
integral: %32
type
.: %13
Labels: %32
themselves: %32
do: %32
not: %32
alter: %32
the: %32
flow: %32
of: %32
control
.: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
A
.
9
.
2: %32
Expression: %32
Statement: %13
Most: %32
statements: %32
are: %32
expression: %32
statements
,: %32
which: %32
have: %32
the: %32
form: %13
expression
-
statement
:: %13
expressionopt
;: %13
Most: %32
expression: %32
statements: %32
are: %32
assignments: %32
or: %32
function: %32
calls
.: %32
All: %32
side: %32
effects: %32
from: %32
the: %32
expression: %32
are: %13
completed: %32
before: %32
the: %32
next: %32
statement: %32
is: %32
executed
.: %32
If: %32
the: %32
expression: %32
is: %32
missing
,: %32
the: %32
construction: %32
is: %32
called: %32
a: %13
null: %32
statement
;: %32
it: %32
is: %32
often: %32
used: %32
to: %32
supply: %32
an: %32
empty: %32
body: %32
to: %32
an: %32
iteration: %32
statement: %32
to: %32
place: %32
a: %32
label
.: %13
A
.
9
.
3: %32
Compound: %32
Statement: %13
So: %32
that: %32
several: %32
statements: %32
can: %32
be: %32
used: %32
where: %32
one: %32
is: %32
expected
,: %32
the: %32
compound: %32
statement: %32
(
also: %32
called: %13
`
`
block
'
'
): %32
is: %32
provided
.: %32
The: %32
body: %32
of: %32
a: %32
function: %32
definition: %32
is: %32
a: %32
compound: %32
statement
.: %13
compound
-
statement
:: %13
{: %32
declaration
-
listopt: %32
statement
-
listopt: %32
}: %13
declaration
-
list
:: %13
declaration: %13
declaration
-
list: %32
declaration: %13
statement
-
list
:: %13
statement: %13
statement
-
list: %32
statement: %13
If: %32
an: %32
identifier: %32
in: %32
the: %32
declaration
-
list: %32
was: %32
in: %32
scope: %32
outside: %32
the: %32
block
,: %32
the: %32
outer: %32
declaration: %32
is: %32
suspended: %13
within: %32
the: %32
block: %32
(
see: %32
Par
.
A
.
1
1
.
1
)
,: %32
after: %32
which: %32
it: %32
resumes: %32
its: %32
force
.: %32
An: %32
identifier: %32
may: %32
be: %32
declared: %32
only: %13
once: %32
in: %32
the: %32
same: %32
block
.: %32
These: %32
rules: %32
apply: %32
to: %32
identifiers: %32
in: %32
the: %32
same: %32
name: %32
space: %32
(
Par
.
A
.
1
1
)
;: %32
identifiers: %32
in: %13
different: %32
name: %32
spaces: %32
are: %32
treated: %32
as: %32
distinct
.: %13
Initialization: %32
of: %32
automatic: %32
objects: %32
is: %32
performed: %32
each: %32
time: %32
the: %32
block: %32
is: %32
entered: %32
at: %32
the: %32
top
,: %32
and: %32
proceeds: %32
in: %13
the: %32
order: %32
of: %32
the: %32
declarators
.: %32
If: %32
a: %32
jump: %32
into: %32
the: %32
block: %32
is: %32
executed
,: %32
these: %32
initializations: %32
are: %32
not: %32
performed
.: %13
Initialization: %32
of: %32
static: %32
objects: %32
are: %32
performed: %32
only: %32
once
,: %32
before: %32
the: %32
program: %32
begins: %32
execution
.: %13
A
.
9
.
4: %32
Selection: %32
Statements: %13
Selection: %32
statements: %32
choose: %32
one: %32
of: %32
several: %32
flows: %32
of: %32
control
.: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
selection
-
statement
:: %13
if: %32
(
expression
): %32
statement: %13
if: %32
(
expression
): %32
statement: %32
else: %32
statement: %13
switch: %32
(
expression
): %32
statement: %13
In: %32
both: %32
forms: %32
of: %32
the: %32
if: %32
statement
,: %32
the: %32
expression
,: %32
which: %32
must: %32
have: %32
arithmetic: %32
or: %32
pointer: %32
type
,: %32
is: %13
evaluated
,: %32
including: %32
all: %32
side: %32
effects
,: %32
and: %32
if: %32
it: %32
compares: %32
unequal: %32
to: %32
0
,: %32
the: %32
first: %32
substatement: %32
is: %32
executed
.: %32
In: %13
the: %32
second: %32
form
,: %32
the: %32
second: %32
substatement: %32
is: %32
executed: %32
if: %32
the: %32
expression: %32
is: %32
0
.: %32
The: %32
else: %32
ambiguity: %32
is: %13
resolved: %32
by: %32
connecting: %32
an: %32
else: %32
with: %32
the: %32
last: %32
encountered: %32
else
-
less: %32
if: %32
at: %32
the: %32
same: %32
block: %32
nesting: %32
level
.: %13
The: %32
switch: %32
statement: %32
causes: %32
control: %32
to: %32
be: %32
transferred: %32
to: %32
one: %32
of: %32
several: %32
statements: %32
depending: %32
on: %32
the: %13
value: %32
of: %32
an: %32
expression
,: %32
which: %32
must: %32
have: %32
integral: %32
type
.: %32
The: %32
substatement: %32
controlled: %32
by: %32
a: %32
switch: %32
is: %13
typically: %32
compound
.: %32
Any: %32
statement: %32
within: %32
the: %32
substatement: %32
may: %32
be: %32
labeled: %32
with: %32
one: %32
or: %32
more: %32
case: %13
labels: %32
(
Par
.
A
.
9
.
1
)
.: %32
The: %32
controlling: %32
expression: %32
undergoes: %32
integral: %32
promotion: %32
(
Par
.
A
.
6
.
1
)
,: %32
and: %32
the: %32
case: %13
constants: %32
are: %32
converted: %32
to: %32
the: %32
promoted: %32
type
.: %32
No: %32
two: %32
of: %32
these: %32
case: %32
constants: %32
associated: %32
with: %32
the: %32
same: %13
switch: %32
may: %32
have: %32
the: %32
same: %32
value: %32
after: %32
conversion
.: %32
There: %32
may: %32
also: %32
be: %32
at: %32
most: %32
one: %32
default: %32
label: %13
associated: %32
with: %32
a: %32
switch
.: %32
Switches: %32
may: %32
be: %32
nested
;: %32
a: %32
case: %32
or: %32
default: %32
label: %32
is: %32
associated: %32
with: %32
the: %13
smallest: %32
switch: %32
that: %32
contains: %32
it
.: %13
When: %32
the: %32
switch: %32
statement: %32
is: %32
executed
,: %32
its: %32
expression: %32
is: %32
evaluated
,: %32
including: %32
all: %32
side: %32
effects
,: %32
and: %13
compared: %32
with: %32
each: %32
case: %32
constant
.: %32
If: %32
one: %32
of: %32
the: %32
case: %32
constants: %32
is: %32
equal: %32
to: %32
the: %32
value: %32
of: %32
the: %32
expression
,: %13
control: %32
passes: %32
to: %32
the: %32
statement: %32
of: %32
the: %32
matched: %32
case: %32
label
.: %32
If: %32
no: %32
case: %32
constant: %32
matches: %32
the: %32
expression
,: %13
and: %32
if: %32
there: %32
is: %32
a: %32
default: %32
label
,: %32
control: %32
passes: %32
to: %32
the: %32
labeled: %32
statement
.: %32
If: %32
no: %32
case: %32
matches
,: %32
and: %32
if: %32
there: %13
is: %32
no: %32
default
,: %32
then: %32
none: %32
of: %32
the: %32
substatements: %32
of: %32
the: %32
swtich: %32
is: %32
executed
.: %13
In: %32
the: %32
first: %32
edition: %32
of: %32
this: %32
book
,: %32
the: %32
controlling: %32
expression: %32
of: %32
switch
,: %32
and: %32
the: %32
case: %32
constants
,: %32
were: %32
required: %32
to: %13
have: %32
int: %32
type
.: %13
A
.
9
.
5: %32
Iteration: %32
Statements: %13
Iteration: %32
statements: %32
specify: %32
looping
.: %13
iteration
-
statement
:: %13
while: %32
(
expression
): %32
statement: %13
do: %32
statement: %32
while: %32
(
expression
)
;: %13
for: %32
(
expressionopt
;: %32
expressionopt
;: %32
expressionopt
): %32
statement: %13
In: %32
the: %32
while: %32
and: %32
do: %32
statements
,: %32
the: %32
substatement: %32
is: %32
executed: %32
repeatedly: %32
so: %32
long: %32
as: %32
the: %32
value: %32
of: %32
the: %13
expression: %32
remains: %32
unequal: %32
to: %32
0
;: %32
the: %32
expression: %32
must: %32
have: %32
arithmetic: %32
or: %32
pointer: %32
type
.: %32
With: %32
while
,: %32
the: %13
test
,: %32
including: %32
all: %32
side: %32
effects: %32
from: %32
the: %32
expression
,: %32
occurs: %32
before: %32
each: %32
execution: %32
of: %32
the: %32
statement
;: %32
with: %13
do
,: %32
the: %32
test: %32
follows: %32
each: %32
iteration
.: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
In: %32
the: %32
for: %32
statement
,: %32
the: %32
first: %32
expression: %32
is: %32
evaluated: %32
once
,: %32
and: %32
thus: %32
specifies: %32
initialization: %32
for: %32
the: %32
loop
.: %13
There: %32
is: %32
no: %32
restriction: %32
on: %32
its: %32
type
.: %32
The: %32
second: %32
expression: %32
must: %32
have: %32
arithmetic: %32
or: %32
pointer: %32
type
;: %32
it: %32
is: %13
evaluated: %32
before: %32
each: %32
iteration
,: %32
and: %32
if: %32
it: %32
becomes: %32
equal: %32
to: %32
0
,: %32
the: %32
for: %32
is: %32
terminated
.: %32
The: %32
third: %32
expression: %13
is: %32
evaluated: %32
after: %32
each: %32
iteration
,: %32
and: %32
thus: %32
specifies: %32
a: %32
re
-
initialization: %32
for: %32
the: %32
loop
.: %32
There: %32
is: %32
no: %32
restriction: %13
on: %32
its: %32
type
.: %32
Side
-
effects: %32
from: %32
each: %32
expression: %32
are: %32
completed: %32
immediately: %32
after: %32
its: %32
evaluation
.: %32
If: %32
the: %13
substatement: %32
does: %32
not: %32
contain: %32
continue
,: %32
a: %32
statement: %13
for: %32
(
expression
1
;: %32
expression
2
;: %32
expression
3
): %32
statement: %13
is: %32
equivalent: %32
to: %13
expression
1
;: %13
while: %32
(
expression
2
): %32
{: %13
statement: %13
expression
3
;: %13
}: %13
Any: %32
of: %32
the: %32
three: %32
expressions: %32
may: %32
be: %32
dropped
.: %32
A: %32
missing: %32
second: %32
expression: %32
makes: %32
the: %32
implied: %32
test: %13
equivalent: %32
to: %32
testing: %32
a: %32
non
-
zero: %32
element
.: %13
A
.
9
.
6: %32
Jump: %32
statements: %13
Jump: %32
statements: %32
transfer: %32
control: %32
unconditionally
.: %13
jump
-
statement
:: %13
goto: %32
identifier
;: %13
continue
;: %13
break
;: %13
return: %32
expressionopt
;: %13
In: %32
the: %32
goto: %32
statement
,: %32
the: %32
identifier: %32
must: %32
be: %32
a: %32
label: %32
(
Par
.
A
.
9
.
1
): %32
located: %32
in: %32
the: %32
current: %32
function
.: %32
Control: %13
transfers: %32
to: %32
the: %32
labeled: %32
statement
.: %13
A: %32
continue: %32
statement: %32
may: %32
appear: %32
only: %32
within: %32
an: %32
iteration: %32
statement
.: %32
It: %32
causes: %32
control: %32
to: %32
pass: %32
to: %32
the: %13
loop
-
continuation: %32
portion: %32
of: %32
the: %32
smallest: %32
enclosing: %32
such: %32
statement
.: %32
More: %32
precisely
,: %32
within: %32
each: %32
of: %32
the: %13
statements: %13
while: %32
(
.
.
.
): %32
{: %13
.
.
.: %13
contin
:: %32
;: %13
}: %13
do: %32
{: %13
.
.
.: %13
contin
:: %32
;: %13
}: %32
while: %32
(
.
.
.
)
;: %13
for: %32
(
.
.
.
): %32
{: %13
.
.
.: %13
contin
:: %32
;: %13
}: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
a: %32
continue: %32
not: %32
contained: %32
in: %32
a: %32
smaller: %32
iteration: %32
statement: %32
is: %32
the: %32
same: %32
as: %32
goto: %32
contin
.: %13
A: %32
break: %32
statement: %32
may: %32
appear: %32
only: %32
in: %32
an: %32
iteration: %32
statement: %32
or: %32
a: %32
switch: %32
statement
,: %32
and: %32
terminates: %13
execution: %32
of: %32
the: %32
smallest: %32
enclosing: %32
such: %32
statement
;: %32
control: %32
passes: %32
to: %32
the: %32
statement: %32
following: %32
the: %13
terminated: %32
statement
.: %13
A: %32
function: %32
returns: %32
to: %32
its: %32
caller: %32
by: %32
the: %32
return: %32
statement
.: %32
When: %32
return: %32
is: %32
followed: %32
by: %32
an: %32
expression
,: %13
the: %32
value: %32
is: %32
returned: %32
to: %32
the: %32
caller: %32
of: %32
the: %32
function
.: %32
The: %32
expression: %32
is: %32
converted
,: %32
as: %32
by: %32
assignment
,: %32
to: %32
the: %13
type: %32
returned: %32
by: %32
the: %32
function: %32
in: %32
which: %32
it: %32
appears
.: %13
Flowing: %32
off: %32
the: %32
end: %32
of: %32
a: %32
function: %32
is: %32
equivalent: %32
to: %32
a: %32
return: %32
with: %32
no: %32
expression
.: %32
In: %32
either: %32
case
,: %32
the: %32
returned: %13
value: %32
is: %32
undefined
.: %13
A
.
1
0: %32
External: %32
Declarations: %13
The: %32
unit: %32
of: %32
input: %32
provided: %32
to: %32
the: %32
C: %32
compiler: %32
is: %32
called: %32
a: %32
translation: %32
unit
;: %32
it: %32
consists: %32
of: %32
a: %32
sequence: %32
of: %13
external: %32
declarations
,: %32
which: %32
are: %32
either: %32
declarations: %32
or: %32
function: %32
definitions
.: %13
translation
-
unit
:: %13
external
-
declaration: %13
translation
-
unit: %32
external
-
declaration: %13
external
-
declaration
:: %13
function
-
definition: %13
declaration: %13
The: %32
scope: %32
of: %32
external: %32
declarations: %32
persists: %32
to: %32
the: %32
end: %32
of: %32
the: %32
translation: %32
unit: %32
in: %32
which: %32
they: %32
are: %32
declared
,: %13
just: %32
as: %32
the: %32
effect: %32
of: %32
declarations: %32
within: %32
the: %32
blocks: %32
persists: %32
to: %32
the: %32
end: %32
of: %32
the: %32
block
.: %32
The: %32
syntax: %32
of: %32
external: %13
declarations: %32
is: %32
the: %32
same: %32
as: %32
that: %32
of: %32
all: %32
declarations
,: %32
except: %32
that: %32
only: %32
at: %32
this: %32
level: %32
may: %32
the: %32
code: %32
for: %13
functions: %32
be: %32
given
.: %13
A
.
1
0
.
1: %32
Function: %32
Definitions: %13
Function: %32
definitions: %32
have: %32
the: %32
form: %13
function
-
definition
:: %13
declaration
-
specifiersopt: %32
declarator: %32
declaration
-
listopt: %32
compound
-
statement: %13
The: %32
only: %32
storage
-
class: %32
specifiers: %32
allowed: %32
among: %32
the: %32
declaration: %32
specifiers: %32
are: %32
extern: %32
or: %32
static
;: %32
see: %13
Par
.
A
.
1
1
.
2: %32
for: %32
the: %32
distinction: %32
between: %32
them
.: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
A: %32
function: %32
may: %32
return: %32
an: %32
arithmetic: %32
type
,: %32
a: %32
structure
,: %32
a: %32
union
,: %32
a: %32
pointer
,: %32
or: %32
void
,: %32
but: %32
not: %32
a: %32
function: %32
or: %13
an: %32
array
.: %32
The: %32
declarator: %32
in: %32
a: %32
function: %32
declaration: %32
must: %32
specify: %32
explicitly: %32
that: %32
the: %32
declared: %32
identifier: %32
has: %13
function: %32
type
;: %32
that: %32
is
,: %32
it: %32
must: %32
contain: %32
one: %32
of: %32
the: %32
forms: %32
(
see: %32
Par
.
A
.
8
.
6
.
3
)
.: %13
direct
-
declarator: %32
(: %32
parameter
-
type
-
list: %32
): %13
direct
-
declarator: %32
(: %32
identifier
-
listopt: %32
): %13
where: %32
the: %32
direct
-
declarator: %32
is: %32
an: %32
identifier: %32
or: %32
a: %32
parenthesized: %32
identifier
.: %32
In: %32
particular
,: %32
it: %32
must: %32
not: %32
achieve: %13
function: %32
type: %32
by: %32
means: %32
of: %32
a: %32
typedef
.: %13
In: %32
the: %32
first: %32
form
,: %32
the: %32
definition: %32
is: %32
a: %32
new
-
style: %32
function
,: %32
and: %32
its: %32
parameters
,: %32
together: %32
with: %32
their: %32
types
,: %32
are: %13
declared: %32
in: %32
its: %32
parameter: %32
type: %32
list
;: %32
the: %32
declaration
-
list: %32
following: %32
the: %32
function
'
s: %32
declarator: %32
must: %32
be: %32
absent
.: %13
Unless: %32
the: %32
parameter: %32
type: %32
list: %32
consists: %32
solely: %32
of: %32
void
,: %32
showing: %32
that: %32
the: %32
function: %32
takes: %32
no: %32
parameters
,: %13
each: %32
declarator: %32
in: %32
the: %32
parameter: %32
type: %32
list: %32
must: %32
contain: %32
an: %32
identifier
.: %32
If: %32
the: %32
parameter: %32
type: %32
list: %32
ends: %32
with: %13
`
`
,: %32
.
.
.
'
': %32
then: %32
the: %32
function: %32
may: %32
be: %32
called: %32
with: %32
more: %32
arguments: %32
than: %32
parameters
;: %32
the: %32
va
_
arg: %32
macro: %13
mechanism: %32
defined: %32
in: %32
the: %32
standard: %32
header: %32
<
stdarg
.
h
>: %32
and: %32
described: %32
in: %32
Appendix: %32
B: %32
must: %32
be: %32
used: %32
to: %13
refer: %32
to: %32
the: %32
extra: %32
arguments
.: %32
Variadic: %32
functions: %32
must: %32
have: %32
at: %32
least: %32
one: %32
named: %32
parameter
.: %13
In: %32
the: %32
second: %32
form
,: %32
the: %32
definition: %32
is: %32
old
-
style
:: %32
the: %32
identifier: %32
list: %32
names: %32
the: %32
parameters
,: %32
while: %32
the: %13
declaration: %32
list: %32
attributes: %32
types: %32
to: %32
them
.: %32
If: %32
no: %32
declaration: %32
is: %32
given: %32
for: %32
a: %32
parameter
,: %32
its: %32
type: %32
is: %32
taken: %32
to: %32
be: %13
int
.: %32
The: %32
declaration: %32
list: %32
must: %32
declare: %32
only: %32
parameters: %32
named: %32
in: %32
the: %32
list
,: %32
initialization: %32
is: %32
not: %32
permitted
,: %13
and: %32
the: %32
only: %32
storage
-
class: %32
specifier: %32
possible: %32
is: %32
register
.: %13
In: %32
both: %32
styles: %32
of: %32
function: %32
definition
,: %32
the: %32
parameters: %32
are: %32
understood: %32
to: %32
be: %32
declared: %32
just: %32
after: %32
the: %32
beginning: %13
of: %32
the: %32
compound: %32
statement: %32
constituting: %32
the: %32
function
'
s: %32
body
,: %32
and: %32
thus: %32
the: %32
same: %32
identifiers: %32
must: %32
not: %32
be: %13
redeclared: %32
there: %32
(
although: %32
they: %32
may
,: %32
like: %32
other: %32
identifiers
,: %32
be: %32
redeclared: %32
in: %32
inner: %32
blocks
)
.: %32
If: %32
a: %32
parameter: %13
is: %32
declared: %32
to: %32
have: %32
type: %32
`
`
array: %32
of: %32
type
,
'
': %32
the: %32
declaration: %32
is: %32
adjusted: %32
to: %32
read: %32
`
`
pointer: %32
to: %32
type
;
'
': %32
similarly
,: %32
if: %13
a: %32
parameter: %32
is: %32
declared: %32
to: %32
have: %32
type: %32
`
`
function: %32
returning: %32
type
,
'
': %32
the: %32
declaration: %32
is: %32
adjusted: %32
to: %32
read: %13
`
`
pointer: %32
to: %32
function: %32
returning: %32
type
.
'
': %32
During: %32
the: %32
call: %32
to: %32
a: %32
function
,: %32
the: %32
arguments: %32
are: %32
converted: %32
as: %13
necessary: %32
and: %32
assigned: %32
to: %32
the: %32
parameters
;: %32
see: %32
Par
.
A
.
7
.
3
.
2
.: %13
New
-
style: %32
function: %32
definitions: %32
are: %32
new: %32
with: %32
the: %32
ANSI: %32
standard
.: %32
There: %32
is: %32
also: %32
a: %32
small: %32
change: %32
in: %32
the: %32
details: %32
of: %13
promotion
;: %32
the: %32
first: %32
edition: %32
specified: %32
that: %32
the: %32
declarations: %32
of: %32
float: %32
parameters: %32
were: %32
adjusted: %32
to: %32
read: %32
double
.: %13
The: %32
difference: %32
becomes: %32
noticable: %32
when: %32
a: %32
pointer: %32
to: %32
a: %32
parameter: %32
is: %32
generated: %32
within: %32
a: %32
function
.: %13
A: %32
complete: %32
example: %32
of: %32
a: %32
new
-
style: %32
function: %32
definition: %32
is: %13
int: %32
max
(
int: %32
a
,: %32
int: %32
b
,: %32
int: %32
c
): %13
{: %13
int: %32
m
;: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
m: %32
=: %32
(
a: %32
>: %32
b
): %32
?: %32
a: %32
:: %32
b
;: %13
return: %32
(
m: %32
>: %32
c
): %32
?: %32
m: %32
:: %32
c
;: %13
}: %13
Here: %32
int: %32
is: %32
the: %32
declaration: %32
specifier
;: %32
max
(
int: %32
a
,: %32
int: %32
b
,: %32
int: %32
c
): %32
is: %32
the: %32
function
'
s: %32
declarator
,: %13
and: %32
{: %32
.
.
.: %32
}: %32
is: %32
the: %32
block: %32
giving: %32
the: %32
code: %32
for: %32
the: %32
function
.: %32
The: %32
corresponding: %32
old
-
style: %32
definition: %13
would: %32
be: %13
int: %32
max
(
a
,: %32
b
,: %32
c
): %13
int: %32
a
,: %32
b
,: %32
c
;: %13
{: %13
/
*: %32
.
.
.: %32
*
/: %13
}: %13
where: %32
now: %32
int: %32
max
(
a
,: %32
b
,: %32
c
): %32
is: %32
the: %32
declarator
,: %32
and: %32
int: %32
a
,: %32
b
,: %32
c
;: %32
is: %32
the: %32
declaration: %32
list: %32
for: %32
the: %13
parameters
.: %13
A
.
1
0
.
2: %32
External: %32
Declarations: %13
External: %32
declarations: %32
specify: %32
the: %32
characteristics: %32
of: %32
objects
,: %32
functions: %32
and: %32
other: %32
identifiers
.: %32
The: %32
term: %13
`
`
external
'
': %32
refers: %32
to: %32
their: %32
location: %32
outside: %32
functions
,: %32
and: %32
is: %32
not: %32
directly: %32
connected: %32
with: %32
the: %32
extern: %13
keyword
;: %32
the: %32
storage: %32
class: %32
for: %32
an: %32
externally
-
declared: %32
object: %32
may: %32
be: %32
left: %32
empty
,: %32
or: %32
it: %32
may: %32
be: %32
specified: %32
as: %13
extern: %32
or: %32
static
.: %13
Several: %32
external: %32
declarations: %32
for: %32
the: %32
same: %32
identifier: %32
may: %32
exist: %32
within: %32
the: %32
same: %32
translation: %32
unit: %32
if: %32
they: %13
agree: %32
in: %32
type: %32
and: %32
linkage
,: %32
and: %32
if: %32
there: %32
is: %32
at: %32
most: %32
one: %32
definition: %32
for: %32
the: %32
identifier
.: %13
Two: %32
declarations: %32
for: %32
an: %32
object: %32
or: %32
function: %32
are: %32
deemed: %32
to: %32
agree: %32
in: %32
type: %32
under: %32
the: %32
rule: %32
discussed: %32
in: %13
Par
.
A
.
8
.
1
0
.: %32
In: %32
addition
,: %32
if: %32
the: %32
declarations: %32
differ: %32
because: %32
one: %32
type: %32
is: %32
an: %32
incomplete: %32
structure
,: %32
union
,: %32
or: %13
enumeration: %32
type: %32
(
Par
.
A
.
8
.
3
): %32
and: %32
the: %32
other: %32
is: %32
the: %32
corresponding: %32
completed: %32
type: %32
with: %32
the: %32
same: %32
tag
,: %32
the: %13
types: %32
are: %32
taken: %32
to: %32
agree
.: %32
Moreover
,: %32
if: %32
one: %32
type: %32
is: %32
an: %32
incomplete: %32
array: %32
type: %32
(
Par
.
A
.
8
.
6
.
2
): %32
and: %32
the: %32
other: %32
is: %13
a: %32
completed: %32
array: %32
type
,: %32
the: %32
types
,: %32
if: %32
otherwise: %32
identical
,: %32
are: %32
also: %32
taken: %32
to: %32
agree
.: %32
Finally
,: %32
if: %32
one: %32
type: %13
specifies: %32
an: %32
old
-
style: %32
function
,: %32
and: %32
the: %32
other: %32
an: %32
otherwise: %32
identical: %32
new
-
style: %32
function
,: %32
with: %32
parameter: %13
declarations
,: %32
the: %32
types: %32
are: %32
taken: %32
to: %32
agree
.: %13
If: %32
the: %32
first: %32
external: %32
declarator: %32
for: %32
a: %32
function: %32
or: %32
object: %32
includes: %32
the: %32
static: %32
specifier
,: %32
the: %32
identifier: %32
has: %13
internal: %32
linkage
;: %32
otherwise: %32
it: %32
has: %32
external: %32
linkage
.: %32
Linkage: %32
is: %32
discussed: %32
in: %32
Par
.
1
1
.
2
.: %13
An: %32
external: %32
declaration: %32
for: %32
an: %32
object: %32
is: %32
a: %32
definition: %32
if: %32
it: %32
has: %32
an: %32
initializer
.: %32
An: %32
external: %32
object: %32
declaration: %13
that: %32
does: %32
not: %32
have: %32
an: %32
initializer
,: %32
and: %32
does: %32
not: %32
contain: %32
the: %32
extern: %32
specifier
,: %32
is: %32
a: %32
tentative: %32
definition
.: %32
If: %32
a: %13
definition: %32
for: %32
an: %32
object: %32
appears: %32
in: %32
a: %32
translation: %32
unit
,: %32
any: %32
tentative: %32
definitions: %32
are: %32
treated: %32
merely: %32
as: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
redundant: %32
declarations
.: %32
If: %32
no: %32
definition: %32
for: %32
the: %32
object: %32
appears: %32
in: %32
the: %32
translation: %32
unit
,: %32
all: %32
its: %32
tentative: %13
definitions: %32
become: %32
a: %32
single: %32
definition: %32
with: %32
initializer: %32
0
.: %13
Each: %32
object: %32
must: %32
have: %32
exactly: %32
one: %32
definition
.: %32
For: %32
objects: %32
with: %32
internal: %32
linkage
,: %32
this: %32
rule: %32
applies: %13
separately: %32
to: %32
each: %32
translation: %32
unit
,: %32
because: %32
internally
-
linked: %32
objects: %32
are: %32
unique: %32
to: %32
a: %32
translation: %32
unit
.: %32
For: %13
objects: %32
with: %32
external: %32
linkage
,: %32
it: %32
applies: %32
to: %32
the: %32
entire: %32
program
.: %13
Although: %32
the: %32
one
-
definition: %32
rule: %32
is: %32
formulated: %32
somewhat: %32
differently: %32
in: %32
the: %32
first: %32
edition: %32
of: %32
this: %32
book
,: %32
it: %32
is: %32
in: %32
effect: %13
identical: %32
to: %32
the: %32
one: %32
stated: %32
here
.: %32
Some: %32
implementations: %32
relax: %32
it: %32
by: %32
generalizing: %32
the: %32
notion: %32
of: %32
tentative: %32
definition
.: %32
In: %13
the: %32
alternate: %32
formulation
,: %32
which: %32
is: %32
usual: %32
in: %32
UNIX: %32
systems: %32
and: %32
recognized: %32
as: %32
a: %32
common: %32
extension: %32
by: %32
the: %13
Standard
,: %32
all: %32
the: %32
tentative: %32
definitions: %32
for: %32
an: %32
externally: %32
linked: %32
object
,: %32
throughout: %32
all: %32
the: %32
translation: %32
units: %32
of: %32
the: %13
program
,: %32
are: %32
considered: %32
together: %32
instead: %32
of: %32
in: %32
each: %32
translation: %32
unit: %32
separately
.: %32
If: %32
a: %32
definition: %32
occurs: %32
somewhere: %32
in: %13
the: %32
program
,: %32
then: %32
the: %32
tentative: %32
definitions: %32
become: %32
merely: %32
declarations
,: %32
but: %32
if: %32
no: %32
definition: %32
appears
,: %32
then: %32
all: %32
its: %13
tentative: %32
definitions: %32
become: %32
a: %32
definition: %32
with: %32
initializer: %32
0
.: %13
A
.
1
1: %32
Scope: %32
and: %32
Linkage: %13
A: %32
program: %32
need: %32
not: %32
all: %32
be: %32
compiled: %32
at: %32
one: %32
time
:: %32
the: %32
source: %32
text: %32
may: %32
be: %32
kept: %32
in: %32
several: %32
files: %32
containing: %13
translation: %32
units
,: %32
and: %32
precompiled: %32
routines: %32
may: %32
be: %32
loaded: %32
from: %32
libraries
.: %32
Communication: %32
among: %32
the: %13
functions: %32
of: %32
a: %32
program: %32
may: %32
be: %32
carried: %32
out: %32
both: %32
through: %32
calls: %32
and: %32
through: %32
manipulation: %32
of: %32
external: %32
data
.: %13
Therefore
,: %32
there: %32
are: %32
two: %32
kinds: %32
of: %32
scope: %32
to: %32
consider
:: %32
first
,: %32
the: %32
lexical: %32
scope: %32
of: %32
an: %32
identifier: %32
which: %32
is: %32
the: %13
region: %32
of: %32
the: %32
program: %32
text: %32
within: %32
which: %32
the: %32
identifier
'
s: %32
characteristics: %32
are: %32
understood
;: %32
and: %32
second
,: %32
the: %13
scope: %32
associated: %32
with: %32
objects: %32
and: %32
functions: %32
with: %32
external: %32
linkage
,: %32
which: %32
determines: %32
the: %32
connections: %13
between: %32
identifiers: %32
in: %32
separately: %32
compiled: %32
translation: %32
units
.: %13
A
.
1
1
.
1: %32
Lexical: %32
Scope: %13
Identifiers: %32
fall: %32
into: %32
several: %32
name: %32
spaces: %32
that: %32
do: %32
not: %32
interfere: %32
with: %32
one: %32
another
;: %32
the: %32
same: %32
identifier: %32
may: %32
be: %13
used: %32
for: %32
different: %32
purposes
,: %32
even: %32
in: %32
the: %32
same: %32
scope
,: %32
if: %32
the: %32
uses: %32
are: %32
in: %32
different: %32
name: %32
spaces
.: %32
These: %13
classes: %32
are
:: %32
objects
,: %32
functions
,: %32
typedef: %32
names
,: %32
and: %32
enum: %32
constants
;: %32
labels
;: %32
tags: %32
of: %32
structures: %32
or: %32
unions
,: %13
and: %32
enumerations
;: %32
and: %32
members: %32
of: %32
each: %32
structure: %32
or: %32
union: %32
individually
.: %13
These: %32
rules: %32
differ: %32
in: %32
several: %32
ways: %32
from: %32
those: %32
described: %32
in: %32
the: %32
first: %32
edition: %32
of: %32
this: %32
manual
.: %32
Labels: %32
did: %32
not: %13
previously: %32
have: %32
their: %32
own: %32
name: %32
space
;: %32
tags: %32
of: %32
structures: %32
and: %32
unions: %32
each: %32
had: %32
a: %32
separate: %32
space
,: %32
and: %32
in: %32
some: %13
implementations: %32
enumerations: %32
tags: %32
did: %32
as: %32
well
;: %32
putting: %32
different: %32
kinds: %32
of: %32
tags: %32
into: %32
the: %32
same: %32
space: %32
is: %32
a: %32
new: %13
restriction
.: %32
The: %32
most: %32
important: %32
departure: %32
from: %32
the: %32
first: %32
edition: %32
is: %32
that: %32
each: %32
structure: %32
or: %32
union: %32
creates: %32
a: %32
separate: %13
name: %32
space: %32
for: %32
its: %32
members
,: %32
so: %32
that: %32
the: %32
same: %32
name: %32
may: %32
appear: %32
in: %32
several: %32
different: %32
structures
.: %32
This: %32
rule: %32
has: %32
been: %13
common: %32
practice: %32
for: %32
several: %32
years
.: %13
The: %32
lexical: %32
scope: %32
of: %32
an: %32
object: %32
or: %32
function: %32
identifier: %32
in: %32
an: %32
external: %32
declaration: %32
begins: %32
at: %32
the: %32
end: %32
of: %32
its: %13
declarator: %32
and: %32
persists: %32
to: %32
the: %32
end: %32
of: %32
the: %32
translation: %32
unit: %32
in: %32
which: %32
it: %32
appears
.: %32
The: %32
scope: %32
of: %32
a: %32
parameter: %32
of: %32
a: %13
function: %32
definition: %32
begins: %32
at: %32
the: %32
start: %32
of: %32
the: %32
block: %32
defining: %32
the: %32
function
,: %32
and: %32
persists: %32
through: %32
the: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
function
;: %32
the: %32
scope: %32
of: %32
a: %32
parameter: %32
in: %32
a: %32
function: %32
declaration: %32
ends: %32
at: %32
the: %32
end: %32
of: %32
the: %32
declarator
.: %32
The: %32
scope: %13
of: %32
an: %32
identifier: %32
declared: %32
at: %32
the: %32
head: %32
of: %32
a: %32
block: %32
begins: %32
at: %32
the: %32
end: %32
of: %32
its: %32
declarator
,: %32
and: %32
persists: %32
to: %32
the: %32
end: %13
of: %32
the: %32
block
.: %32
The: %32
scope: %32
of: %32
a: %32
label: %32
is: %32
the: %32
whole: %32
of: %32
the: %32
function: %32
in: %32
which: %32
it: %32
appears
.: %32
The: %32
scope: %32
of: %32
a: %13
structure
,: %32
union
,: %32
or: %32
enumeration: %32
tag
,: %32
or: %32
an: %32
enumeration: %32
constant
,: %32
begins: %32
at: %32
its: %32
appearance: %32
in: %32
a: %32
type: %13
specifier
,: %32
and: %32
persists: %32
to: %32
the: %32
end: %32
of: %32
a: %32
translation: %32
unit: %32
(
for: %32
declarations: %32
at: %32
the: %32
external: %32
level
): %32
or: %32
to: %32
the: %32
end: %13
of: %32
the: %32
block: %32
(
for: %32
declarations: %32
within: %32
a: %32
function
)
.: %13
If: %32
an: %32
identifier: %32
is: %32
explicitly: %32
declared: %32
at: %32
the: %32
head: %32
of: %32
a: %32
block
,: %32
including: %32
the: %32
block: %32
constituting: %32
a: %32
function
,: %13
any: %32
declaration: %32
of: %32
the: %32
identifier: %32
outside: %32
the: %32
block: %32
is: %32
suspended: %32
until: %32
the: %32
end: %32
of: %32
the: %32
block
.: %13
A
.
1
1
.
2: %32
Linkage: %13
Within: %32
a: %32
translation: %32
unit
,: %32
all: %32
declarations: %32
of: %32
the: %32
same: %32
object: %32
or: %32
function: %32
identifier: %32
with: %32
internal: %32
linkage: %13
refer: %32
to: %32
the: %32
same: %32
thing
,: %32
and: %32
the: %32
object: %32
or: %32
function: %32
is: %32
unique: %32
to: %32
that: %32
translation: %32
unit
.: %32
All: %32
declarations: %32
for: %13
the: %32
same: %32
object: %32
or: %32
function: %32
identifier: %32
with: %32
external: %32
linkage: %32
refer: %32
to: %32
the: %32
same: %32
thing
,: %32
and: %32
the: %32
object: %32
or: %13
function: %32
is: %32
shared: %32
by: %32
the: %32
entire: %32
program
.: %13
As: %32
discussed: %32
in: %32
Par
.
A
.
1
0
.
2
,: %32
the: %32
first: %32
external: %32
declaration: %32
for: %32
an: %32
identifier: %32
gives: %32
the: %32
identifier: %32
internal: %13
linkage: %32
if: %32
the: %32
static: %32
specifier: %32
is: %32
used
,: %32
external: %32
linkage: %32
otherwise
.: %32
If: %32
a: %32
declaration: %32
for: %32
an: %32
identifier: %13
within: %32
a: %32
block: %32
does: %32
not: %32
include: %32
the: %32
extern: %32
specifier
,: %32
then: %32
the: %32
identifier: %32
has: %32
no: %32
linkage: %32
and: %32
is: %32
unique: %32
to: %13
the: %32
function
.: %32
If: %32
it: %32
does: %32
include: %32
extern
,: %32
and: %32
an: %32
external: %32
declaration: %32
for: %32
is: %32
active: %32
in: %32
the: %32
scope: %13
surrounding: %32
the: %32
block
,: %32
then: %32
the: %32
identifier: %32
has: %32
the: %32
same: %32
linkage: %32
as: %32
the: %32
external: %32
declaration
,: %32
and: %32
refers: %32
to: %13
the: %32
same: %32
object: %32
or: %32
function
;: %32
but: %32
if: %32
no: %32
external: %32
declaration: %32
is: %32
visible
,: %32
its: %32
linkage: %32
is: %32
external
.: %13
A
.
1
2: %32
Preprocessing: %13
A: %32
preprocessor: %32
performs: %32
macro: %32
substitution
,: %32
conditional: %32
compilation
,: %32
and: %32
inclusion: %32
of: %32
named: %32
files
.: %32
Lines: %13
beginning: %32
with: %32
#
,: %32
perhaps: %32
preceded: %32
by: %32
white: %32
space
,: %32
communicate: %32
with: %32
this: %32
preprocessor
.: %32
The: %32
syntax: %32
of: %13
these: %32
lines: %32
is: %32
independent: %32
of: %32
the: %32
rest: %32
of: %32
the: %32
language
;: %32
they: %32
may: %32
appear: %32
anywhere: %32
and: %32
have: %32
effect: %32
that: %13
lasts: %32
(
independent: %32
of: %32
scope
): %32
until: %32
the: %32
end: %32
of: %32
the: %32
translation: %32
unit
.: %32
Line: %32
boundaries: %32
are: %32
significant
;: %32
each: %13
line: %32
is: %32
analyzed: %32
individually: %32
(
bus: %32
see: %32
Par
.
A
.
1
2
.
2: %32
for: %32
how: %32
to: %32
adjoin: %32
lines
)
.: %32
To: %32
the: %32
preprocessor
,: %32
a: %32
token: %32
is: %13
any: %32
language: %32
token
,: %32
or: %32
a: %32
character: %32
sequence: %32
giving: %32
a: %32
file: %32
name: %32
as: %32
in: %32
the: %32
#
include: %32
directive: %13
(
Par
.
A
.
1
2
.
4
)
;: %32
in: %32
addition
,: %32
any: %32
character: %32
not: %32
otherwise: %32
defined: %32
is: %32
taken: %32
as: %32
a: %32
token
.: %32
However
,: %32
the: %32
effect: %32
of: %13
white: %32
spaces: %32
other: %32
than: %32
space: %32
and: %32
horizontal: %32
tab: %32
is: %32
undefined: %32
within: %32
preprocessor: %32
lines
.: %13
Preprocessing: %32
itself: %32
takes: %32
place: %32
in: %32
several: %32
logically: %32
successive: %32
phases: %32
that: %32
may
,: %32
in: %32
a: %32
particular: %13
implementation
,: %32
be: %32
condensed
.: %13
1
.: %32
First
,: %32
trigraph: %32
sequences: %32
as: %32
described: %32
in: %32
Par
.
A
.
1
2
.
1: %32
are: %32
replaced: %32
by: %32
their: %32
equivalents
.: %32
Should: %32
the: %13
operating: %32
system: %32
environment: %32
require: %32
it
,: %32
newline: %32
characters: %32
are: %32
introduced: %32
between: %32
the: %32
lines: %32
of: %13
the: %32
source: %32
file
.: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
2
.: %32
Each: %32
occurrence: %32
of: %32
a: %32
backslash: %32
character: %32
\: %32
followed: %32
by: %32
a: %32
newline: %32
is: %32
deleted
,: %32
this: %32
splicing: %32
lines: %13
(
Par
.
A
.
1
2
.
2
)
.: %13
3
.: %32
The: %32
program: %32
is: %32
split: %32
into: %32
tokens: %32
separated: %32
by: %32
white
-
space: %32
characters
;: %32
comments: %32
are: %32
replaced: %32
by: %32
a: %13
single: %32
space
.: %32
Then: %32
preprocessing: %32
directives: %32
are: %32
obeyed
,: %32
and: %32
macros: %32
(
Pars
.
A
.
1
2
.
3
-
A
.
1
2
.
1
0
): %32
are: %13
expanded
.: %13
4
.: %32
Escape: %32
sequences: %32
in: %32
character: %32
constants: %32
and: %32
string: %32
literals: %32
(
Pars
.: %32
A
.
2
.
5
.
2
,: %32
A
.
2
.
6
): %32
are: %32
replaced: %32
by: %13
their: %32
equivalents
;: %32
then: %32
adjacent: %32
string: %32
literals: %32
are: %32
concatenated
.: %13
5
.: %32
The: %32
result: %32
is: %32
translated
,: %32
then: %32
linked: %32
together: %32
with: %32
other: %32
programs: %32
and: %32
libraries
,: %32
by: %32
collecting: %32
the: %13
necessary: %32
programs: %32
and: %32
data
,: %32
and: %32
connecting: %32
external: %32
functions: %32
and: %32
object: %32
references: %32
to: %32
their: %13
definitions
.: %13
A
.
1
2
.
1: %32
Trigraph: %32
Sequences: %13
The: %32
character: %32
set: %32
of: %32
C: %32
source: %32
programs: %32
is: %32
contained: %32
within: %32
seven
-
bit: %32
ASCII
,: %32
but: %32
is: %32
a: %32
superset: %32
of: %32
the: %32
ISO: %13
6
4
6
-
1
9
8
3: %32
Invariant: %32
Code: %32
Set
.: %32
In: %32
order: %32
to: %32
enable: %32
programs: %32
to: %32
be: %32
represented: %32
in: %32
the: %32
reduced: %32
set
,: %32
all: %13
occurrences: %32
of: %32
the: %32
following: %32
trigraph: %32
sequences: %32
are: %32
replaced: %32
by: %32
the: %32
corresponding: %32
single: %32
character
.: %32
This: %13
replacement: %32
occurs: %32
before: %32
any: %32
other: %32
processing
.: %13
?
?
=: %13
?
?
/: %13
?
?
': %13
#: %13
\: %13
^: %13
?
?
(: %13
?
?
): %13
?
?
!: %13
[: %13
]: %13
|: %13
?
?
<: %13
?
?
>: %13
?
?
-: %13
{: %13
}: %13
~: %13
No: %32
other: %32
such: %32
replacements: %32
occur
.: %13
Trigraph: %32
sequences: %32
are: %32
new: %32
with: %32
the: %32
ANSI: %32
standard
.: %13
A
.
1
2
.
2: %32
Line: %32
Splicing: %13
Lines: %32
that: %32
end: %32
with: %32
the: %32
backslash: %32
character: %32
\: %32
are: %32
folded: %32
by: %32
deleting: %32
the: %32
backslash: %32
and: %32
the: %32
following: %13
newline: %32
character
.: %32
This: %32
occurs: %32
before: %32
division: %32
into: %32
tokens
.: %13
A
.
1
2
.
3: %32
Macro: %32
Definition: %32
and: %32
Expansion: %13
A: %32
control: %32
line: %32
of: %32
the: %32
form: %13
#: %32
define: %32
identifier: %32
token
-
sequence: %13
causes: %32
the: %32
preprocessor: %32
to: %32
replace: %32
subsequent: %32
instances: %32
of: %32
the: %32
identifier: %32
with: %32
the: %32
given: %32
sequence: %32
of: %13
tokens
;: %32
leading: %32
and: %32
trailing: %32
white: %32
space: %32
around: %32
the: %32
token: %32
sequence: %32
is: %32
discarded
.: %32
A: %32
second: %32
#
define: %32
for: %13
the: %32
same: %32
identifier: %32
is: %32
erroneous: %32
unless: %32
the: %32
second: %32
token: %32
sequence: %32
is: %32
identical: %32
to: %32
the: %32
first
,: %32
where: %32
all: %32
white: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
space: %32
separations: %32
are: %32
taken: %32
to: %32
be: %32
equivalent
.: %13
A: %32
line: %32
of: %32
the: %32
form: %13
#: %32
define: %32
identifier: %32
(
identifier
-
list
): %32
token
-
sequence: %13
where: %32
there: %32
is: %32
no: %32
space: %32
between: %32
the: %32
first: %32
identifier: %32
and: %32
the: %32
(
,: %32
is: %32
a: %32
macro: %32
definition: %32
with: %32
parameters: %32
given: %13
by: %32
the: %32
identifier: %32
list
.: %32
As: %32
with: %32
the: %32
first: %32
form
,: %32
leading: %32
and: %32
trailing: %32
white: %32
space: %32
arround: %32
the: %32
token: %32
sequence: %13
is: %32
discarded
,: %32
and: %32
the: %32
macro: %32
may: %32
be: %32
redefined: %32
only: %32
with: %32
a: %32
definition: %32
in: %32
which: %32
the: %32
number: %32
and: %32
spelling: %32
of: %13
parameters
,: %32
and: %32
the: %32
token: %32
sequence
,: %32
is: %32
identical
.: %13
A: %32
control: %32
line: %32
of: %32
the: %32
form: %13
#: %32
undef: %32
identifier: %13
causes: %32
the: %32
identifier
'
s: %32
preprocessor: %32
definition: %32
to: %32
be: %32
forgotten
.: %32
It: %32
is: %32
not: %32
erroneous: %32
to: %32
apply: %32
#
undef: %32
to: %32
an: %13
unknown: %32
identifier
.: %13
When: %32
a: %32
macro: %32
has: %32
been: %32
defined: %32
in: %32
the: %32
second: %32
form
,: %32
subsequent: %32
textual: %32
instances: %32
of: %32
the: %32
macro: %32
identifier: %13
followed: %32
by: %32
optional: %32
white: %32
space
,: %32
and: %32
then: %32
by: %32
(
,: %32
a: %32
sequence: %32
of: %32
tokens: %32
separated: %32
by: %32
commas
,: %32
and: %32
a: %32
): %13
constitute: %32
a: %32
call: %32
of: %32
the: %32
macro
.: %32
The: %32
arguments: %32
of: %32
the: %32
call: %32
are: %32
the: %32
comma
-
separated: %32
token: %32
sequences
;: %13
commas: %32
that: %32
are: %32
quoted: %32
or: %32
protected: %32
by: %32
nested: %32
parentheses: %32
do: %32
not: %32
separate: %32
arguments
.: %32
During: %32
collection
,: %13
arguments: %32
are: %32
not: %32
macro
-
expanded
.: %32
The: %32
number: %32
of: %32
arguments: %32
in: %32
the: %32
call: %32
must: %32
match: %32
the: %32
number: %32
of: %13
parameters: %32
in: %32
the: %32
definition
.: %32
After: %32
the: %32
arguments: %32
are: %32
isolated
,: %32
leading: %32
and: %32
trailing: %32
white: %32
space: %32
is: %32
removed: %13
from: %32
them
.: %32
Then: %32
the: %32
token: %32
sequence: %32
resulting: %32
from: %32
each: %32
argument: %32
is: %32
substituted: %32
for: %32
each: %32
unquoted: %13
occurrence: %32
of: %32
the: %32
corresponding: %32
parameter
'
s: %32
identifier: %32
in: %32
the: %32
replacement: %32
token: %32
sequence: %32
of: %32
the: %32
macro
.: %13
Unless: %32
the: %32
parameter: %32
in: %32
the: %32
replacement: %32
sequence: %32
is: %32
preceded: %32
by: %32
#
,: %32
or: %32
preceded: %32
or: %32
followed: %32
by: %32
#
#
,: %32
the: %13
argument: %32
tokens: %32
are: %32
examined: %32
for: %32
macro: %32
calls
,: %32
and: %32
expanded: %32
as: %32
necessary
,: %32
just: %32
before: %32
insertion
.: %13
Two: %32
special: %32
operators: %32
influence: %32
the: %32
replacement: %32
process
.: %32
First
,: %32
if: %32
an: %32
occurrence: %32
of: %32
a: %32
parameter: %32
in: %32
the: %13
replacement: %32
token: %32
sequence: %32
is: %32
immediately: %32
preceded: %32
by: %32
#
,: %32
string: %32
quotes: %32
(
"
): %32
are: %32
placed: %32
around: %32
the: %13
corresponding: %32
parameter
,: %32
and: %32
then: %32
both: %32
the: %32
#: %32
and: %32
the: %32
parameter: %32
identifier: %32
are: %32
replaced: %32
by: %32
the: %32
quoted: %13
argument
.: %32
A: %32
\: %32
character: %32
is: %32
inserted: %32
before: %32
each: %32
": %32
or: %32
\: %32
character: %32
that: %32
appears: %32
surrounding
,: %32
or: %32
inside
,: %32
a: %13
string: %32
literal: %32
or: %32
character: %32
constant: %32
in: %32
the: %32
argument
.: %13
Second
,: %32
if: %32
the: %32
definition: %32
token: %32
sequence: %32
for: %32
either: %32
kind: %32
of: %32
macro: %32
contains: %32
a: %32
#
#: %32
operator
,: %32
then: %32
just: %32
after: %13
replacement: %32
of: %32
the: %32
parameters
,: %32
each: %32
#
#: %32
is: %32
deleted
,: %32
together: %32
with: %32
any: %32
white: %32
space: %32
on: %32
either: %32
side
,: %32
so: %32
as: %32
to: %13
concatenate: %32
the: %32
adjacent: %32
tokens: %32
and: %32
form: %32
a: %32
new: %32
token
.: %32
The: %32
effect: %32
is: %32
undefined: %32
if: %32
invalid: %32
tokens: %32
are: %13
produced
,: %32
or: %32
if: %32
the: %32
result: %32
depends: %32
on: %32
the: %32
order: %32
of: %32
processing: %32
of: %32
the: %32
#
#: %32
operators
.: %32
Also
,: %32
#
#: %32
may: %32
not: %13
appear: %32
at: %32
the: %32
beginning: %32
or: %32
end: %32
of: %32
a: %32
replacement: %32
token: %32
sequence
.: %13
In: %32
both: %32
kinds: %32
of: %32
macro
,: %32
the: %32
replacement: %32
token: %32
sequence: %32
is: %32
repeatedly: %32
rescanned: %32
for: %32
more: %32
defined: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
identifiers
.: %32
However
,: %32
once: %32
a: %32
given: %32
identifier: %32
has: %32
been: %32
replaced: %32
in: %32
a: %32
given: %32
expansion
,: %32
it: %32
is: %32
not: %32
replaced: %32
if: %13
it: %32
turns: %32
up: %32
again: %32
during: %32
rescanning
;: %32
instead: %32
it: %32
is: %32
left: %32
unchanged
.: %13
Even: %32
if: %32
the: %32
final: %32
value: %32
of: %32
a: %32
macro: %32
expansion: %32
begins: %32
with: %32
with: %32
#
,: %32
it: %32
is: %32
not: %32
taken: %32
to: %32
be: %32
a: %32
preprocessing: %13
directive
.: %13
The: %32
details: %32
of: %32
the: %32
macro
-
expansion: %32
process: %32
are: %32
described: %32
more: %32
precisely: %32
in: %32
the: %32
ANSI: %32
standard: %32
than: %32
in: %32
the: %32
first: %13
edition
.: %32
The: %32
most: %32
important: %32
change: %32
is: %32
the: %32
addition: %32
of: %32
the: %32
#: %32
and: %32
#
#: %32
operators
,: %32
which: %32
make: %32
quotation: %32
and: %13
concatenation: %32
admissible
.: %32
Some: %32
of: %32
the: %32
new: %32
rules
,: %32
especially: %32
those: %32
involving: %32
concatenation
,: %32
are: %32
bizarre
.: %32
(
See: %13
example: %32
below
.
): %13
For: %32
example
,: %32
this: %32
facility: %32
may: %32
be: %32
used: %32
for: %32
`
`
manifest
-
constants
,
'
': %32
as: %32
in: %13
#
define: %32
TABSIZE: %32
1
0
0: %13
int: %32
table
[
TABSIZE
]
;: %13
The: %32
definition: %13
#
define: %32
ABSDIFF
(
a
,: %32
b
): %13
(
(
a
)
>
(
b
): %32
?: %32
(
a
)
-
(
b
): %32
:: %32
(
b
)
-
(
a
)
): %13
defines: %32
a: %32
macro: %32
to: %32
return: %32
the: %32
absolute: %32
value: %32
of: %32
the: %32
difference: %32
between: %32
its: %32
arguments
.: %32
Unlike: %32
a: %32
function: %32
to: %13
do: %32
the: %32
same: %32
thing
,: %32
the: %32
arguments: %32
and: %32
returned: %32
value: %32
may: %32
have: %32
any: %32
arithmetic: %32
type: %32
or: %32
even: %32
be: %32
pointers
.: %13
Also
,: %32
the: %32
arguments
,: %32
which: %32
might: %32
have: %32
side: %32
effects
,: %32
are: %32
evaluated: %32
twice
,: %32
once: %32
for: %32
the: %32
test: %32
and: %32
once: %32
to: %13
produce: %32
the: %32
value
.: %13
Given: %32
the: %32
definition: %13
#
define: %32
tempfile
(
dir
): %13
#
dir: %32
"
%:
s
": %13
the: %32
macro: %32
call: %32
tempfile
(
/
usr
/
tmp
): %32
yields: %13
"
/
usr
/
tmp
": %32
"
%:
s
": %13
which: %32
will: %32
subsequently: %32
be: %32
catenated: %32
into: %32
a: %32
single: %32
string
.: %32
After: %13
#
define: %32
cat
(
x
,: %32
y
): %13
x: %32
#
#: %32
y: %13
the: %32
call: %32
cat
(
var
,: %32
1
2
3
): %32
yields: %32
var
1
2
3
.: %32
However
,: %32
the: %32
call: %32
cat
(
cat
(
1
,
2
)
,
3
): %32
is: %32
undefined
:: %32
the: %13
presence: %32
of: %32
#
#: %32
prevents: %32
the: %32
arguments: %32
of: %32
the: %32
outer: %32
call: %32
from: %32
being: %32
expanded
.: %32
Thus: %32
it: %32
produces: %32
the: %32
token: %13
string: %13
cat: %13
(: %13
1: %13
,: %13
2: %13
)
3: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
and: %32
)
3: %32
(
the: %32
catenation: %32
of: %32
the: %32
last: %32
token: %32
of: %32
the: %32
first: %32
argument: %32
with: %32
the: %32
first: %32
token: %32
of: %32
the: %32
second
): %32
is: %32
not: %32
a: %13
legal: %32
token
.: %32
If: %32
a: %32
second: %32
level: %32
of: %32
macro: %32
definition: %32
is: %32
introduced
,: %13
#
define: %32
xcat
(
x
,: %32
y
): %13
cat
(
x
,
y
): %13
things: %32
work: %32
more: %32
smoothly
;: %32
xcat
(
xcat
(
1
,: %32
2
)
,: %32
3
): %32
does: %32
produce: %32
1
2
3
,: %32
because: %32
the: %32
expansion: %32
of: %13
xcat: %32
itself: %32
does: %32
not: %32
involve: %32
the: %32
#
#: %32
operator
.: %13
Likewise
,: %32
ABSDIFF
(
ABSDIFF
(
a
,
b
)
,
c
): %32
produces: %32
the: %32
expected
,: %32
fully
-
expanded: %32
result
.: %13
A
.
1
2
.
4: %32
File: %32
Inclusion: %13
A: %32
control: %32
line: %32
of: %32
the: %32
form: %13
#: %32
include: %32
<
filename
>: %13
causes: %32
the: %32
replacement: %32
of: %32
that: %32
line: %32
by: %32
the: %32
entire: %32
contents: %32
of: %32
the: %32
file: %32
filename
.: %32
The: %32
characters: %32
in: %32
the: %32
name: %13
filename: %32
must: %32
not: %32
include: %32
>: %32
or: %32
newline
,: %32
and: %32
the: %32
effect: %32
is: %32
undefined: %32
if: %32
it: %32
contains: %32
any: %32
of: %32
"
,: %32
'
,: %32
\
,: %32
or: %32
/
*
.: %13
The: %32
named: %32
file: %32
is: %32
searched: %32
for: %32
in: %32
a: %32
sequence: %32
of: %32
implementation
-
defined: %32
places
.: %13
Similarly
,: %32
a: %32
control: %32
line: %32
of: %32
the: %32
form: %13
#: %32
include: %32
"
filename
": %13
searches: %32
first: %32
in: %32
association: %32
with: %32
the: %32
original: %32
source: %32
file: %32
(
a: %32
deliberately: %32
implementation
-
dependent: %13
phrase
)
,: %32
and: %32
if: %32
that: %32
search: %32
fails
,: %32
then: %32
as: %32
in: %32
the: %32
first: %32
form
.: %32
The: %32
effect: %32
of: %32
using: %32
'
,: %32
\
,: %32
or: %32
/
*: %32
in: %32
the: %32
filename: %13
remains: %32
undefined
,: %32
but: %32
>: %32
is: %32
permitted
.: %13
Finally
,: %32
a: %32
directive: %32
of: %32
the: %32
form: %13
#: %32
include: %32
token
-
sequence: %13
not: %32
matching: %32
one: %32
of: %32
the: %32
previous: %32
forms: %32
is: %32
interpreted: %32
by: %32
expanding: %32
the: %32
token: %32
sequence: %32
as: %32
for: %32
normal: %13
text
;: %32
one: %32
of: %32
the: %32
two: %32
forms: %32
with: %32
<
.
.
.
>: %32
or: %32
"
.
.
.
": %32
must: %32
result
,: %32
and: %32
is: %32
then: %32
treated: %32
as: %32
previously: %13
described
.: %13
#
include: %32
files: %32
may: %32
be: %32
nested
.: %13
A
.
1
2
.
5: %32
Conditional: %32
Compilation: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
Parts: %32
of: %32
a: %32
program: %32
may: %32
be: %32
compiled: %32
conditionally
,: %32
according: %32
to: %32
the: %32
following: %32
schematic: %32
syntax
.: %13
preprocessor
-
conditional
:: %13
if
-
line: %32
text: %32
elif
-
parts: %32
else
-
partopt: %32
#
endif: %13
if
-
line
:: %13
#: %32
if: %32
constant
-
expression: %13
#: %32
ifdef: %32
identifier: %13
#: %32
ifndef: %32
identifier: %13
elif
-
parts
:: %13
elif
-
line: %32
text: %13
elif
-
partsopt: %13
elif
-
line
:: %13
#: %32
elif: %32
constant
-
expression: %13
else
-
part
:: %13
else
-
line: %32
text: %13
else
-
line
:: %13
#
else: %13
Each: %32
of: %32
the: %32
directives: %32
(
if
-
line
,: %32
elif
-
line
,: %32
else
-
line
,: %32
and: %32
#
endif
): %32
appears: %32
alone: %32
on: %32
a: %32
line
.: %32
The: %32
constant: %13
expressions: %32
in: %32
#
if: %32
and: %32
subsequent: %32
#
elif: %32
lines: %32
are: %32
evaluated: %32
in: %32
order: %32
until: %32
an: %32
expression: %32
with: %32
a: %32
non
-: %13
zero: %32
value: %32
is: %32
found
;: %32
text: %32
following: %32
a: %32
line: %32
with: %32
a: %32
zero: %32
value: %32
is: %32
discarded
.: %32
The: %32
text: %32
following: %32
the: %32
successful: %13
directive: %32
line: %32
is: %32
treated: %32
normally
.: %32
`
`
Text
'
': %32
here: %32
refers: %32
to: %32
any: %32
material
,: %32
including: %32
preprocessor: %32
lines
,: %32
that: %32
is: %13
not: %32
part: %32
of: %32
the: %32
conditional: %32
structure
;: %32
it: %32
may: %32
be: %32
empty
.: %32
Once: %32
a: %32
successful: %32
#
if: %32
or: %32
#
elif: %32
line: %32
has: %32
been: %13
found: %32
and: %32
its: %32
text: %32
processed
,: %32
succeeding: %32
#
elif: %32
and: %32
#
else: %32
lines
,: %32
together: %32
with: %32
their: %32
text
,: %32
are: %32
discarded
.: %13
If: %32
all: %32
the: %32
expressions: %32
are: %32
zero
,: %32
and: %32
there: %32
is: %32
an: %32
#
else
,: %32
the: %32
text: %32
following: %32
the: %32
#
else: %32
is: %32
treated: %32
normally
.: %13
Text: %32
controlled: %32
by: %32
inactive: %32
arms: %32
of: %32
the: %32
conditional: %32
is: %32
ignored: %32
except: %32
for: %32
checking: %32
the: %32
nesting: %32
of: %13
conditionals
.: %13
The: %32
constant: %32
expression: %32
in: %32
#
if: %32
and: %32
#
elif: %32
is: %32
subject: %32
to: %32
ordinary: %32
macro: %32
replacement
.: %32
Moreover
,: %32
any: %13
expressions: %32
of: %32
the: %32
form: %13
defined: %32
identifier: %13
or: %13
defined: %32
(
identifier
): %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
are: %32
replaced
,: %32
before: %32
scanning: %32
for: %32
macros
,: %32
by: %32
1
L: %32
if: %32
the: %32
identifier: %32
is: %32
defined: %32
in: %32
the: %32
preprocessor
,: %32
and: %32
by: %32
0
L: %13
if: %32
not
.: %32
Any: %32
identifiers: %32
remaining: %32
after: %32
macro: %32
expansion: %32
are: %32
replaced: %32
by: %32
0
L
.: %32
Finally
,: %32
each: %32
integer: %32
constant: %13
is: %32
considered: %32
to: %32
be: %32
suffixed: %32
with: %32
L
,: %32
so: %32
that: %32
all: %32
arithmetic: %32
is: %32
taken: %32
to: %32
be: %32
long: %32
or: %32
unsigned: %32
long
.: %13
The: %32
resulting: %32
constant: %32
expression: %32
(
Par
.
A
.
7
.
1
9
): %32
is: %32
restricted
:: %32
it: %32
must: %32
be: %32
integral
,: %32
and: %32
may: %32
not: %32
contain: %13
sizeof
,: %32
a: %32
cast
,: %32
or: %32
an: %32
enumeration: %32
constant
.: %13
The: %32
control: %32
lines: %13
#
ifdef: %32
identifier: %13
#
ifndef: %32
identifier: %13
are: %32
equivalent: %32
to: %13
#: %32
if: %32
defined: %32
identifier: %13
#: %32
if: %32
!: %32
defined: %32
identifier: %13
respectively
.: %13
#
elif: %32
is: %32
new: %32
since: %32
the: %32
first: %32
edition
,: %32
although: %32
it: %32
has: %32
been: %32
available: %32
is: %32
some: %32
preprocessors
.: %32
The: %32
defined: %13
preprocessor: %32
operator: %32
is: %32
also: %32
new
.: %13
A
.
1
2
.
6: %32
Line: %32
Control: %13
For: %32
the: %32
benefit: %32
of: %32
other: %32
preprocessors: %32
that: %32
generate: %32
C: %32
programs
,: %32
a: %32
line: %32
in: %32
one: %32
of: %32
the: %32
forms: %13
#: %32
line: %32
constant: %32
"
filename
": %13
#: %32
line: %32
constant: %13
causes: %32
the: %32
compiler: %32
to: %32
believe
,: %32
for: %32
purposes: %32
of: %32
error: %32
diagnostics
,: %32
that: %32
the: %32
line: %32
number: %32
of: %32
the: %32
next: %32
source: %13
line: %32
is: %32
given: %32
by: %32
the: %32
decimal: %32
integer: %32
constant: %32
and: %32
the: %32
current: %32
input: %32
file: %32
is: %32
named: %32
by: %32
the: %32
identifier
.: %32
If: %32
the: %13
quoted: %32
filename: %32
is: %32
absent
,: %32
the: %32
remembered: %32
name: %32
does: %32
not: %32
change
.: %32
Macros: %32
in: %32
the: %32
line: %32
are: %32
expanded: %13
before: %32
it: %32
is: %32
interpreted
.: %13
A
.
1
2
.
7: %32
Error: %32
Generation: %13
A: %32
preprocessor: %32
line: %32
of: %32
the: %32
form: %13
#: %32
error: %32
token
-
sequenceopt: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
causes: %32
the: %32
preprocessor: %32
to: %32
write: %32
a: %32
diagnostic: %32
message: %32
that: %32
includes: %32
the: %32
token: %32
sequence
.: %13
A
.
1
2
.
8: %32
Pragmas: %13
A: %32
control: %32
line: %32
of: %32
the: %32
form: %13
#: %32
pragma: %32
token
-
sequenceopt: %13
causes: %32
the: %32
preprocessor: %32
to: %32
perform: %32
an: %32
implementation
-
dependent: %32
action
.: %32
An: %32
unrecognized: %32
pragma: %32
is: %13
ignored
.: %13
A
.
1
2
.
9: %32
Null: %32
directive: %13
A: %32
control: %32
line: %32
of: %32
the: %32
form: %13
#: %13
has: %32
no: %32
effect
.: %13
A
.
1
2
.
1
0: %32
Predefined: %32
names: %13
Several: %32
identifiers: %32
are: %32
predefined
,: %32
and: %32
expand: %32
to: %32
produce: %32
special: %32
information
.: %32
They
,: %32
and: %32
also: %32
the: %13
preprocessor: %32
expansion: %32
operator: %32
defined
,: %32
may: %32
not: %32
be: %32
undefined: %32
or: %32
redefined
.: %13
_
_
LINE
_
_: %32
A: %32
decimal: %32
constant: %32
containing: %32
the: %32
current: %32
source: %32
line: %32
number
.: %13
_
_
FILE
_
_: %32
A: %32
string: %32
literal: %32
containing: %32
the: %32
name: %32
of: %32
the: %32
file: %32
being: %32
compiled
.: %13
_
_
DATE
_
_: %32
A: %32
string: %32
literal: %32
containing: %32
the: %32
date: %32
of: %32
compilation
,: %32
in: %32
the: %32
form: %32
"
Mmmm: %32
dd: %32
yyyy
": %13
_
_
TIME
_
_: %32
A: %32
string: %32
literal: %32
containing: %32
the: %32
time: %32
of: %32
compilation
,: %32
in: %32
the: %32
form: %32
"
hh
::
mm
::
ss
": %13
The: %32
constant: %32
1
.: %32
It: %32
is: %32
intended: %32
that: %32
this: %32
identifier: %32
be: %32
defined: %32
to: %32
be: %32
1: %32
only: %32
in: %32
standard
-: %13
_
_
STDC
_
_: %13
conforming: %32
implementations
.: %13
#
error: %32
and: %32
#
pragma: %32
are: %32
new: %32
with: %32
the: %32
ANSI: %32
standard
;: %32
the: %32
predefined: %32
preprocessor: %32
macros: %32
are: %32
new
,: %32
but: %32
some: %13
of: %32
them: %32
have: %32
been: %32
available: %32
in: %32
some: %32
implementations
.: %13
A
.
1
3: %32
Grammar: %13
Below: %32
is: %32
a: %32
recapitulation: %32
of: %32
the: %32
grammar: %32
that: %32
was: %32
given: %32
throughout: %32
the: %32
earlier: %32
part: %32
of: %32
this: %32
appendix
.: %32
It: %13
has: %32
exactly: %32
the: %32
same: %32
content
,: %32
but: %32
is: %32
in: %32
different: %32
order
.: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
The: %32
grammar: %32
has: %32
undefined: %32
terminal: %32
symbols: %32
integer
-
constant
,: %32
character
-
constant
,: %32
floating
-
constant
,: %13
identifier
,: %32
string
,: %32
and: %32
enumeration
-
constant
;: %32
the: %32
typewriter: %32
style: %32
words: %32
and: %32
symbols: %32
are: %32
terminals: %13
given: %32
literally
.: %32
This: %32
grammar: %32
can: %32
be: %32
transformed: %32
mechanically: %32
into: %32
input: %32
acceptable: %32
for: %32
an: %32
automatic: %13
parser
-
generator
.: %32
Besides: %32
adding: %32
whatever: %32
syntactic: %32
marking: %32
is: %32
used: %32
to: %32
indicate: %32
alternatives: %32
in: %13
productions
,: %32
it: %32
is: %32
necessary: %32
to: %32
expand: %32
the: %32
`
`
one: %32
of
'
': %32
constructions
,: %32
and: %32
(
depending: %32
on: %32
the: %32
rules: %32
of: %32
the: %13
parser
-
generator
): %32
to: %32
duplicate: %32
each: %32
production: %32
with: %32
an: %32
opt: %32
symbol
,: %32
once: %32
with: %32
the: %32
symbol: %32
and: %32
once: %13
without
.: %32
With: %32
one: %32
further: %32
change
,: %32
namely: %32
deleting: %32
the: %32
production: %32
typedef
-
name
:: %32
identifier: %32
and: %32
making: %13
typedef
-
name: %32
a: %32
terminal: %32
symbol
,: %32
this: %32
grammar: %32
is: %32
acceptable: %32
to: %32
the: %32
YACC: %32
parser
-
generator
.: %32
It: %32
has: %32
only: %13
one: %32
conflict
,: %32
generated: %32
by: %32
the: %32
if
-
else: %32
ambiguity
.: %13
translation
-
unit
:: %13
external
-
declaration: %13
translation
-
unit: %32
external
-
declaration: %13
external
-
declaration
:: %13
function
-
definition: %13
declaration: %13
function
-
definition
:: %13
declaration
-
specifiersopt: %32
declarator: %32
declaration
-
listopt: %32
compound
-
statement: %13
declaration
:: %13
declaration
-
specifiers: %32
init
-
declarator
-
listopt
;: %13
declaration
-
list
:: %13
declaration: %13
declaration
-
list: %32
declaration: %13
declaration
-
specifiers
:: %13
storage
-
class
-
specifier: %32
declaration
-
specifiersopt: %13
type
-
specifier: %32
declaration
-
specifiersopt: %13
type
-
qualifier: %32
declaration
-
specifiersopt: %13
storage
-
class: %32
specifier
:: %32
one: %32
of: %13
auto: %32
register: %32
static: %32
extern: %32
typedef: %13
type: %32
specifier
:: %32
one: %32
of: %13
void: %32
char: %32
short: %32
int: %32
long: %32
float: %32
double: %32
signed: %13
unsigned: %32
struct
-
or
-
union
-
specifier: %32
enum
-
specifier: %32
typedef
-
name: %13
type
-
qualifier
:: %32
one: %32
of: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
const: %32
volatile: %13
struct
-
or
-
union
-
specifier
:: %13
struct
-
or
-
union: %32
identifieropt: %32
{: %32
struct
-
declaration
-
list: %32
}: %13
struct
-
or
-
union: %32
identifier: %13
struct
-
or
-
union
:: %32
one: %32
of: %13
struct: %32
union: %13
struct
-
declaration
-
list
:: %13
struct: %32
declaration: %13
struct
-
declaration
-
list: %32
struct: %32
declaration: %13
init
-
declarator
-
list
:: %13
init
-
declarator: %13
init
-
declarator
-
list
,: %32
init
-
declarator: %13
init
-
declarator
:: %13
declarator: %13
declarator: %32
=: %32
initializer: %13
struct
-
declaration
:: %13
specifier
-
qualifier
-
list: %32
struct
-
declarator
-
list
;: %13
specifier
-
qualifier
-
list
:: %13
type
-
specifier: %32
specifier
-
qualifier
-
listopt: %13
type
-
qualifier: %32
specifier
-
qualifier
-
listopt: %13
struct
-
declarator
-
list
:: %13
struct
-
declarator: %13
struct
-
declarator
-
list: %32
,: %32
struct
-
declarator: %13
struct
-
declarator
:: %13
declarator: %13
declaratoropt: %32
:: %32
constant
-
expression: %13
enum
-
specifier
:: %13
enum: %32
identifieropt: %32
{: %32
enumerator
-
list: %32
}: %13
enum: %32
identifier: %13
enumerator
-
list
:: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
enumerator: %13
enumerator
-
list: %32
,: %32
enumerator: %13
enumerator
:: %13
identifier: %13
identifier: %32
=: %32
constant
-
expression: %13
declarator
:: %13
pointeropt: %32
direct
-
declarator: %13
direct
-
declarator
:: %13
identifier: %13
(
declarator
): %13
direct
-
declarator: %32
[: %32
constant
-
expressionopt: %32
]: %13
direct
-
declarator: %32
(: %32
parameter
-
type
-
list: %32
): %13
direct
-
declarator: %32
(: %32
identifier
-
listopt: %32
): %13
pointer
:: %13
*: %32
type
-
qualifier
-
listopt: %13
*: %32
type
-
qualifier
-
listopt: %32
pointer: %13
type
-
qualifier
-
list
:: %13
type
-
qualifier: %13
type
-
qualifier
-
list: %32
type
-
qualifier: %13
parameter
-
type
-
list
:: %13
parameter
-
list: %13
parameter
-
list: %32
,: %32
.
.
.: %13
parameter
-
list
:: %13
parameter
-
declaration: %13
parameter
-
list: %32
,: %32
parameter
-
declaration: %13
parameter
-
declaration
:: %13
declaration
-
specifiers: %32
declarator: %13
declaration
-
specifiers: %32
abstract
-
declaratoropt: %13
identifier
-
list
:: %13
identifier: %13
identifier
-
list: %32
,: %32
identifier: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
initializer
:: %13
assignment
-
expression: %13
{: %32
initializer
-
list: %32
}: %13
{: %32
initializer
-
list: %32
,: %32
}: %13
initializer
-
list
:: %13
initializer: %13
initializer
-
list: %32
,: %32
initializer: %13
type
-
name
:: %13
specifier
-
qualifier
-
list: %32
abstract
-
declaratoropt: %13
abstract
-
declarator
:: %13
pointer: %13
pointeropt: %32
direct
-
abstract
-
declarator: %13
direct
-
abstract
-
declarator
:: %13
(: %32
abstract
-
declarator: %32
): %13
direct
-
abstract
-
declaratoropt: %32
[
constant
-
expressionopt
]: %13
direct
-
abstract
-
declaratoropt: %32
(
parameter
-
type
-
listopt
): %13
typedef
-
name
:: %13
identifier: %13
statement
:: %13
labeled
-
statement: %13
expression
-
statement: %13
compound
-
statement: %13
selection
-
statement: %13
iteration
-
statement: %13
jump
-
statement: %13
labeled
-
statement
:: %13
identifier: %32
:: %32
statement: %13
case: %32
constant
-
expression: %32
:: %32
statement: %13
default: %32
:: %32
statement: %13
expression
-
statement
:: %13
expressionopt
;: %13
compound
-
statement
:: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
{: %32
declaration
-
listopt: %32
statement
-
listopt: %32
}: %13
statement
-
list
:: %13
statement: %13
statement
-
list: %32
statement: %13
selection
-
statement
:: %13
if: %32
(
expression
): %32
statement: %13
if: %32
(
expression
): %32
statement: %32
else: %32
statement: %13
switch: %32
(
expression
): %32
statement: %13
iteration
-
statement
:: %13
while: %32
(
expression
): %32
statement: %13
do: %32
statement: %32
while: %32
(
expression
)
;: %13
for: %32
(
expressionopt
;: %32
expressionopt
;: %32
expressionopt
): %32
statement: %13
jump
-
statement
:: %13
goto: %32
identifier
;: %13
continue
;: %13
break
;: %13
return: %32
expressionopt
;: %13
expression
:: %13
assignment
-
expression: %13
expression: %32
,: %32
assignment
-
expression: %13
assignment
-
expression
:: %13
conditional
-
expression: %13
unary
-
expression: %32
assignment
-
operator: %32
assignment
-
expression: %13
assignment
-
operator
:: %32
one: %32
of: %13
=: %32
*
=: %32
/
=: %32
%:
=: %32
+
=: %32
-
=: %32
<
<
=: %32
>
>
=: %32
&
=: %32
^
=: %32
|
=: %13
conditional
-
expression
:: %13
logical
-
OR
-
expression: %13
logical
-
OR
-
expression: %32
?: %32
expression: %32
:: %32
conditional
-
expression: %13
constant
-
expression
:: %13
conditional
-
expression: %13
logical
-
OR
-
expression
:: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
logical
-
AND
-
expression: %13
logical
-
OR
-
expression: %32
|
|: %32
logical
-
AND
-
expression: %13
logical
-
AND
-
expression
:: %13
inclusive
-
OR
-
expression: %13
logical
-
AND
-
expression: %32
&
&: %32
inclusive
-
OR
-
expression: %13
inclusive
-
OR
-
expression
:: %13
exclusive
-
OR
-
expression: %13
inclusive
-
OR
-
expression: %32
|: %32
exclusive
-
OR
-
expression: %13
exclusive
-
OR
-
expression
:: %13
AND
-
expression: %13
exclusive
-
OR
-
expression: %32
^: %32
AND
-
expression: %13
AND
-
expression
:: %13
equality
-
expression: %13
AND
-
expression: %32
&: %32
equality
-
expression: %13
equality
-
expression
:: %13
relational
-
expression: %13
equality
-
expression: %32
=
=: %32
relational
-
expression: %13
equality
-
expression: %32
!
=: %32
relational
-
expression: %13
relational
-
expression
:: %13
shift
-
expression: %13
relational
-
expression: %32
<: %32
shift
-
expression: %13
relational
-
expression: %32
>: %32
shift
-
expression: %13
relational
-
expression: %32
<
=: %32
shift
-
expression: %13
relational
-
expression: %32
>
=: %32
shift
-
expression: %13
shift
-
expression
:: %13
additive
-
expression: %13
shift
-
expression: %32
<
<: %32
additive
-
expression: %13
shift
-
expression: %32
>
>: %32
additive
-
expression: %13
additive
-
expression
:: %13
multiplicative
-
expression: %13
additive
-
expression: %32
+: %32
multiplicative
-
expression: %13
additive
-
expression: %32
-: %32
multiplicative
-
expression: %13
multiplicative
-
expression
:: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
multiplicative
-
expression: %32
*: %32
cast
-
expression: %13
multiplicative
-
expression: %32
/: %32
cast
-
expression: %13
multiplicative
-
expression: %32
%: %32
cast
-
expression: %13
cast
-
expression
:: %13
unary: %32
expression: %13
(
type
-
name
): %32
cast
-
expression: %13
unary
-
expression
:: %13
postfix: %32
expression: %13
+
+
unary: %32
expression: %13
-
-
unary: %32
expression: %13
unary
-
operator: %32
cast
-
expression: %13
sizeof: %32
unary
-
expression: %13
sizeof: %32
(
type
-
name
): %13
unary: %32
operator
:: %32
one: %32
of: %13
&: %32
*: %32
+: %32
-: %32
~: %32
!: %13
postfix
-
expression
:: %13
primary
-
expression: %13
postfix
-
expression
[
expression
]: %13
postfix
-
expression
(
argument
-
expression
-
listopt
): %13
postfix
-
expression
.
identifier: %13
postfix
-
expression
-
>
+
identifier: %13
postfix
-
expression
+
+: %13
postfix
-
expression
-
-: %13
primary
-
expression
:: %13
identifier: %13
constant: %13
string: %13
(
expression
): %13
argument
-
expression
-
list
:: %13
assignment
-
expression: %13
assignment
-
expression
-
list: %32
,: %32
assignment
-
expression: %13
constant
:: %13
integer
-
constant: %13
character
-
constant: %13
floating
-
constant: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
enumeration
-
constant: %13
The: %32
following: %32
grammar: %32
for: %32
the: %32
preprocessor: %32
summarizes: %32
the: %32
structure: %32
of: %32
control: %32
lines
,: %32
but: %32
is: %32
not: %32
suitable: %13
for: %32
mechanized: %32
parsing
.: %32
It: %32
includes: %32
the: %32
symbol: %32
text
,: %32
which: %32
means: %32
ordinary: %32
program: %32
text
,: %32
non
-
conditional: %13
preprocessor: %32
control: %32
lines
,: %32
or: %32
complete: %32
preprocessor: %32
conditional: %32
instructions
.: %13
control
-
line
:: %13
#: %32
define: %32
identifier: %32
token
-
sequence: %13
#: %32
define: %32
identifier
(
identifier
,: %32
.
.
.: %32
,: %32
identifier
): %32
token
-
sequence: %13
#: %32
undef: %32
identifier: %13
#: %32
include: %32
<
filename
>: %13
#: %32
include: %32
"
filename
": %13
#: %32
line: %32
constant: %32
"
filename
": %13
#: %32
line: %32
constant: %13
#: %32
error: %32
token
-
sequenceopt: %13
#: %32
pragma: %32
token
-
sequenceopt: %13
#: %13
preprocessor
-
conditional: %13
preprocessor
-
conditional
:: %13
if
-
line: %32
text: %32
elif
-
parts: %32
else
-
partopt: %32
#
endif: %13
if
-
line
:: %13
#: %32
if: %32
constant
-
expression: %13
#: %32
ifdef: %32
identifier: %13
#: %32
ifndef: %32
identifier: %13
elif
-
parts
:: %13
elif
-
line: %32
text: %13
elif
-
partsopt: %13
elif
-
line
:: %13
#: %32
elif: %32
constant
-
expression: %13
else
-
part
:: %13
else
-
line: %32
text: %13
else
-
line
:: %13
#
else: %13
Appendix: %32
A: %32
-: %32
Reference: %32
Manual: %13
Back: %32
to: %32
Chapter: %32
8: %32
-
-: %32
Index: %32
-
-: %32
Appendix: %32
B: %13
Appendix: %32
B: %32
-: %32
Standard: %32
Library: %13
Back: %32
to: %32
Appendix: %32
A: %32
-
-: %32
Index: %32
-
-: %32
Appendix: %32
C: %13
Appendix: %32
B: %32
-: %32
Standard: %32
Library: %13
This: %32
appendix: %32
is: %32
a: %32
summary: %32
of: %32
the: %32
library: %32
defined: %32
by: %32
the: %32
ANSI: %32
standard
.: %32
The: %32
standard: %32
library: %32
is: %32
not: %32
part: %13
of: %32
the: %32
C: %32
language: %32
proper
,: %32
but: %32
an: %32
environment: %32
that: %32
supports: %32
standard: %32
C: %32
will: %32
provide: %32
the: %32
function: %13
declarations: %32
and: %32
type: %32
and: %32
macro: %32
definitions: %32
of: %32
this: %32
library
.: %32
We: %32
have: %32
omitted: %32
a: %32
few: %32
functions: %32
that: %32
are: %32
of: %13
limited: %32
utility: %32
or: %32
easily: %32
synthesized: %32
from: %32
others
;: %32
we: %32
have: %32
omitted: %32
multi
-
byte: %32
characters
;: %32
and: %32
we: %32
have: %13
omitted: %32
discussion: %32
of: %32
locale: %32
issues
;: %32
that: %32
is
,: %32
properties: %32
that: %32
depend: %32
on: %32
local: %32
language
,: %32
nationality
,: %32
or: %13
culture
.: %13
The: %32
functions
,: %32
types: %32
and: %32
macros: %32
of: %32
the: %32
standard: %32
library: %32
are: %32
declared: %32
in: %32
standard: %32
headers
:: %13
<
assert
.
h
>: %13
<
ctype
.
h
>: %13
<
errno
.
h
>: %13
<
float
.
h
>: %13
<
limits
.
h
>: %13
<
locale
.
h
>: %13
<
math
.
h
>: %13
<
setjmp
.
h
>: %13
<
signal
.
h
>: %13
<
stdarg
.
h
>: %13
<
stddef
.
h
>: %13
<
stdio
.
h
>: %13
<
stdlib
.
h
>: %13
<
string
.
h
>: %13
<
time
.
h
>: %13
A: %32
header: %32
can: %32
be: %32
accessed: %32
by: %13
#
include: %32
<
header
>: %13
Headers: %32
may: %32
be: %32
included: %32
in: %32
any: %32
order: %32
and: %32
any: %32
number: %32
of: %32
times
.: %32
A: %32
header: %32
must: %32
be: %32
included: %32
outside: %32
of: %13
any: %32
external: %32
declaration: %32
or: %32
definition: %32
and: %32
before: %32
any: %32
use: %32
of: %32
anything: %32
it: %32
declares
.: %32
A: %32
header: %32
need: %32
not: %32
be: %32
a: %13
source: %32
file
.: %13
External: %32
identifiers: %32
that: %32
begin: %32
with: %32
an: %32
underscore: %32
are: %32
reserved: %32
for: %32
use: %32
by: %32
the: %32
library
,: %32
as: %32
are: %32
all: %32
other: %13
identifiers: %32
that: %32
begin: %32
with: %32
an: %32
underscore: %32
and: %32
an: %32
upper
-
case: %32
letter: %32
or: %32
another: %32
underscore
.: %13
B
.
1: %32
Input: %32
and: %32
Output
:: %32
<
stdio
.
h
>: %13
The: %32
input: %32
and: %32
output: %32
functions
,: %32
types
,: %32
and: %32
macros: %32
defined: %32
in: %32
<
stdio
.
h
>: %32
represent: %32
nearly: %32
one: %32
third: %32
of: %13
the: %32
library
.: %13
A: %32
stream: %32
is: %32
a: %32
source: %32
or: %32
destination: %32
of: %32
data: %32
that: %32
may: %32
be: %32
associated: %32
with: %32
a: %32
disk: %32
or: %32
other: %32
peripheral
.: %32
The: %13
library: %32
supports: %32
text: %32
streams: %32
and: %32
binary: %32
streams
,: %32
although: %32
on: %32
some: %32
systems
,: %32
notably: %32
UNIX
,: %32
these: %32
are: %13
identical
.: %32
A: %32
text: %32
stream: %32
is: %32
a: %32
sequence: %32
of: %32
lines
;: %32
each: %32
line: %32
has: %32
zero: %32
or: %32
more: %32
characters: %32
and: %32
is: %32
terminated: %32
by: %13
Appendix: %32
B: %32
-: %32
Standard: %32
Library: %13
'
\
n
'
.: %32
An: %32
environment: %32
may: %32
need: %32
to: %32
convert: %32
a: %32
text: %32
stream: %32
to: %32
or: %32
from: %32
some: %32
other: %32
representation: %32
(
such: %32
as: %13
mapping: %32
'
\
n
': %32
to: %32
carriage: %32
return: %32
and: %32
linefeed
)
.: %32
A: %32
binary: %32
stream: %32
is: %32
a: %32
sequence: %32
of: %32
unprocessed: %32
bytes: %32
that: %13
record: %32
internal: %32
data
,: %32
with: %32
the: %32
property: %32
that: %32
if: %32
it: %32
is: %32
written
,: %32
then: %32
read: %32
back: %32
on: %32
the: %32
same: %32
system
,: %32
it: %32
will: %13
compare: %32
equal
.: %13
A: %32
stream: %32
is: %32
connected: %32
to: %32
a: %32
file: %32
or: %32
device: %32
by: %32
opening: %32
it
;: %32
the: %32
connection: %32
is: %32
broken: %32
by: %32
closing: %32
the: %32
stream
.: %13
Opening: %32
a: %32
file: %32
returns: %32
a: %32
pointer: %32
to: %32
an: %32
object: %32
of: %32
type: %32
FILE
,: %32
which: %32
records: %32
whatever: %32
information: %32
is: %13
necessary: %32
to: %32
control: %32
the: %32
stream
.: %32
We: %32
will: %32
use: %32
`
`
file: %32
pointer
'
': %32
and: %32
`
`
stream
'
': %32
interchangeably: %32
when: %32
there: %32
is: %13
no: %32
ambiguity
.: %13
When: %32
a: %32
program: %32
begins: %32
execution
,: %32
the: %32
three: %32
streams: %32
stdin
,: %32
stdout
,: %32
and: %32
stderr: %32
are: %32
already: %32
open
.: %13
B
.
1
.
1: %32
File: %32
Operations: %13
The: %32
following: %32
functions: %32
deal: %32
with: %32
operations: %32
on: %32
files
.: %32
The: %32
type: %32
size
_
t: %32
is: %32
the: %32
unsigned: %32
integral: %32
type: %13
produced: %32
by: %32
the: %32
sizeof: %32
operator
.: %13
FILE: %32
*
fopen
(
const: %32
char: %32
*
filename
,: %32
const: %32
char: %32
*
mode
): %13
fopen: %32
opens: %32
the: %32
named: %32
file
,: %32
and: %32
returns: %32
a: %32
stream
,: %32
or: %32
NULL: %32
if: %32
the: %32
attempt: %32
fails
.: %32
Legal: %32
values: %32
for: %13
mode: %32
include
:: %13
"
r
": %32
open: %32
text: %32
file: %32
for: %32
reading: %13
"
w
": %32
create: %32
text: %32
file: %32
for: %32
writing
;: %32
discard: %32
previous: %32
contents: %32
if: %32
any: %13
"
a
": %32
append
;: %32
open: %32
or: %32
create: %32
text: %32
file: %32
for: %32
writing: %32
at: %32
end: %32
of: %32
file: %13
"
r
+
": %32
open: %32
text: %32
file: %32
for: %32
update: %32
(
i
.
e
.
,: %32
reading: %32
and: %32
writing
): %13
"
w
+
": %32
create: %32
text: %32
file: %32
for: %32
update
,: %32
discard: %32
previous: %32
contents: %32
if: %32
any: %13
"
a
+
": %32
append
;: %32
open: %32
or: %32
create: %32
text: %32
file: %32
for: %32
update
,: %32
writing: %32
at: %32
end: %13
Update: %32
mode: %32
permits: %32
reading: %32
and: %32
writing: %32
the: %32
same: %32
file
;: %32
fflush: %32
or: %32
a: %32
file
-
positioning: %32
function: %13
must: %32
be: %32
called: %32
between: %32
a: %32
read: %32
and: %32
a: %32
write: %32
or: %32
vice: %32
versa
.: %32
If: %32
the: %32
mode: %32
includes: %32
b: %32
after: %32
the: %32
initial: %13
letter
,: %32
as: %32
in: %32
"
rb
": %32
or: %32
"
w
+
b
"
,: %32
that: %32
indicates: %32
a: %32
binary: %32
file
.: %32
Filenames: %32
are: %32
limited: %32
to: %13
FILENAME
_
MAX: %32
characters
.: %32
At: %32
most: %32
FOPEN
_
MAX: %32
files: %32
may: %32
be: %32
open: %32
at: %32
once
.: %13
FILE: %32
*
freopen
(
const: %32
char: %32
*
filename
,: %32
const: %32
char: %32
*
mode
,: %32
FILE: %32
*
stream
): %13
freopen: %32
opens: %32
the: %32
file: %32
with: %32
the: %32
specified: %32
mode: %32
and: %32
associates: %32
the: %32
stream: %32
with: %32
it
.: %32
It: %32
returns: %13
stream
,: %32
or: %32
NULL: %32
if: %32
an: %32
error: %32
occurs
.: %32
freopen: %32
is: %32
normally: %32
used: %32
to: %32
change: %32
the: %32
files: %32
associated: %13
with: %32
stdin
,: %32
stdout
,: %32
or: %32
stderr
.: %13
int: %32
fflush
(
FILE: %32
*
stream
): %13
On: %32
an: %32
output: %32
stream
,: %32
fflush: %32
causes: %32
any: %32
buffered: %32
but: %32
unwritten: %32
data: %32
to: %32
be: %32
written
;: %32
on: %32
an: %32
input: %13
Appendix: %32
B: %32
-: %32
Standard: %32
Library: %13
stream
,: %32
the: %32
effect: %32
is: %32
undefined
.: %32
It: %32
returns: %32
EOF: %32
for: %32
a: %32
write: %32
error
,: %32
and: %32
zero: %32
otherwise
.: %13
fflush
(
NULL
): %32
flushes: %32
all: %32
output: %32
streams
.: %13
int: %32
fclose
(
FILE: %32
*
stream
): %13
fclose: %32
flushes: %32
any: %32
unwritten: %32
data: %32
for: %32
stream
,: %32
discards: %32
any: %32
unread: %32
buffered: %32
input
,: %32
frees: %32
any: %13
automatically: %32
allocated: %32
buffer
,: %32
then: %32
closes: %32
the: %32
stream
.: %32
It: %32
returns: %32
EOF: %32
if: %32
any: %32
errors: %32
occurred
,: %32
and: %13
zero: %32
otherwise
.: %13
int: %32
remove
(
const: %32
char: %32
*
filename
): %13
remove: %32
removes: %32
the: %32
named: %32
file
,: %32
so: %32
that: %32
a: %32
subsequent: %32
attempt: %32
to: %32
open: %32
it: %32
will: %32
fail
.: %32
It: %32
returns: %32
non
-: %13
zero: %32
if: %32
the: %32
attempt: %32
fails
.: %13
int: %32
rename
(
const: %32
char: %32
*
oldname
,: %32
const: %32
char: %32
*
newname
): %13
rename: %32
changes: %32
the: %32
name: %32
of: %32
a: %32
file
;: %32
it: %32
returns: %32
non
-
zero: %32
if: %32
the: %32
attempt: %32
fails
.: %13
FILE: %32
*
tmpfile
(
void
): %13
tmpfile: %32
creates: %32
a: %32
temporary: %32
file: %32
of: %32
mode: %32
"
wb
+
": %32
that: %32
will: %32
be: %32
automatically: %32
removed: %32
when: %13
closed: %32
or: %32
when: %32
the: %32
program: %32
terminates: %32
normally
.: %32
tmpfile: %32
returns: %32
a: %32
stream
,: %32
or: %32
NULL: %32
if: %32
it: %32
could: %13
not: %32
create: %32
the: %32
file
.: %13
char: %32
*
tmpnam
(
char: %32
s
[
L
_
tmpnam
]
): %13
tmpnam
(
NULL
): %32
creates: %32
a: %32
string: %32
that: %32
is: %32
not: %32
the: %32
name: %32
of: %32
an: %32
existing: %32
file
,: %32
and: %32
returns: %32
a: %32
pointer: %32
to: %13
an: %32
internal: %32
static: %32
array
.: %32
tmpnam
(
s
): %32
stores: %32
the: %32
string: %32
in: %32
s: %32
as: %32
well: %32
as: %32
returning: %32
it: %32
as: %32
the: %32
function: %13
value
;: %32
s: %32
must: %32
have: %32
room: %32
for: %32
at: %32
least: %32
L
_
tmpnam: %32
characters
.: %32
tmpnam: %32
generates: %32
a: %32
different: %32
name: %13
each: %32
time: %32
it: %32
is: %32
called
;: %32
at: %32
most: %32
TMP
_
MAX: %32
different: %32
names: %32
are: %32
guaranteed: %32
during: %32
execution: %32
of: %32
the: %13
program
.: %32
Note: %32
that: %32
tmpnam: %32
creates: %32
a: %32
name
,: %32
not: %32
a: %32
file
.: %13
int: %32
setvbuf
(
FILE: %32
*
stream
,: %32
char: %32
*
buf
,: %32
int: %32
mode
,: %32
size
_
t: %32
size
): %13
setvbuf: %32
controls: %32
buffering: %32
for: %32
the: %32
stream
;: %32
it: %32
must: %32
be: %32
called: %32
before: %32
reading
,: %32
writing: %32
or: %32
any: %32
other: %13
operation
.: %32
A: %32
mode: %32
of: %32
_
IOFBF: %32
causes: %32
full: %32
buffering
,: %32
_
IOLBF: %32
line: %32
buffering: %32
of: %32
text: %32
files
,: %32
and: %13
_
IONBF: %32
no: %32
buffering
.: %32
If: %32
buf: %32
is: %32
not: %32
NULL
,: %32
it: %32
will: %32
be: %32
used: %32
as: %32
the: %32
buffer
,: %32
otherwise: %32
a: %32
buffer: %32
will: %32
be: %13
allocated
.: %32
size: %32
determines: %32
the: %32
buffer: %32
size
.: %32
setvbuf: %32
returns: %32
non
-
zero: %32
for: %32
any: %32
error
.: %13
void: %32
setbuf
(
FILE: %32
*
stream
,: %32
char: %32
*
buf
): %13
If: %32
buf: %32
is: %32
NULL
,: %32
buffering: %32
is: %32
turned: %32
off: %32
for: %32
the: %32
stream
.: %32
Otherwise
,: %32
setbuf: %32
is: %32
equivalent: %32
to: %13
(
void
): %32
setvbuf
(
stream
,: %32
buf
,: %32
_
IOFBF
,: %32
BUFSIZ
)
.: %13
B
.
1
.
2: %32
Formatted: %32
Output: %13
The: %32
printf: %32
functions: %32
provide: %32
formatted: %32
output: %32
conversion
.: %13
Appendix: %32
B: %32
-: %32
Standard: %32
Library: %13
int: %32
fprintf
(
FILE: %32
*
stream
,: %32
const: %32
char: %32
*
format
,: %32
.
.
.
): %13
fprintf: %32
converts: %32
and: %32
writes: %32
output: %32
to: %32
stream: %32
under: %32
the: %32
control: %32
of: %32
format
.: %32
The: %32
return: %32
value: %32
is: %32
the: %13
number: %32
of: %32
characters: %32
written
,: %32
or: %32
negative: %32
if: %32
an: %32
error: %32
occurred
.: %13
The: %32
format: %32
string: %32
contains: %32
two: %32
types: %32
of: %32
objects
:: %32
ordinary: %32
characters
,: %32
which: %32
are: %32
copied: %32
to: %32
the: %32
output: %13
stream
,: %32
and: %32
conversion: %32
specifications
,: %32
each: %32
of: %32
which: %32
causes: %32
conversion: %32
and: %32
printing: %32
of: %32
the: %32
next: %13
successive: %32
argument: %32
to: %32
fprintf
.: %32
Each: %32
conversion: %32
specification: %32
begins: %32
with: %32
the: %32
character: %32
%: %32
and: %32
ends: %13
with: %32
a: %32
conversion: %32
character
.: %32
Between: %32
the: %32
%: %32
and: %32
the: %32
conversion: %32
character: %32
there: %32
may: %32
be
,: %32
in: %32
order
:: %13
q: %13
q: %13
q: %13
q: %13
q: %13
Flags: %32
(
in: %32
any: %32
order
)
,: %32
which: %32
modify: %32
the: %32
specification
:: %13
r: %32
-
,: %32
which: %32
specifies: %32
left: %32
adjustment: %32
of: %32
the: %32
converted: %32
argument: %32
in: %32
its: %32
field
.: %13
r: %32
+
,: %32
which: %32
specifies: %32
that: %32
the: %32
number: %32
will: %32
always: %32
be: %32
printed: %32
with: %32
a: %32
sign
.: %13
r: %32
space
:: %32
if: %32
the: %32
first: %32
character: %32
is: %32
not: %32
a: %32
sign
,: %32
a: %32
space: %32
will: %32
be: %32
prefixed
.: %13
r: %32
0
:: %32
for: %32
numeric: %32
conversions
,: %32
specifies: %32
padding: %32
to: %32
the: %32
field: %32
width: %32
with: %32
leading: %32
zeros
.: %13
r: %32
#
,: %32
which: %32
specifies: %32
an: %32
alternate: %32
output: %32
form
.: %32
For: %32
o
,: %32
the: %32
first: %32
digit: %32
will: %32
become: %32
zero
.: %32
For: %32
x: %32
or: %13
X
,: %32
0
x: %32
or: %32
0
X: %32
will: %32
be: %32
prefixed: %32
to: %32
a: %32
non
-
zero: %32
result
.: %32
For: %32
e
,: %32
E
,: %32
f
,: %32
g
,: %32
and: %32
G
,: %32
the: %32
output: %32
will: %13
always: %32
have: %32
a: %32
decimal: %32
point
;: %32
for: %32
g: %32
and: %32
G
,: %32
trailing: %32
zeros: %32
will: %32
not: %32
be: %32
removed
.: %13
A: %32
number: %32
specifying: %32
a: %32
minimum: %32
field: %32
width
.: %32
The: %32
converted: %32
argument: %32
will: %32
be: %32
printed: %32
in: %32
a: %32
field: %32
at: %13
least: %32
this: %32
wide
,: %32
and: %32
wider: %32
if: %32
necessary
.: %32
If: %32
the: %32
converted: %32
argument: %32
has: %32
fewer: %32
characters: %32
than: %32
the: %13
field: %32
width: %32
it: %32
will: %32
be: %32
padded: %32
on: %32
the: %32
left: %32
(
or: %32
right
,: %32
if: %32
left: %32
adjustment: %32
has: %32
been: %32
requested
): %32
to: %32
make: %32
up: %13
the: %32
field: %32
width
.: %32
The: %32
padding: %32
character: %32
is: %32
normally: %32
space
,: %32
but: %32
is: %32
0: %32
if: %32
the: %32
zero: %32
padding: %32
flag: %32
is: %13
present
.: %13
A: %32
period
,: %32
which: %32
separates: %32
the: %32
field: %32
width: %32
from: %32
the: %32
precision
.: %13
A: %32
number
,: %32
the: %32
precision
,: %32
that: %32
specifies: %32
the: %32
maximum: %32
number: %32
of: %32
characters: %32
to: %32
be: %32
printed: %32
from: %32
a: %13
string
,: %32
or: %32
the: %32
number: %32
of: %32
digits: %32
to: %32
be: %32
printed: %32
after: %32
the: %32
decimal: %32
point: %32
for: %32
e
,: %32
E
,: %32
or: %32
f: %32
conversions
,: %32
or: %13
the: %32
number: %32
of: %32
significant: %32
digits: %32
for: %32
g: %32
or: %32
G: %32
conversion
,: %32
or: %32
the: %32
number: %32
of: %32
digits: %32
to: %32
be: %32
printed: %32
for: %32
an: %13
integer: %32
(
leading: %32
0
s: %32
will: %32
be: %32
added: %32
to: %32
make: %32
up: %32
the: %32
necessary: %32
width
)
.: %13
A: %32
length: %32
modifier: %32
h
,: %32
l: %32
(
letter: %32
ell
)
,: %32
or: %32
L
.: %32
`
`
h
'
': %32
indicates: %32
that: %32
the: %32
corresponding: %32
argument: %32
is: %32
to: %32
be: %13
printed: %32
as: %32
a: %32
short: %32
or: %32
unsigned: %32
short
;: %32
`
`
l
'
': %32
indicates: %32
that: %32
the: %32
argument: %32
is: %32
a: %32
long: %32
or: %13
unsigned: %32
long
,: %32
`
`
L
'
': %32
indicates: %32
that: %32
the: %32
argument: %32
is: %32
a: %32
long: %32
double
.: %13
Width: %32
or: %32
precision: %32
or: %32
both: %32
may: %32
be: %32
specified: %32
as: %32
*
,: %32
in: %32
which: %32
case: %32
the: %32
value: %32
is: %32
computed: %32
by: %32
converting: %32
the: %13
next: %32
argument
(
s
)
,: %32
which: %32
must: %32
be: %32
int
.: %13
The: %32
conversion: %32
characters: %32
and: %32
their: %32
meanings: %32
are: %32
shown: %32
in: %32
Table: %32
B
.
1
.: %32
If: %32
the: %32
character: %32
after: %32
the: %32
%: %32
is: %32
not: %32
a: %13
conversion: %32
character
,: %32
the: %32
behavior: %32
is: %32
undefined
.: %13
Table: %32
B
.
1: %32
Printf: %32
Conversions: %13
Character: %13
Argument: %32
type
;: %32
Printed: %32
As: %13
Appendix: %32
B: %32
-: %32
Standard: %32
Library: %13
d
,
i: %32
int
;: %32
signed: %32
decimal: %32
notation
.: %13
o: %32
int
;: %32
unsigned: %32
octal: %32
notation: %32
(
without: %32
a: %32
leading: %32
zero
)
.: %13
x
,
X: %32
unsigned: %32
int
;: %32
unsigned: %32
hexadecimal: %32
notation: %32
(
without: %32
a: %32
leading: %32
0
x: %32
or: %32
0
X
)
,: %32
using: %13
: %32%32%32
abcdef: %32
for: %32
0
x: %32
or: %32
ABCDEF: %32
for: %32
0
X
.: %13
u: %32
int
;: %32
unsigned: %32
decimal: %32
notation
.: %13
c: %32
int
;: %32
single: %32
character
,: %32
after: %32
conversion: %32
to: %32
unsigned: %32
char: %13
s: %32
char: %32
*
;: %32
characters: %32
from: %32
the: %32
string: %32
are: %32
printed: %32
until: %32
a: %32
'
\
0
': %32
is: %32
reached: %32
or: %32
until: %32
the: %32
number: %13
: %32
of: %32
characters: %32
indicated: %32
by: %32
the: %32
precision: %32
have: %32
been: %32
printed
.: %13
f: %32
double
;: %32
decimal: %32
notation: %32
of: %32
the: %32
form: %32
[
-
]
mmm
.
ddd
,: %32
where: %32
the: %32
number: %32
of: %32
d
'
s: %32
is: %32
given: %32
by: %13
: %32
the: %32
precision
.: %32
The: %32
default: %32
precision: %32
is: %32
6
;: %32
a: %32
precision: %32
of: %32
0: %32
suppresses: %32
the: %32
decimal: %32
point
.: %13
e
,
E: %32
double
;: %32
decimal: %32
notation: %32
of: %32
the: %32
form: %32
[
-
]
m
.
dddddde
+
/
-
xx: %32
or: %32
[
-
]
m
.
ddddddE
+
/
-
xx
,: %13
: %32%32%32
where: %32
the: %32
number: %32
of: %32
d
'
s: %32
is: %32
specified: %32
by: %32
the: %32
precision
.: %32
The: %32
default: %32
precision: %32
is: %32
6
;: %32
a: %32
precision: %13
: %32%32
of: %32
0: %32
suppresses: %32
the: %32
decimal: %32
point
.: %13
g
,
G: %32
double
;: %32
%:
e: %32
or: %32
%:
E: %32
is: %32
used: %32
if: %32
the: %32
exponent: %32
is: %32
less: %32
than: %32
-
4: %32
or: %32
greater: %32
than: %32
or: %32
equal: %32
to: %32
the: %13
: %32%32%32
precision
;: %32
otherwise: %32
%:
f: %32
is: %32
used
.: %32
Trailing: %32
zeros: %32
and: %32
a: %32
trailing: %32
decimal: %32
point: %32
are: %32
not: %32
printed
.: %13
p: %32
void: %32
*
;: %32
print: %32
as: %32
a: %32
pointer: %32
(
implementation
-
dependent: %32
representation
)
.: %13
n: %32
int: %32
*
;: %32
the: %32
number: %32
of: %32
characters: %32
written: %32
so: %32
far: %32
by: %32
this: %32
call: %32
to: %32
printf: %32
is: %32
written: %32
into: %32
the: %13
: %32
argument
.: %32
No: %32
argument: %32
is: %32
converted
.: %13
%: %32
no: %32
argument: %32
is: %32
converted
;: %32
print: %32
a: %32
%: %13
int: %32
printf
(
const: %32
char: %32
*
format
,: %32
.
.
.
): %13
printf
(
.
.
.
): %32
is: %32
equivalent: %32
to: %32
fprintf
(
stdout
,: %32
.
.
.
)
.: %13
int: %32
sprintf
(
char: %32
*
s
,: %32
const: %32
char: %32
*
format
,: %32
.
.
.
): %13
sprintf: %32
is: %32
the: %32
same: %32
as: %32
printf: %32
except: %32
that: %32
the: %32
output: %32
is: %32
written: %32
into: %32
the: %32
string: %32
s
,: %32
terminated: %13
with: %32
'
\
0
'
.: %32
s: %32
must: %32
be: %32
big: %32
enough: %32
to: %32
hold: %32
the: %32
result
.: %32
The: %32
return: %32
count: %32
does: %32
not: %32
include: %32
the: %32
'
\
0
'
.: %13
int: %32
vprintf
(
const: %32
char: %32
*
format
,: %32
va
_
list: %32
arg
): %13
int: %32
vfprintf
(
FILE: %32
*
stream
,: %32
const: %32
char: %32
*
format
,: %32
va
_
list: %32
arg
): %13
int: %32
vsprintf
(
char: %32
*
s
,: %32
const: %32
char: %32
*
format
,: %32
va
_
list: %32
arg
): %13
The: %32
functions: %32
vprintf
,: %32
vfprintf
,: %32
and: %32
vsprintf: %32
are: %32
equivalent: %32
to: %32
the: %32
corresponding: %13
printf: %32
functions
,: %32
except: %32
that: %32
the: %32
variable: %32
argument: %32
list: %32
is: %32
replaced: %32
by: %32
arg
,: %32
which: %32
has: %32
been: %13
initialized: %32
by: %32
the: %32
va
_
start: %32
macro: %32
and: %32
perhaps: %32
va
_
arg: %32
calls
.: %32
See: %32
the: %32
discussion: %32
of: %13
<
stdarg
.
h
>: %32
in: %32
Section: %32
B
.
7
.: %13
B
.
1
.
3: %32
Formatted: %32
Input: %13
Appendix: %32
B: %32
-: %32
Standard: %32
Library: %13
The: %32
scanf: %32
function: %32
deals: %32
with: %32
formatted: %32
input: %32
conversion
.: %13
int: %32
fscanf
(
FILE: %32
*
stream
,: %32
const: %32
char: %32
*
format
,: %32
.
.
.
): %13
fscanf: %32
reads: %32
from: %32
stream: %32
under: %32
control: %32
of: %32
format
,: %32
and: %32
assigns: %32
converted: %32
values: %32
through: %13
subsequent: %32
arguments
,: %32
each: %32
of: %32
which: %32
must: %32
be: %32
a: %32
pointer
.: %32
It: %32
returns: %32
when: %32
format: %32
is: %32
exhausted
.: %32
fscanf: %13
returns: %32
EOF: %32
if: %32
end: %32
of: %32
file: %32
or: %32
an: %32
error: %32
occurs: %32
before: %32
any: %32
conversion
;: %32
otherwise: %32
it: %32
returns: %32
the: %32
number: %32
of: %13
input: %32
items: %32
converted: %32
and: %32
assigned
.: %13
The: %32
format: %32
string: %32
usually: %32
contains: %32
conversion: %32
specifications
,: %32
which: %32
are: %32
used: %32
to: %32
direct: %32
interpretation: %32
of: %13
input
.: %32
The: %32
format: %32
string: %32
may: %32
contain
:: %13
q: %13
q: %13
q: %13
Blanks: %32
or: %32
tabs
,: %32
which: %32
are: %32
not: %32
ignored
.: %13
Ordinary: %32
characters: %32
(
not: %32
%:
)
,: %32
which: %32
are: %32
expected: %32
to: %32
match: %32
the: %32
next: %32
non
-
white: %32
space: %32
character: %32
of: %13
the: %32
input: %32
stream
.: %13
Conversion: %32
specifications
,: %32
consisting: %32
of: %32
a: %32
%:
,: %32
an: %32
optional: %32
assignment: %32
suppression: %32
character: %32
*
,: %32
an: %13
optional: %32
number: %32
specifying: %32
a: %32
maximum: %32
field: %32
width
,: %32
an: %32
optional: %32
h
,: %32
l
,: %32
or: %32
L: %32
indicating: %32
the: %32
width: %32
of: %13
the: %32
target
,: %32
and: %32
a: %32
conversion: %32
character
.: %13
A: %32
conversion: %32
specification: %32
determines: %32
the: %32
conversion: %32
of: %32
the: %32
next: %32
input: %32
field
.: %32
Normally: %32
the: %32
result: %32
is: %13
placed: %32
in: %32
the: %32
variable: %32
pointed: %32
to: %32
by: %32
the: %32
corresponding: %32
argument
.: %32
If: %32
assignment: %32
suppression: %32
is: %32
indicated: %13
by: %32
*
,: %32
as: %32
in: %32
%:
*
s
,: %32
however
,: %32
the: %32
input: %32
field: %32
is: %32
simply: %32
skipped
;: %32
no: %32
assignment: %32
is: %32
made
.: %32
An: %32
input: %32
field: %32
is: %13
defined: %32
as: %32
a: %32
string: %32
of: %32
non
-
white: %32
space: %32
characters
;: %32
it: %32
extends: %32
either: %32
to: %32
the: %32
next: %32
white: %32
space: %32
character: %32
or: %13
until: %32
the: %32
field: %32
width
,: %32
if: %32
specified
,: %32
is: %32
exhausted
.: %32
This: %32
implies: %32
that: %32
scanf: %32
will: %32
read: %32
across: %32
line: %32
boundaries: %13
to: %32
find: %32
its: %32
input
,: %32
since: %32
newlines: %32
are: %32
white: %32
space
.: %32
(
White: %32
space: %32
characters: %32
are: %32
blank
,: %32
tab
,: %32
newline
,: %32
carriage: %13
return
,: %32
vertical: %32
tab
,: %32
and: %32
formfeed
.
): %13
The: %32
conversion: %32
character: %32
indicates: %32
the: %32
interpretation: %32
of: %32
the: %32
input: %32
field
.: %32
The: %32
corresponding: %32
argument: %32
must: %13
be: %32
a: %32
pointer
.: %32
The: %32
legal: %32
conversion: %32
characters: %32
are: %32
shown: %32
in: %32
Table: %32
B
.
2
.: %13
The: %32
conversion: %32
characters: %32
d
,: %32
i
,: %32
n
,: %32
o
,: %32
u
,: %32
and: %32
x: %32
may: %32
be: %32
preceded: %32
by: %32
h: %32
if: %32
the: %32
argument: %32
is: %32
a: %32
pointer: %32
to: %13
short: %32
rather: %32
than: %32
int
,: %32
or: %32
by: %32
l: %32
(
letter: %32
ell
): %32
if: %32
the: %32
argument: %32
is: %32
a: %32
pointer: %32
to: %32
long
.: %32
The: %32
conversion: %32
characters: %13
e
,: %32
f
,: %32
and: %32
g: %32
may: %32
be: %32
preceded: %32
by: %32
l: %32
if: %32
a: %32
pointer: %32
to: %32
double: %32
rather: %32
than: %32
float: %32
is: %32
in: %32
the: %32
argument: %32
list
,: %32
and: %13
by: %32
L: %32
if: %32
a: %32
pointer: %32
to: %32
a: %32
long: %32
double
.: %13
Table: %32
B
.
2: %32
Scanf: %32
Conversions: %13
Character: %13
Input: %32
Data
;: %32
Argument: %32
type: %13
d: %32
decimal: %32
integer
;: %32
int
*: %13
i: %32
integer
;: %32
int
*
.: %32
The: %32
integer: %32
may: %32
be: %32
in: %32
octal: %32
(
leading: %32
0
): %32
or: %32
hexadecimal: %32
(
leading: %32
0
x: %32
or: %32
0
X
)
.: %13
Appendix: %32
B: %32
-: %32
Standard: %32
Library: %13
o: %32
octal: %32
integer: %32
(
with: %32
or: %32
without: %32
leading: %32
zero
)
;: %32
int: %32
*
.: %13
u: %32
unsigned: %32
decimal: %32
integer
;: %32
unsigned: %32
int: %32
*
.: %13
x: %32
hexadecimal: %32
integer: %32
(
with: %32
or: %32
without: %32
leading: %32
0
x: %32
or: %32
0
X
)
;: %32
int
*
.: %13
c: %32
characters
;: %32
char
*
.: %32
The: %32
next: %32
input: %32
characters: %32
are: %32
placed: %32
in: %32
the: %32
indicated: %32
array
,: %32
up: %32
to: %32
the: %13
: %32
number: %32
given: %32
by: %32
the: %32
width: %32
field
;: %32
the: %32
default: %32
is: %32
1
.: %32
No: %32
'
\
0
': %32
is: %32
added
.: %32
The: %32
normal: %32
skip: %32
over: %13
white: %32
space: %32
characters: %32
is: %32
suppressed: %32
in: %32
this: %32
case
;: %32
to: %32
read: %32
the: %32
next: %32
non
-
white: %32
space: %13
character
,: %32
use: %32
%:
1
s
.: %13
s: %32
string: %32
of: %32
non
-
white: %32
space: %32
characters: %32
(
not: %32
quoted
)
;: %32
char: %32
*
,: %32
pointing: %32
to: %32
an: %32
array: %32
of: %13
: %32
characters: %32
large: %32
enough: %32
to: %32
hold: %32
the: %32
string: %32
and: %32
a: %32
terminating: %32
'
\
0
': %32
that: %32
will: %32
be: %32
added
.: %13
e
,
f
,
g: %32
floating
-
point: %32
number
;: %32
float: %32
*
.: %32
The: %32
input: %32
format: %32
for: %32
float
'
s: %32
is: %32
an: %32
optional: %32
sign
,: %32
a: %13
: %32%32%32%32%32
string: %32
of: %32
numbers: %32
possibly: %32
containing: %32
a: %32
decimal: %32
point
,: %32
and: %32
an: %32
optional: %32
exponent: %32
field: %13
: %32%32%32%32
containing: %32
an: %32
E: %32
or: %32
e: %32
followed: %32
by: %32
a: %32
possibly: %32
signed: %32
integer
.: %13
p: %32
pointer: %32
value: %32
as: %32
printed: %32
by: %32
printf
(
"
%:
p
"
)
;
,: %32
void: %32
*
.: %13
n: %32
writes: %32
into: %32
the: %32
argument: %32
the: %32
number: %32
of: %32
characters: %32
read: %32
so: %32
far: %32
by: %32
this: %32
call
;: %32
int: %32
*
.: %32
No: %32
input: %13
: %32
is: %32
read
.: %32
The: %32
converted: %32
item: %32
count: %32
is: %32
not: %32
incremented
.: %13
[
.
.
.
]: %32
matches: %32
the: %32
longest: %32
non
-
empty: %32
string: %32
of: %32
input: %32
characters: %32
from: %32
the: %32
set: %32
between: %32
brackets
;: %13
: %32%32%32%32%32
char: %32
*
.: %32
A: %32
'
\
0
': %32
is: %32
added
.: %32
[
]
.
.
.
]: %32
includes: %32
]: %32
in: %32
the: %32
set
.: %13
[
^
.
.
.
]: %32
matches: %32
the: %32
longest: %32
non
-
empty: %32
string: %32
of: %32
input: %32
characters: %32
not: %32
from: %32
the: %32
set: %32
between: %32
brackets
;: %13
: %32%32%32%32%32%32
char: %32
*
.: %32
A: %32
'
\
0
': %32
is: %32
added
.: %32
[
^
]
.
.
.
]: %32
includes: %32
]: %32
in: %32
the: %32
set
.: %13
%: %32
literal: %32
%:
;: %32
no: %32
assignment: %32
is: %32
made
.: %13
int: %32
scanf
(
const: %32
char: %32
*
format
,: %32
.
.
.
): %13
scanf
(
.
.
.
): %32
is: %32
identical: %32
to: %32
fscanf
(
stdin
,: %32
.
.
.
)
.: %13
int: %32
sscanf
(
const: %32
char: %32
*
s
,: %32
const: %32
char: %32
*
format
,: %32
.
.
.
): %13
sscanf
(
s
,: %32
.
.
.
): %32
is: %32
equivalent: %32
to: %32
scanf
(
.
.
.
): %32
except: %32
that: %32
the: %32
input: %32
characters: %32
are: %32
taken: %13
from: %32
the: %32
string: %32
s
.: %13
B
.
1
.
4: %32
Character: %32
Input: %32
and: %32
Output: %32
Functions: %13
int: %32
fgetc
(
FILE: %32
*
stream
): %13
fgetc: %32
returns: %32
the: %32
next: %32
character: %32
of: %32
stream: %32
as: %32
an: %32
unsigned: %32
char: %32
(
converted: %32
to: %32
an: %32
int
)
,: %32
or: %13
EOF: %32
if: %32
end: %32
of: %32
file: %32
or: %32
error: %32
occurs
.: %13
char: %32
*
fgets
(
char: %32
*
s
,: %32
int: %32
n
,: %32
FILE: %32
*
stream
): %13
fgets: %32
reads: %32
at: %32
most: %32
the: %32
next: %32
n
-
1: %32
characters: %32
into: %32
the: %32
array: %32
s
,: %32
stopping: %32
if: %32
a: %32
newline: %32
is: %13
encountered
;: %32
the: %32
newline: %32
is: %32
included: %32
in: %32
the: %32
array
,: %32
which: %32
is: %32
terminated: %32
by: %32
'
\
0
'
.: %32
fgets: %32
returns: %32
s
,: %13
or: %32
NULL: %32
if: %32
end: %32
of: %32
file: %32
or: %32
error: %32
occurs
.: %13
Appendix: %32
B: %32
-: %32
Standard: %32
Library: %13
int: %32
fputc
(
int: %32
c
,: %32
FILE: %32
*
stream
): %13
fputc: %32
writes: %32
the: %32
character: %32
c: %32
(
converted: %32
to: %32
an: %32
unsigend: %32
char
): %32
on: %32
stream
.: %32
It: %32
returns: %32
the: %13
character: %32
written
,: %32
or: %32
EOF: %32
for: %32
error
.: %13
int: %32
fputs
(
const: %32
char: %32
*
s
,: %32
FILE: %32
*
stream
): %13
fputs: %32
writes: %32
the: %32
string: %32
s: %32
(
which: %32
need: %32
not: %32
contain: %32
\
n
): %32
on: %32
stream
;: %32
it: %32
returns: %32
non
-
negative
,: %32
or: %13
EOF: %32
for: %32
an: %32
error
.: %13
int: %32
getc
(
FILE: %32
*
stream
): %13
getc: %32
is: %32
equivalent: %32
to: %32
fgetc: %32
except: %32
that: %32
if: %32
it: %32
is: %32
a: %32
macro
,: %32
it: %32
may: %32
evaluate: %32
stream: %32
more: %32
than: %13
once
.: %13
int: %32
getchar
(
void
): %13
getchar: %32
is: %32
equivalent: %32
to: %32
getc
(
stdin
)
.: %13
char: %32
*
gets
(
char: %32
*
s
): %13
gets: %32
reads: %32
the: %32
next: %32
input: %32
line: %32
into: %32
the: %32
array: %32
s
;: %32
it: %32
replaces: %32
the: %32
terminating: %32
newline: %32
with: %32
'
\
0
'
.: %32
It: %13
returns: %32
s
,: %32
or: %32
NULL: %32
if: %32
end: %32
of: %32
file: %32
or: %32
error: %32
occurs
.: %13
int: %32
putc
(
int: %32
c
,: %32
FILE: %32
*
stream
): %13
putc: %32
is: %32
equivalent: %32
to: %32
fputc: %32
except: %32
that: %32
if: %32
it: %32
is: %32
a: %32
macro
,: %32
it: %32
may: %32
evaluate: %32
stream: %32
more: %32
than: %13
once
.: %13
int: %32
putchar
(
int: %32
c
): %13
putchar
(
c
): %32
is: %32
equivalent: %32
to: %32
putc
(
c
,
stdout
)
.: %13
int: %32
puts
(
const: %32
char: %32
*
s
): %13
puts: %32
writes: %32
the: %32
string: %32
s: %32
and: %32
a: %32
newline: %32
to: %32
stdout
.: %32
It: %32
returns: %32
EOF: %32
if: %32
an: %32
error: %32
occurs
,: %32
non
-: %13
negative: %32
otherwise
.: %13
int: %32
ungetc
(
int: %32
c
,: %32
FILE: %32
*
stream
): %13
ungetc: %32
pushes: %32
c: %32
(
converted: %32
to: %32
an: %32
unsigned: %32
char
): %32
back: %32
onto: %32
stream
,: %32
where: %32
it: %32
will: %32
be: %13
returned: %32
on: %32
the: %32
next: %32
read
.: %32
Only: %32
one: %32
character: %32
of: %32
pushback: %32
per: %32
stream: %32
is: %32
guaranteed
.: %32
EOF: %32
may: %32
not: %13
be: %32
pushed: %32
back
.: %32
ungetc: %32
returns: %32
the: %32
character: %32
pushed: %32
back
,: %32
or: %32
EOF: %32
for: %32
error
.: %13
B
.
1
.
5: %32
Direct: %32
Input: %32
and: %32
Output: %32
Functions: %13
size
_
t: %32
fread
(
void: %32
*
ptr
,: %32
size
_
t: %32
size
,: %32
size
_
t: %32
nobj
,: %32
FILE: %32
*
stream
): %13
fread: %32
reads: %32
from: %32
stream: %32
into: %32
the: %32
array: %32
ptr: %32
at: %32
most: %32
nobj: %32
objects: %32
of: %32
size: %32
size
.: %32
fread: %13
returns: %32
the: %32
number: %32
of: %32
objects: %32
read
;: %32
this: %32
may: %32
be: %32
less: %32
than: %32
the: %32
number: %32
requested
.: %32
feof: %32
and: %13
ferror: %32
must: %32
be: %32
used: %32
to: %32
determine: %32
status
.: %13
Appendix: %32
B: %32
-: %32
Standard: %32
Library: %13
size
_
t: %32
fwrite
(
const: %32
void: %32
*
ptr
,: %32
size
_
t: %32
size
,: %32
size
_
t: %32
nobj
,: %32
FILE: %32
*
stream
): %13
fwrite: %32
writes
,: %32
from: %32
the: %32
array: %32
ptr
,: %32
nobj: %32
objects: %32
of: %32
size: %32
size: %32
on: %32
stream
.: %32
It: %32
returns: %32
the: %13
number: %32
of: %32
objects: %32
written
,: %32
which: %32
is: %32
less: %32
than: %32
nobj: %32
on: %32
error
.: %13
B
.
1
.
6: %32
File: %32
Positioning: %32
Functions: %13
int: %32
fseek
(
FILE: %32
*
stream
,: %32
long: %32
offset
,: %32
int: %32
origin
): %13
fseek: %32
sets: %32
the: %32
file: %32
position: %32
for: %32
stream
;: %32
a: %32
subsequent: %32
read: %32
or: %32
write: %32
will: %32
access: %32
data: %32
beginning: %32
at: %13
the: %32
new: %32
position
.: %32
For: %32
a: %32
binary: %32
file
,: %32
the: %32
position: %32
is: %32
set: %32
to: %32
offset: %32
characters: %32
from: %32
origin
,: %32
which: %13
may: %32
be: %32
SEEK
_
SET: %32
(
beginning
)
,: %32
SEEK
_
CUR: %32
(
current: %32
position
)
,: %32
or: %32
SEEK
_
END: %32
(
end: %32
of: %32
file
)
.: %32
For: %32
a: %13
text: %32
stream
,: %32
offset: %32
must: %32
be: %32
zero
,: %32
or: %32
a: %32
value: %32
returned: %32
by: %32
ftell: %32
(
in: %32
which: %32
case: %32
origin: %32
must: %13
be: %32
SEEK
_
SET
)
.: %32
fseek: %32
returns: %32
non
-
zero: %32
on: %32
error
.: %13
long: %32
ftell
(
FILE: %32
*
stream
): %13
ftell: %32
returns: %32
the: %32
current: %32
file: %32
position: %32
for: %32
stream
,: %32
or: %32
-
1: %32
on: %32
error
.: %13
void: %32
rewind
(
FILE: %32
*
stream
): %13
rewind
(
fp
): %32
is: %32
equivalent: %32
to: %32
fseek
(
fp
,: %32
0
L
,: %32
SEEK
_
SET
)
;: %32
clearerr
(
fp
)
.: %13
int: %32
fgetpos
(
FILE: %32
*
stream
,: %32
fpos
_
t: %32
*
ptr
): %13
fgetpos: %32
records: %32
the: %32
current: %32
position: %32
in: %32
stream: %32
in: %32
*
ptr
,: %32
for: %32
subsequent: %32
use: %32
by: %32
fsetpos
.: %13
The: %32
type: %32
fpos
_
t: %32
is: %32
suitable: %32
for: %32
recording: %32
such: %32
values
.: %32
fgetpos: %32
returns: %32
non
-
zero: %32
on: %32
error
.: %13
int: %32
fsetpos
(
FILE: %32
*
stream
,: %32
const: %32
fpos
_
t: %32
*
ptr
): %13
fsetpos: %32
positions: %32
stream: %32
at: %32
the: %32
position: %32
recorded: %32
by: %32
fgetpos: %32
in: %32
*
ptr
.: %32
fsetpos: %32
returns: %13
non
-
zero: %32
on: %32
error
.: %13
B
.
1
.
7: %32
Error: %32
Functions: %13
Many: %32
of: %32
the: %32
functions: %32
in: %32
the: %32
library: %32
set: %32
status: %32
indicators: %32
when: %32
error: %32
or: %32
end: %32
of: %32
file: %32
occur
.: %32
These: %32
indicators: %13
may: %32
be: %32
set: %32
and: %32
tested: %32
explicitly
.: %32
In: %32
addition
,: %32
the: %32
integer: %32
expression: %32
errno: %32
(
declared: %32
in: %32
<
errno
.
h
>
): %13
may: %32
contain: %32
an: %32
error: %32
number: %32
that: %32
gives: %32
further: %32
information: %32
about: %32
the: %32
most: %32
recent: %32
error
.: %13
void: %32
clearerr
(
FILE: %32
*
stream
): %13
clearerr: %32
clears: %32
the: %32
end: %32
of: %32
file: %32
and: %32
error: %32
indicators: %32
for: %32
stream
.: %13
int: %32
feof
(
FILE: %32
*
stream
): %13
feof: %32
returns: %32
non
-
zero: %32
if: %32
the: %32
end: %32
of: %32
file: %32
indicator: %32
for: %32
stream: %32
is: %32
set
.: %13
int: %32
ferror
(
FILE: %32
*
stream
): %13
Appendix: %32
B: %32
-: %32
Standard: %32
Library: %13
ferror: %32
returns: %32
non
-
zero: %32
if: %32
the: %32
error: %32
indicator: %32
for: %32
stream: %32
is: %32
set
.: %13
void: %32
perror
(
const: %32
char: %32
*
s
): %13
perror
(
s
): %32
prints: %32
s: %32
and: %32
an: %32
implementation
-
defined: %32
error: %32
message: %32
corresponding: %32
to: %32
the: %32
integer: %13
in: %32
errno
,: %32
as: %32
if: %32
by: %13
fprintf
(
stderr
,: %32
"
%:
s
:: %32
%:
s
\
n
"
,: %32
s
,: %32
"
error: %32
message
"
)
;: %13
See: %32
strerror: %32
in: %32
Section: %32
B
.
3
.: %13
B
.
2: %32
Character: %32
Class: %32
Tests
:: %32
<
ctype
.
h
>: %13
The: %32
header: %32
<
ctype
.
h
>: %32
declares: %32
functions: %32
for: %32
testing: %32
characters
.: %32
For: %32
each: %32
function
,: %32
the: %32
argument: %32
list: %32
is: %13
an: %32
int
,: %32
whose: %32
value: %32
must: %32
be: %32
EOF: %32
or: %32
representable: %32
as: %32
an: %32
unsigned: %32
char
,: %32
and: %32
the: %32
return: %32
value: %32
is: %32
an: %13
int
.: %32
The: %32
functions: %32
return: %32
non
-
zero: %32
(
true
): %32
if: %32
the: %32
argument: %32
c: %32
satisfies: %32
the: %32
condition: %32
described
,: %32
and: %32
zero: %32
if: %13
not
.: %13
isalnum
(
c
): %32
isalpha
(
c
): %32
or: %32
isdigit
(
c
): %32
is: %32
true: %13
isalpha
(
c
): %32
isupper
(
c
): %32
or: %32
islower
(
c
): %32
is: %32
true: %13
iscntrl
(
c
): %32
control: %32
character: %13
isdigit
(
c
): %32
decimal: %32
digit: %13
isgraph
(
c
): %32
printing: %32
character: %32
except: %32
space: %13
islower
(
c
): %32
lower
-
case: %32
letter: %13
isprint
(
c
): %32
printing: %32
character: %32
including: %32
space: %13
ispunct
(
c
): %32
printing: %32
character: %32
except: %32
space: %32
or: %32
letter: %32
or: %32
digit: %13
isspace
(
c
): %32
space
,: %32
formfeed
,: %32
newline
,: %32
carriage: %32
return
,: %32
tab
,: %32
vertical: %32
tab: %13
isupper
(
c
): %32
upper
-
case: %32
letter: %13
isxdigit
(
c
): %32
hexadecimal: %32
digit: %13
In: %32
the: %32
seven
-
bit: %32
ASCII: %32
character: %32
set
,: %32
the: %32
printing: %32
characters: %32
are: %32
0
x
2
0: %32
(
': %32
'
): %32
to: %32
0
x
7
E: %32
(
'
-
'
)
;: %32
the: %13
control: %32
characters: %32
are: %32
0: %32
NUL: %32
to: %32
0
x
1
F: %32
(
US
)
,: %32
and: %32
0
x
7
F: %32
(
DEL
)
.: %13
In: %32
addition
,: %32
there: %32
are: %32
two: %32
functions: %32
that: %32
convert: %32
the: %32
case: %32
of: %32
letters
:: %13
int: %32
tolower
(
c
): %32
convert: %32
c: %32
to: %32
lower: %32
case: %13
int: %32
toupper
(
c
): %32
convert: %32
c: %32
to: %32
upper: %32
case: %13
If: %32
c: %32
is: %32
an: %32
upper
-
case: %32
letter
,: %32
tolower
(
c
): %32
returns: %32
the: %32
corresponding: %32
lower
-
case: %32
letter
,: %32
toupper
(
c
): %13
Appendix: %32
B: %32
-: %32
Standard: %32
Library: %13
returns: %32
the: %32
corresponding: %32
upper
-
case: %32
letter
;: %32
otherwise: %32
it: %32
returns: %32
c
.: %13
B
.
3: %32
String: %32
Functions
:: %32
<
string
.
h
>: %13
There: %32
are: %32
two: %32
groups: %32
of: %32
string: %32
functions: %32
defined: %32
in: %32
the: %32
header: %32
<
string
.
h
>
.: %32
The: %32
first: %32
have: %32
names: %13
beginning: %32
with: %32
str
;: %32
the: %32
second: %32
have: %32
names: %32
beginning: %32
with: %32
mem
.: %32
Except: %32
for: %32
memmove
,: %32
the: %32
behavior: %32
is: %13
undefined: %32
if: %32
copying: %32
takes: %32
place: %32
between: %32
overlapping: %32
objects
.: %32
Comparison: %32
functions: %32
treat: %32
arguments: %32
as: %13
unsigned: %32
char: %32
arrays
.: %13
In: %32
the: %32
following: %32
table
,: %32
variables: %32
s: %32
and: %32
t: %32
are: %32
of: %32
type: %32
char: %32
*
;: %32
cs: %32
and: %32
ct: %32
are: %32
of: %32
type: %32
const: %32
char: %32
*
;: %13
n: %32
is: %32
of: %32
type: %32
size
_
t
;: %32
and: %32
c: %32
is: %32
an: %32
int: %32
converted: %32
to: %32
char
.: %13
copy: %32
string: %32
ct: %32
to: %32
string: %32
s
,: %32
including: %32
'
\
0
'
;: %32
return: %32
s
.: %13
copy: %32
at: %32
most: %32
n: %32
characters: %32
of: %32
string: %32
ct: %32
to: %32
s
;: %32
return: %32
s
.: %32
Pad: %32
with: %32
'
\
0
'
'
s: %13
char: %32
*
strncpy
(
s
,
ct
,
n
): %13
if: %32
ct: %32
has: %32
fewer: %32
than: %32
n: %32
characters
.: %13
concatenate: %32
string: %32
ct: %32
to: %32
end: %32
of: %32
string: %32
s
;: %32
return: %32
s
.: %13
char: %32
*
strcat
(
s
,
ct
): %13
concatenate: %32
at: %32
most: %32
n: %32
characters: %32
of: %32
string: %32
ct: %32
to: %32
string: %32
s
,: %32
terminate: %32
s: %13
char: %32
*
strncat
(
s
,
ct
,
n
): %13
with: %32
'
\
0
'
;: %32
return: %32
s
.: %13
compare: %32
string: %32
cs: %32
to: %32
string: %32
ct
,: %32
return: %32
<
0: %32
if: %32
cs
<
ct
,: %32
0: %32
if: %32
cs
=
=
ct
,: %32
or: %13
int: %32
strcmp
(
cs
,
ct
): %13
>
0: %32
if: %32
cs
>
ct
.: %13
compare: %32
at: %32
most: %32
n: %32
characters: %32
of: %32
string: %32
cs: %32
to: %32
string: %32
ct
;: %32
return: %32
<
0: %32
if: %13
int: %32
strncmp
(
cs
,
ct
,
n
): %13
cs
<
ct
,: %32
0: %32
if: %32
cs
=
=
ct
,: %32
or: %32
>
0: %32
if: %32
cs
>
ct
.: %13
return: %32
pointer: %32
to: %32
first: %32
occurrence: %32
of: %32
c: %32
in: %32
cs: %32
or: %32
NULL: %32
if: %32
not: %32
present
.: %13
char: %32
*
strchr
(
cs
,
c
): %13
char: %32
*
strrchr
(
cs
,
c
): %32
return: %32
pointer: %32
to: %32
last: %32
occurrence: %32
of: %32
c: %32
in: %32
cs: %32
or: %32
NULL: %32
if: %32
not: %32
present
.: %13
size
_
t: %32
strspn
(
cs
,
ct
): %32
return: %32
length: %32
of: %32
prefix: %32
of: %32
cs: %32
consisting: %32
of: %32
characters: %32
in: %32
ct
.: %13
size
_
t: %32
strcspn
(
cs
,
ct
): %32
return: %32
length: %32
of: %32
prefix: %32
of: %32
cs: %32
consisting: %32
of: %32
characters: %32
not: %32
in: %32
ct
.: %13
return: %32
pointer: %32
to: %32
first: %32
occurrence: %32
in: %32
string: %32
cs: %32
of: %32
any: %32
character: %32
string: %32
ct
,: %13
char: %32
*
strpbrk
(
cs
,
ct
): %13
or: %32
NULL: %32
if: %32
not: %32
present
.: %13
return: %32
pointer: %32
to: %32
first: %32
occurrence: %32
of: %32
string: %32
ct: %32
in: %32
cs
,: %32
or: %32
NULL: %32
if: %32
not: %13
char: %32
*
strstr
(
cs
,
ct
): %13
present
.: %13
return: %32
length: %32
of: %32
cs
.: %13
size
_
t: %32
strlen
(
cs
): %13
return: %32
pointer: %32
to: %32
implementation
-
defined: %32
string: %32
corresponding: %32
to: %32
error: %13
char: %32
*
strerror
(
n
): %13
n
.: %13
strtok: %32
searches: %32
s: %32
for: %32
tokens: %32
delimited: %32
by: %32
characters: %32
from: %32
ct
;: %32
see: %13
char: %32
*
strtok
(
s
,
ct
): %13
below
.: %13
char: %32
*
strcpy
(
s
,
ct
): %13
A: %32
sequence: %32
of: %32
calls: %32
of: %32
strtok
(
s
,
ct
): %32
splits: %32
s: %32
into: %32
tokens
,: %32
each: %32
delimited: %32
by: %32
a: %32
character: %32
from: %32
ct
.: %32
The: %13
first: %32
call: %32
in: %32
a: %32
sequence: %32
has: %32
a: %32
non
-
NULL: %32
s
,: %32
it: %32
finds: %32
the: %32
first: %32
token: %32
in: %32
s: %32
consisting: %32
of: %32
characters: %32
not: %32
in: %32
ct
;: %13
Appendix: %32
B: %32
-: %32
Standard: %32
Library: %13
it: %32
terminates: %32
that: %32
by: %32
overwriting: %32
the: %32
next: %32
character: %32
of: %32
s: %32
with: %32
'
\
0
': %32
and: %32
returns: %32
a: %32
pointer: %32
to: %32
the: %32
token
.: %13
Each: %32
subsequent: %32
call
,: %32
indicated: %32
by: %32
a: %32
NULL: %32
value: %32
of: %32
s
,: %32
returns: %32
the: %32
next: %32
such: %32
token
,: %32
searching: %32
from: %32
just: %13
past: %32
the: %32
end: %32
of: %32
the: %32
previous: %32
one
.: %32
strtok: %32
returns: %32
NULL: %32
when: %32
no: %32
further: %32
token: %32
is: %32
found
.: %32
The: %32
string: %32
ct: %13
may: %32
be: %32
different: %32
on: %32
each: %32
call
.: %13
The: %32
mem
.
.
.: %32
functions: %32
are: %32
meant: %32
for: %32
manipulating: %32
objects: %32
as: %32
character: %32
arrays
;: %32
the: %32
intent: %32
is: %32
an: %32
interface: %13
to: %32
efficient: %32
routines
.: %32
In: %32
the: %32
following: %32
table
,: %32
s: %32
and: %32
t: %32
are: %32
of: %32
type: %32
void: %32
*
;: %32
cs: %32
and: %32
ct: %32
are: %32
of: %32
type: %32
const: %13
void: %32
*
;: %32
n: %32
is: %32
of: %32
type: %32
size
_
t
;: %32
and: %32
c: %32
is: %32
an: %32
int: %32
converted: %32
to: %32
an: %32
unsigned: %32
char
.: %13
void: %32
*
memcpy
(
s
,
ct
,
n
): %32
copy: %32
n: %32
characters: %32
from: %32
ct: %32
to: %32
s
,: %32
and: %32
return: %32
s
.: %13
void: %32
*
memmove
(
s
,
ct
,
n
): %32
same: %32
as: %32
memcpy: %32
except: %32
that: %32
it: %32
works: %32
even: %32
if: %32
the: %32
objects: %32
overlap
.: %13
int: %32
memcmp
(
cs
,
ct
,
n
): %32
compare: %32
the: %32
first: %32
n: %32
characters: %32
of: %32
cs: %32
with: %32
ct
;: %32
return: %32
as: %32
with: %32
strcmp
.: %13
return: %32
pointer: %32
to: %32
first: %32
occurrence: %32
of: %32
character: %32
c: %32
in: %32
cs
,: %32
or: %32
NULL: %32
if: %32
not: %13
void: %32
*
memchr
(
cs
,
c
,
n
): %13
present: %32
among: %32
the: %32
first: %32
n: %32
characters
.: %13
void: %32
*
memset
(
s
,
c
,
n
): %32
place: %32
character: %32
c: %32
into: %32
first: %32
n: %32
characters: %32
of: %32
s
,: %32
return: %32
s
.: %13
B
.
4: %32
Mathematical: %32
Functions
:: %32
<
math
.
h
>: %13
The: %32
header: %32
<
math
.
h
>: %32
declares: %32
mathematical: %32
functions: %32
and: %32
macros
.: %13
The: %32
macros: %32
EDOM: %32
and: %32
ERANGE: %32
(
found: %32
in: %32
<
errno
.
h
>
): %32
are: %32
non
-
zero: %32
integral: %32
constants: %32
that: %32
are: %32
used: %32
to: %13
signal: %32
domain: %32
and: %32
range: %32
errors: %32
for: %32
the: %32
functions
;: %32
HUGE
_
VAL: %32
is: %32
a: %32
positive: %32
double: %32
value
.: %32
A: %32
domain: %13
error: %32
occurs: %32
if: %32
an: %32
argument: %32
is: %32
outside: %32
the: %32
domain: %32
over: %32
which: %32
the: %32
function: %32
is: %32
defined
.: %32
On: %32
a: %32
domain: %32
error
,: %13
errno: %32
is: %32
set: %32
to: %32
EDOM
;: %32
the: %32
return: %32
value: %32
is: %32
implementation
-
defined
.: %32
A: %32
range: %32
error: %32
occurs: %32
if: %32
the: %32
result: %32
of: %13
the: %32
function: %32
cannot: %32
be: %32
represented: %32
as: %32
a: %32
double
.: %32
If: %32
the: %32
result: %32
overflows
,: %32
the: %32
function: %32
returns: %32
HUGE
_
VAL: %13
with: %32
the: %32
right: %32
sign
,: %32
and: %32
errno: %32
is: %32
set: %32
to: %32
ERANGE
.: %32
If: %32
the: %32
result: %32
underflows
,: %32
the: %32
function: %32
returns: %32
zero
;: %13
whether: %32
errno: %32
is: %32
set: %32
to: %32
ERANGE: %32
is: %32
implementation
-
defined
.: %13
In: %32
the: %32
following: %32
table
,: %32
x: %32
and: %32
y: %32
are: %32
of: %32
type: %32
double
,: %32
n: %32
is: %32
an: %32
int
,: %32
and: %32
all: %32
functions: %32
return: %32
double
.: %13
Angles: %32
for: %32
trigonometric: %32
functions: %32
are: %32
expressed: %32
in: %32
radians
.: %13
sin
(
x
): %32
sine: %32
of: %32
x: %13
cos
(
x
): %32
cosine: %32
of: %32
x: %13
tan
(
x
): %32
tangent: %32
of: %32
x: %13
asin
(
x
): %32
sin
-
1
(
x
): %32
in: %32
range: %32
[
-
pi
/
2
,
pi
/
2
]
,: %32
x: %32
in: %32
[
-
1
,
1
]
.: %13
acos
(
x
): %32
cos
-
1
(
x
): %32
in: %32
range: %32
[
0
,
pi
]
,: %32
x: %32
in: %32
[
-
1
,
1
]
.: %13
atan
(
x
): %32
tan
-
1
(
x
): %32
in: %32
range: %32
[
-
pi
/
2
,
pi
/
2
]
.: %13
atan
2
(
y
,
x
): %32
tan
-
1
(
y
/
x
): %32
in: %32
range: %32
[
-
pi
,
pi
]
.: %13
Appendix: %32
B: %32
-: %32
Standard: %32
Library: %13
sinh
(
x
): %32
hyperbolic: %32
sine: %32
of: %32
x: %13
cosh
(
x
): %32
hyperbolic: %32
cosine: %32
of: %32
x: %13
tanh
(
x
): %32
hyperbolic: %32
tangent: %32
of: %32
x: %13
exp
(
x
): %32
exponential: %32
function: %32
ex: %13
: %32%32%32%32%32%32
natural: %32
logarithm: %32
ln
(
x
)
,: %32
x
>
0
.: %13
: %32%32%32%32%32
base: %32
1
0: %32
logarithm: %32
log
1
0
(
x
)
,: %32
x
>
0
.: %13
log
(
x
): %13
log
1
0
(
x
): %13
pow
(
x
,
y
): %13
sqrt
(
x
): %13
ceil
(
x
): %13
floor
(
x
): %13
fabs
(
x
): %13
xy
.: %32
A: %32
domain: %32
error: %32
occurs: %32
if: %32
x
=
0: %32
and: %32
y
<
=
0
,: %32
or: %32
if: %32
x
<
0: %32
and: %32
y: %32
is: %32
not: %32
an: %13
integer
.: %13
sqare: %32
root: %32
of: %32
x
,: %32
x
>
=
0
.: %13
smallest: %32
integer: %32
not: %32
less: %32
than: %32
x
,: %32
as: %32
a: %32
double
.: %13
largest: %32
integer: %32
not: %32
greater: %32
than: %32
x
,: %32
as: %32
a: %32
double
.: %13
absolute: %32
value: %32
|
x
|: %13
x
*
2
n: %13
splits: %32
x: %32
into: %32
a: %32
normalized: %32
fraction: %32
in: %32
the: %32
interval: %32
[
1
/
2
,
1
): %32
which: %32
is: %32
returned
,: %13
frexp
(
x
,: %32
int: %32
*
ip
): %32
and: %32
a: %32
power: %32
of: %32
2
,: %32
which: %32
is: %32
stored: %32
in: %32
*
exp
.: %32
If: %32
x: %32
is: %32
zero
,: %32
both: %32
parts: %32
of: %32
the: %13
result: %32
are: %32
zero
.: %13
splits: %32
x: %32
into: %32
integral: %32
and: %32
fractional: %32
parts
,: %32
each: %32
with: %32
the: %32
same: %32
sign: %32
as: %32
x
.: %32
It: %13
modf
(
x
,: %32
double: %32
*
ip
): %13
stores: %32
the: %32
integral: %32
part: %32
in: %32
*
ip
,: %32
and: %32
returns: %32
the: %32
fractional: %32
part
.: %13
floating
-
point: %32
remainder: %32
of: %32
x
/
y
,: %32
with: %32
the: %32
same: %32
sign: %32
as: %32
x
.: %32
If: %32
y: %32
is: %32
zero
,: %32
the: %13
fmod
(
x
,
y
): %13
result: %32
is: %32
implementation
-
defined
.: %13
ldexp
(
x
,
n
): %13
B
.
5: %32
Utility: %32
Functions
:: %32
<
stdlib
.
h
>: %13
The: %32
header: %32
<
stdlib
.
h
>: %32
declares: %32
functions: %32
for: %32
number: %32
conversion
,: %32
storage: %32
allocation
,: %32
and: %32
similar: %13
tasks
.: %13
double: %32
atof
(
const: %32
char: %32
*
s
): %13
atof: %32
converts: %32
s: %32
to: %32
double
;: %32
it: %32
is: %32
equivalent: %32
to: %32
strtod
(
s
,: %32
(
char
*
*
)
NULL
)
.: %13
int: %32
atoi
(
const: %32
char: %32
*
s
): %13
converts: %32
s: %32
to: %32
int
;: %32
it: %32
is: %32
equivalent: %32
to: %32
(
int
)
strtol
(
s
,: %32
(
char
*
*
)
NULL
,: %32
1
0
)
.: %13
long: %32
atol
(
const: %32
char: %32
*
s
): %13
converts: %32
s: %32
to: %32
long
;: %32
it: %32
is: %32
equivalent: %32
to: %32
strtol
(
s
,: %32
(
char
*
*
)
NULL
,: %32
1
0
)
.: %13
double: %32
strtod
(
const: %32
char: %32
*
s
,: %32
char: %32
*
*
endp
): %13
strtod: %32
converts: %32
the: %32
prefix: %32
of: %32
s: %32
to: %32
double
,: %32
ignoring: %32
leading: %32
white: %32
space
;: %32
it: %32
stores: %32
a: %32
pointer: %32
to: %13
Appendix: %32
B: %32
-: %32
Standard: %32
Library: %13
any: %32
unconverted: %32
suffix: %32
in: %32
*
endp: %32
unless: %32
endp: %32
is: %32
NULL
.: %32
If: %32
the: %32
answer: %32
would: %32
overflow
,: %13
HUGE
_
VAL: %32
is: %32
returned: %32
with: %32
the: %32
proper: %32
sign
;: %32
if: %32
the: %32
answer: %32
would: %32
underflow
,: %32
zero: %32
is: %32
returned
.: %32
In: %13
either: %32
case: %32
errno: %32
is: %32
set: %32
to: %32
ERANGE
.: %13
long: %32
strtol
(
const: %32
char: %32
*
s
,: %32
char: %32
*
*
endp
,: %32
int: %32
base
): %13
strtol: %32
converts: %32
the: %32
prefix: %32
of: %32
s: %32
to: %32
long
,: %32
ignoring: %32
leading: %32
white: %32
space
;: %32
it: %32
stores: %32
a: %32
pointer: %32
to: %32
any: %13
unconverted: %32
suffix: %32
in: %32
*
endp: %32
unless: %32
endp: %32
is: %32
NULL
.: %32
If: %32
base: %32
is: %32
between: %32
2: %32
and: %32
3
6
,: %32
conversion: %32
is: %13
done: %32
assuming: %32
that: %32
the: %32
input: %32
is: %32
written: %32
in: %32
that: %32
base
.: %32
If: %32
base: %32
is: %32
zero
,: %32
the: %32
base: %32
is: %32
8
,: %32
1
0
,: %32
or: %32
1
6
;: %13
leading: %32
0: %32
implies: %32
octal: %32
and: %32
leading: %32
0
x: %32
or: %32
0
X: %32
hexadecimal
.: %32
Letters: %32
in: %32
either: %32
case: %32
represent: %32
digits: %13
from: %32
1
0: %32
to: %32
base
-
1
;: %32
a: %32
leading: %32
0
x: %32
or: %32
0
X: %32
is: %32
permitted: %32
in: %32
base: %32
1
6
.: %32
If: %32
the: %32
answer: %32
would: %32
overflow
,: %13
LONG
_
MAX: %32
or: %32
LONG
_
MIN: %32
is: %32
returned
,: %32
depending: %32
on: %32
the: %32
sign: %32
of: %32
the: %32
result
,: %32
and: %32
errno: %32
is: %32
set: %32
to: %13
ERANGE
.: %13
unsigned: %32
long: %32
strtoul
(
const: %32
char: %32
*
s
,: %32
char: %32
*
*
endp
,: %32
int: %32
base
): %13
strtoul: %32
is: %32
the: %32
same: %32
as: %32
strtol: %32
except: %32
that: %32
the: %32
result: %32
is: %32
unsigned: %32
long: %32
and: %32
the: %32
error: %32
value: %13
is: %32
ULONG
_
MAX
.: %13
int: %32
rand
(
void
): %13
rand: %32
returns: %32
a: %32
pseudo
-
random: %32
integer: %32
in: %32
the: %32
range: %32
0: %32
to: %32
RAND
_
MAX
,: %32
which: %32
is: %32
at: %32
least: %32
3
2
7
6
7
.: %13
void: %32
srand
(
unsigned: %32
int: %32
seed
): %13
srand: %32
uses: %32
seed: %32
as: %32
the: %32
seed: %32
for: %32
a: %32
new: %32
sequence: %32
of: %32
pseudo
-
random: %32
numbers
.: %32
The: %32
initial: %32
seed: %32
is: %13
1
.: %13
void: %32
*
calloc
(
size
_
t: %32
nobj
,: %32
size
_
t: %32
size
): %13
calloc: %32
returns: %32
a: %32
pointer: %32
to: %32
space: %32
for: %32
an: %32
array: %32
of: %32
nobj: %32
objects
,: %32
each: %32
of: %32
size: %32
size
,: %32
or: %32
NULL: %32
if: %13
the: %32
request: %32
cannot: %32
be: %32
satisfied
.: %32
The: %32
space: %32
is: %32
initialized: %32
to: %32
zero: %32
bytes
.: %13
void: %32
*
malloc
(
size
_
t: %32
size
): %13
malloc: %32
returns: %32
a: %32
pointer: %32
to: %32
space: %32
for: %32
an: %32
object: %32
of: %32
size: %32
size
,: %32
or: %32
NULL: %32
if: %32
the: %32
request: %32
cannot: %32
be: %13
satisfied
.: %32
The: %32
space: %32
is: %32
uninitialized
.: %13
void: %32
*
realloc
(
void: %32
*
p
,: %32
size
_
t: %32
size
): %13
realloc: %32
changes: %32
the: %32
size: %32
of: %32
the: %32
object: %32
pointed: %32
to: %32
by: %32
p: %32
to: %32
size
.: %32
The: %32
contents: %32
will: %32
be: %13
unchanged: %32
up: %32
to: %32
the: %32
minimum: %32
of: %32
the: %32
old: %32
and: %32
new: %32
sizes
.: %32
If: %32
the: %32
new: %32
size: %32
is: %32
larger
,: %32
the: %32
new: %32
space: %32
is: %13
uninitialized
.: %32
realloc: %32
returns: %32
a: %32
pointer: %32
to: %32
the: %32
new: %32
space
,: %32
or: %32
NULL: %32
if: %32
the: %32
request: %32
cannot: %32
be: %13
satisfied
,: %32
in: %32
which: %32
case: %32
*
p: %32
is: %32
unchanged
.: %13
void: %32
free
(
void: %32
*
p
): %13
free: %32
deallocates: %32
the: %32
space: %32
pointed: %32
to: %32
by: %32
p
;: %32
it: %32
does: %32
nothing: %32
if: %32
p: %32
is: %32
NULL
.: %32
p: %32
must: %32
be: %32
a: %32
pointer: %32
to: %13
space: %32
previously: %32
allocated: %32
by: %32
calloc
,: %32
malloc
,: %32
or: %32
realloc
.: %13
Appendix: %32
B: %32
-: %32
Standard: %32
Library: %13
void: %32
abort
(
void
): %13
abort: %32
causes: %32
the: %32
program: %32
to: %32
terminate: %32
abnormally
,: %32
as: %32
if: %32
by: %32
raise
(
SIGABRT
)
.: %13
void: %32
exit
(
int: %32
status
): %13
exit: %32
causes: %32
normal: %32
program: %32
termination
.: %32
atexit: %32
functions: %32
are: %32
called: %32
in: %32
reverse: %32
order: %32
of: %13
registration
,: %32
open: %32
files: %32
are: %32
flushed
,: %32
open: %32
streams: %32
are: %32
closed
,: %32
and: %32
control: %32
is: %32
returned: %32
to: %32
the: %13
environment
.: %32
How: %32
status: %32
is: %32
returned: %32
to: %32
the: %32
environment: %32
is: %32
implementation
-
dependent
,: %32
but: %32
zero: %13
is: %32
taken: %32
as: %32
successful: %32
termination
.: %32
The: %32
values: %32
EXIT
_
SUCCESS: %32
and: %32
EXIT
_
FAILURE: %32
may: %32
also: %13
be: %32
used
.: %13
int: %32
atexit
(
void: %32
(
*
fcn
)
(
void
)
): %13
atexit: %32
registers: %32
the: %32
function: %32
fcn: %32
to: %32
be: %32
called: %32
when: %32
the: %32
program: %32
terminates: %32
normally
;: %32
it: %32
returns: %13
non
-
zero: %32
if: %32
the: %32
registration: %32
cannot: %32
be: %32
made
.: %13
int: %32
system
(
const: %32
char: %32
*
s
): %13
system: %32
passes: %32
the: %32
string: %32
s: %32
to: %32
the: %32
environment: %32
for: %32
execution
.: %32
If: %32
s: %32
is: %32
NULL
,: %32
system: %32
returns: %32
non
-: %13
zero: %32
if: %32
there: %32
is: %32
a: %32
command: %32
processor
.: %32
If: %32
s: %32
is: %32
not: %32
NULL
,: %32
the: %32
return: %32
value: %32
is: %32
implementation
-: %13
dependent
.: %13
char: %32
*
getenv
(
const: %32
char: %32
*
name
): %13
getenv: %32
returns: %32
the: %32
environment: %32
string: %32
associated: %32
with: %32
name
,: %32
or: %32
NULL: %32
if: %32
no: %32
string: %32
exists
.: %13
Details: %32
are: %32
implementation
-
dependent
.: %13
void: %32
*
bsearch
(
const: %32
void: %32
*
key
,: %32
const: %32
void: %32
*
base
,: %13
size
_
t: %32
n
,: %32
size
_
t: %32
size
,: %13
int: %32
(
*
cmp
)
(
const: %32
void: %32
*
keyval
,: %32
const: %32
void: %32
*
datum
)
): %13
bsearch: %32
searches: %32
base
[
0
]
.
.
.
base
[
n
-
1
]: %32
for: %32
an: %32
item: %32
that: %32
matches: %32
*
key
.: %32
The: %32
function: %13
cmp: %32
must: %32
return: %32
negative: %32
if: %32
its: %32
first: %32
argument: %32
(
the: %32
search: %32
key
): %32
is: %32
less: %32
than: %32
its: %32
second: %32
(
a: %32
table: %13
entry
)
,: %32
zero: %32
if: %32
equal
,: %32
and: %32
positive: %32
if: %32
greater
.: %32
Items: %32
in: %32
the: %32
array: %32
base: %32
must: %32
be: %32
in: %32
ascending: %32
order
.: %13
bsearch: %32
returns: %32
a: %32
pointer: %32
to: %32
a: %32
matching: %32
item
,: %32
or: %32
NULL: %32
if: %32
none: %32
exists
.: %13
void: %32
qsort
(
void: %32
*
base
,: %32
size
_
t: %32
n
,: %32
size
_
t: %32
size
,: %13
int: %32
(
*
cmp
)
(
const: %32
void: %32
*
,: %32
const: %32
void: %32
*
)
): %13
qsort: %32
sorts: %32
into: %32
ascending: %32
order: %32
an: %32
array: %32
base
[
0
]
.
.
.
base
[
n
-
1
]: %32
of: %32
objects: %32
of: %32
size: %32
size
.: %13
The: %32
comparison: %32
function: %32
cmp: %32
is: %32
as: %32
in: %32
bsearch
.: %13
int: %32
abs
(
int: %32
n
): %13
abs: %32
returns: %32
the: %32
absolute: %32
value: %32
of: %32
its: %32
int: %32
argument
.: %13
long: %32
labs
(
long: %32
n
): %13
Appendix: %32
B: %32
-: %32
Standard: %32
Library: %13
labs: %32
returns: %32
the: %32
absolute: %32
value: %32
of: %32
its: %32
long: %32
argument
.: %13
div
_
t: %32
div
(
int: %32
num
,: %32
int: %32
denom
): %13
div: %32
computes: %32
the: %32
quotient: %32
and: %32
remainder: %32
of: %32
num
/
denom
.: %32
The: %32
results: %32
are: %32
stored: %32
in: %32
the: %32
int: %13
members: %32
quot: %32
and: %32
rem: %32
of: %32
a: %32
structure: %32
of: %32
type: %32
div
_
t
.: %13
ldiv
_
t: %32
ldiv
(
long: %32
num
,: %32
long: %32
denom
): %13
ldiv: %32
computes: %32
the: %32
quotient: %32
and: %32
remainder: %32
of: %32
num
/
denom
.: %32
The: %32
results: %32
are: %32
stored: %32
in: %32
the: %32
long: %13
members: %32
quot: %32
and: %32
rem: %32
of: %32
a: %32
structure: %32
of: %32
type: %32
ldiv
_
t
.: %13
B
.
6: %32
Diagnostics
:: %32
<
assert
.
h
>: %13
The: %32
assert: %32
macro: %32
is: %32
used: %32
to: %32
add: %32
diagnostics: %32
to: %32
programs
:: %13
void: %32
assert
(
int: %32
expression
): %13
If: %32
expression: %32
is: %32
zero: %32
when: %13
assert
(
expression
): %13
is: %32
executed
,: %32
the: %32
assert: %32
macro: %32
will: %32
print: %32
on: %32
stderr: %32
a: %32
message
,: %32
such: %32
as: %13
Assertion: %32
failed
:: %32
expression
,: %32
file: %32
filename
,: %32
line: %32
nnn: %13
It: %32
then: %32
calls: %32
abort: %32
to: %32
terminate: %32
execution
.: %32
The: %32
source: %32
filename: %32
and: %32
line: %32
number: %32
come: %32
from: %32
the: %13
preprocessor: %32
macros: %32
_
_
FILE
_
_: %32
and: %32
_
_
LINE
_
_
.: %13
If: %32
NDEBUG: %32
is: %32
defined: %32
at: %32
the: %32
time: %32
<
assert
.
h
>: %32
is: %32
included
,: %32
the: %32
assert: %32
macro: %32
is: %32
ignored
.: %13
B
.
7: %32
Variable: %32
Argument: %32
Lists
:: %32
<
stdarg
.
h
>: %13
The: %32
header: %32
<
stdarg
.
h
>: %32
provides: %32
facilities: %32
for: %32
stepping: %32
through: %32
a: %32
list: %32
of: %32
function: %32
arguments: %32
of: %13
unknown: %32
number: %32
and: %32
type
.: %13
Suppose: %32
lastarg: %32
is: %32
the: %32
last: %32
named: %32
parameter: %32
of: %32
a: %32
function: %32
f: %32
with: %32
a: %32
variable: %32
number: %32
of: %32
arguments
.: %13
Then: %32
declare: %32
within: %32
f: %32
a: %32
variable: %32
of: %32
type: %32
va
_
list: %32
that: %32
will: %32
point: %32
to: %32
each: %32
argument: %32
in: %32
turn
:: %13
va
_
list: %32
ap
;: %13
ap: %32
must: %32
be: %32
initialized: %32
once: %32
with: %32
the: %32
macro: %32
va
_
start: %32
before: %32
any: %32
unnamed: %32
argument: %32
is: %32
accessed
:: %13
Appendix: %32
B: %32
-: %32
Standard: %32
Library: %13
va
_
start
(
va
_
list: %32
ap
,: %32
lastarg
)
;: %13
Thereafter
,: %32
each: %32
execution: %32
of: %32
the: %32
macro: %32
va
_
arg: %32
will: %32
produce: %32
a: %32
value: %32
that: %32
has: %32
the: %32
type: %32
and: %32
value: %32
of: %32
the: %13
next: %32
unnamed: %32
argument
,: %32
and: %32
will: %32
also: %32
modify: %32
ap: %32
so: %32
the: %32
next: %32
use: %32
of: %32
va
_
arg: %32
returns: %32
the: %32
next: %32
argument
:: %13
type: %32
va
_
arg
(
va
_
list: %32
ap
,: %32
type
)
;: %13
The: %32
macro: %13
void: %32
va
_
end
(
va
_
list: %32
ap
)
;: %13
must: %32
be: %32
called: %32
once: %32
after: %32
the: %32
arguments: %32
have: %32
been: %32
processed: %32
but: %32
before: %32
f: %32
is: %32
exited
.: %13
B
.
8: %32
Non
-
local: %32
Jumps
:: %32
<
setjmp
.
h
>: %13
The: %32
declarations: %32
in: %32
<
setjmp
.
h
>: %32
provide: %32
a: %32
way: %32
to: %32
avoid: %32
the: %32
normal: %32
function: %32
call: %32
and: %32
return: %32
sequence
,: %13
typically: %32
to: %32
permit: %32
an: %32
immediate: %32
return: %32
from: %32
a: %32
deeply: %32
nested: %32
function: %32
call
.: %13
int: %32
setjmp
(
jmp
_
buf: %32
env
): %13
The: %32
macro: %32
setjmp: %32
saves: %32
state: %32
information: %32
in: %32
env: %32
for: %32
use: %32
by: %32
longjmp
.: %32
The: %32
return: %32
is: %32
zero: %32
from: %13
a: %32
direct: %32
call: %32
of: %32
setjmp
,: %32
and: %32
non
-
zero: %32
from: %32
a: %32
subsequent: %32
call: %32
of: %32
longjmp
.: %32
A: %32
call: %32
to: %32
setjmp: %13
can: %32
only: %32
occur: %32
in: %32
certain: %32
contexts
,: %32
basically: %32
the: %32
test: %32
of: %32
if
,: %32
switch
,: %32
and: %32
loops
,: %32
and: %32
only: %32
in: %13
simple: %32
relational: %32
expressions
.: %13
if: %32
(
setjmp
(
env
): %32
=
=: %32
0
): %13
/
*: %32
get: %32
here: %32
on: %32
direct: %32
call: %32
*
/: %13
else: %13
/
*: %32
get: %32
here: %32
by: %32
calling: %32
longjmp: %32
*
/: %13
void: %32
longjmp
(
jmp
_
buf: %32
env
,: %32
int: %32
val
): %13
longjmp: %32
restores: %32
the: %32
state: %32
saved: %32
by: %32
the: %32
most: %32
recent: %32
call: %32
to: %32
setjmp
,: %32
using: %32
the: %32
information: %13
saved: %32
in: %32
env
,: %32
and: %32
execution: %32
resumes: %32
as: %32
if: %32
the: %32
setjmp: %32
function: %32
had: %32
just: %32
executed: %32
and: %32
returned: %13
the: %32
non
-
zero: %32
value: %32
val
.: %32
The: %32
function: %32
containing: %32
the: %32
setjmp: %32
must: %32
not: %32
have: %32
terminated
.: %13
Accessible: %32
objects: %32
have: %32
the: %32
values: %32
they: %32
had: %32
at: %32
the: %32
time: %32
longjmp: %32
was: %32
called
,: %32
except: %32
that: %32
non
-: %13
volatile: %32
automatic: %32
variables: %32
in: %32
the: %32
function: %32
calling: %32
setjmp: %32
become: %32
undefined: %32
if: %32
they: %32
were: %13
changed: %32
after: %32
the: %32
setjmp: %32
call
.: %13
B
.
9: %32
Signals
:: %32
<
signal
.
h
>: %13
Appendix: %32
B: %32
-: %32
Standard: %32
Library: %13
The: %32
header: %32
<
signal
.
h
>: %32
provides: %32
facilities: %32
for: %32
handling: %32
exceptional: %32
conditions: %32
that: %32
arise: %32
during: %13
execution
,: %32
such: %32
as: %32
an: %32
interrupt: %32
signal: %32
from: %32
an: %32
external: %32
source: %32
or: %32
an: %32
error: %32
in: %32
execution
.: %13
void: %32
(
*
signal
(
int: %32
sig
,: %32
void: %32
(
*
handler
)
(
int
)
)
)
(
int
): %13
signal: %32
determines: %32
how: %32
subsequent: %32
signals: %32
will: %32
be: %32
handled
.: %32
If: %32
handler: %32
is: %32
SIG
_
DFL
,: %32
the: %13
implementation
-
defined: %32
default: %32
behavior: %32
is: %32
used
,: %32
if: %32
it: %32
is: %32
SIG
_
IGN
,: %32
the: %32
signal: %32
is: %32
ignored
;: %32
otherwise
,: %32
the: %13
function: %32
pointed: %32
to: %32
by: %32
handler: %32
will: %32
be: %32
called
,: %32
with: %32
the: %32
argument: %32
of: %32
the: %32
type: %32
of: %32
signal
.: %32
Valid: %32
signals: %13
include: %13
SIGABRT: %13
SIGFPE: %13
SIGILL: %13
SIGINT: %13
SIGSEGV: %13
SIGTERM: %13
abnormal: %32
termination
,: %32
e
.
g
.
,: %32
from: %32
abort: %13
arithmetic: %32
error
,: %32
e
.
g
.
,: %32
zero: %32
divide: %32
or: %32
overflow: %13
illegal: %32
function: %32
image
,: %32
e
.
g
.
,: %32
illegal: %32
instruction: %13
interactive: %32
attention
,: %32
e
.
g
.
,: %32
interrupt: %13
illegal: %32
storage: %32
access
,: %32
e
.
g
.
,: %32
access: %32
outside: %32
memory: %32
limits: %13
termination: %32
request: %32
sent: %32
to: %32
this: %32
program: %13
signal: %32
returns: %32
the: %32
previous: %32
value: %32
of: %32
handler: %32
for: %32
the: %32
specific: %32
signal
,: %32
or: %32
SIG
_
ERR: %32
if: %32
an: %32
error: %32
occurs
.: %13
When: %32
a: %32
signal: %32
sig: %32
subsequently: %32
occurs
,: %32
the: %32
signal: %32
is: %32
restored: %32
to: %32
its: %32
default: %32
behavior
;: %32
then: %32
the: %32
signal
-: %13
handler: %32
function: %32
is: %32
called
,: %32
as: %32
if: %32
by: %32
(
*
handler
)
(
sig
)
.: %32
If: %32
the: %32
handler: %32
returns
,: %32
execution: %32
will: %32
resume: %13
where: %32
it: %32
was: %32
when: %32
the: %32
signal: %32
occurred
.: %13
The: %32
initial: %32
state: %32
of: %32
signals: %32
is: %32
implementation
-
defined
.: %13
int: %32
raise
(
int: %32
sig
): %13
raise: %32
sends: %32
the: %32
signal: %32
sig: %32
to: %32
the: %32
program
;: %32
it: %32
returns: %32
non
-
zero: %32
if: %32
unsuccessful
.: %13
B
.
1
0: %32
Date: %32
and: %32
Time: %32
Functions
:: %32
<
time
.
h
>: %13
The: %32
header: %32
<
time
.
h
>: %32
declares: %32
types: %32
and: %32
functions: %32
for: %32
manipulating: %32
date: %32
and: %32
time
.: %32
Some: %32
functions: %13
process: %32
local: %32
time
,: %32
which: %32
may: %32
differ: %32
from: %32
calendar: %32
time
,: %32
for: %32
example: %32
because: %32
of: %32
time: %32
zone
.: %32
clock
_
t: %13
and: %32
time
_
t: %32
are: %32
arithmetic: %32
types: %32
representing: %32
times
,: %32
and: %32
struct: %32
tm: %32
holds: %32
the: %32
components: %32
of: %32
a: %13
calendar: %32
time
:: %13
int: %32
tm
_
sec
;: %13
int: %32
tm
_
min
;: %13
seconds: %32
after: %32
the: %32
minute: %32
(
0
,
6
1
): %13
minutes: %32
after: %32
the: %32
hour: %32
(
0
,
5
9
): %13
Appendix: %32
B: %32
-: %32
Standard: %32
Library: %13
int: %13
int: %13
int: %13
int: %13
int: %13
int: %13
int: %13
tm
_
hour
;: %32
hours: %32
since: %32
midnight: %32
(
0
,
2
3
): %13
tm
_
mday
;: %32
day: %32
of: %32
the: %32
month: %32
(
1
,
3
1
): %13
tm
_
mon
;: %32
months: %32
since: %32
January: %32
(
0
,
1
1
): %13
tm
_
year
;: %32
years: %32
since: %32
1
9
0
0: %13
tm
_
wday
;: %32
days: %32
since: %32
Sunday: %32
(
0
,
6
): %13
tm
_
yday
;: %32
days: %32
since: %32
January: %32
1: %32
(
0
,
3
6
5
): %13
tm
_
isdst
;: %32
Daylight: %32
Saving: %32
Time: %32
flag: %13
tm
_
isdst: %32
is: %32
positive: %32
if: %32
Daylight: %32
Saving: %32
Time: %32
is: %32
in: %32
effect
,: %32
zero: %32
if: %32
not
,: %32
and: %32
negative: %32
if: %32
the: %32
information: %32
is: %13
not: %32
available
.: %13
clock
_
t: %32
clock
(
void
): %13
clock: %32
returns: %32
the: %32
processor: %32
time: %32
used: %32
by: %32
the: %32
program: %32
since: %32
the: %32
beginning: %32
of: %32
execution
,: %32
or: %32
-
1: %32
if: %13
unavailable
.: %32
clock
(
)
/
CLK
_
PER
_
SEC: %32
is: %32
a: %32
time: %32
in: %32
seconds
.: %13
time
_
t: %32
time
(
time
_
t: %32
*
tp
): %13
time: %32
returns: %32
the: %32
current: %32
calendar: %32
time: %32
or: %32
-
1: %32
if: %32
the: %32
time: %32
is: %32
not: %32
available
.: %32
If: %32
tp: %32
is: %32
not: %32
NULL
,: %32
the: %13
return: %32
value: %32
is: %32
also: %32
assigned: %32
to: %32
*
tp
.: %13
double: %32
difftime
(
time
_
t: %32
time
2
,: %32
time
_
t: %32
time
1
): %13
difftime: %32
returns: %32
time
2
-
time
1: %32
expressed: %32
in: %32
seconds
.: %13
time
_
t: %32
mktime
(
struct: %32
tm: %32
*
tp
): %13
mktime: %32
converts: %32
the: %32
local: %32
time: %32
in: %32
the: %32
structure: %32
*
tp: %32
into: %32
calendar: %32
time: %32
in: %32
the: %32
same: %32
representation: %13
used: %32
by: %32
time
.: %32
The: %32
components: %32
will: %32
have: %32
values: %32
in: %32
the: %32
ranges: %32
shown
.: %32
mktime: %32
returns: %32
the: %13
calendar: %32
time: %32
or: %32
-
1: %32
if: %32
it: %32
cannot: %32
be: %32
represented
.: %13
The: %32
next: %32
four: %32
functions: %32
return: %32
pointers: %32
to: %32
static: %32
objects: %32
that: %32
may: %32
be: %32
overwritten: %32
by: %32
other: %32
calls
.: %13
char: %32
*
asctime
(
const: %32
struct: %32
tm: %32
*
tp
): %13
asctime
*
tp: %32
into: %32
a: %32
string: %32
of: %32
the: %32
form: %13
Sun: %32
Jan: %13
3: %32
1
5
::
1
4
::
1
3: %32
1
9
8
8
\
n
\
0: %13
char: %32
*
ctime
(
const: %32
time
_
t: %32
*
tp
): %13
ctime: %32
converts: %32
the: %32
calendar: %32
time: %32
*
tp: %32
to: %32
local: %32
time
;: %32
it: %32
is: %32
equivalent: %32
to: %13
asctime
(
localtime
(
tp
)
): %13
struct: %32
tm: %32
*
gmtime
(
const: %32
time
_
t: %32
*
tp
): %13
Appendix: %32
B: %32
-: %32
Standard: %32
Library: %13
gmtime: %32
converts: %32
the: %32
calendar: %32
time: %32
*
tp: %32
into: %32
Coordinated: %32
Universal: %32
Time: %32
(
UTC
)
.: %32
It: %32
returns: %13
NULL: %32
if: %32
UTC: %32
is: %32
not: %32
available
.: %32
The: %32
name: %32
gmtime: %32
has: %32
historical: %32
significance
.: %13
struct: %32
tm: %32
*
localtime
(
const: %32
time
_
t: %32
*
tp
): %13
localtime: %32
converts: %32
the: %32
calendar: %32
time: %32
*
tp: %32
into: %32
local: %32
time
.: %13
size
_
t: %32
strftime
(
char: %32
*
s
,: %32
size
_
t: %32
smax
,: %32
const: %32
char: %32
*
fmt
,: %32
const: %32
struct: %32
tm: %13
*
tp
): %13
strftime: %32
formats: %32
date: %32
and: %32
time: %32
information: %32
from: %32
*
tp: %32
into: %32
s: %32
according: %32
to: %32
fmt
,: %32
which: %32
is: %13
analogous: %32
to: %32
a: %32
printf: %32
format
.: %32
Ordinary: %32
characters: %32
(
including: %32
the: %32
terminating: %32
'
\
0
'
): %32
are: %32
copied: %13
into: %32
s
.: %32
Each: %32
%:
c: %32
is: %32
replaced: %32
as: %32
described: %32
below
,: %32
using: %32
values: %32
appropriate: %32
for: %32
the: %32
local: %13
environment
.: %32
No: %32
more: %32
than: %32
smax: %32
characters: %32
are: %32
placed: %32
into: %32
s
.: %32
strftime: %32
returns: %32
the: %32
number: %32
of: %13
characters
,: %32
excluding: %32
the: %32
'
\
0
'
,: %32
or: %32
zero: %32
if: %32
more: %32
than: %32
smax: %32
characters: %32
were: %32
produced
.: %13
%:
a: %13
%:
A: %13
%:
b: %13
%:
B: %13
%:
c: %13
%:
d: %13
%:
H: %13
%:
I: %13
%:
j: %13
%:
m: %13
%:
M: %13
%:
p: %13
%:
S: %13
%:
U: %13
%:
w: %13
%:
W: %13
%:
x: %13
%:
X: %13
%:
y: %13
%:
Y: %13
%:
Z: %13
%:
%: %13
abbreviated: %32
weekday: %32
name
.: %13
full: %32
weekday: %32
name
.: %13
abbreviated: %32
month: %32
name
.: %13
full: %32
month: %32
name
.: %13
local: %32
date: %32
and: %32
time: %32
representation
.: %13
day: %32
of: %32
the: %32
month: %32
(
0
1
-
3
1
)
.: %13
hour: %32
(
2
4
-
hour: %32
clock
): %32
(
0
0
-
2
3
)
.: %13
hour: %32
(
1
2
-
hour: %32
clock
): %32
(
0
1
-
1
2
)
.: %13
day: %32
of: %32
the: %32
year: %32
(
0
0
1
-
3
6
6
)
.: %13
month: %32
(
0
1
-
1
2
)
.: %13
minute: %32
(
0
0
-
5
9
)
.: %13
local: %32
equivalent: %32
of: %32
AM: %32
or: %32
PM
.: %13
second: %32
(
0
0
-
6
1
)
.: %13
week: %32
number: %32
of: %32
the: %32
year: %32
(
Sunday: %32
as: %32
1
st: %32
day: %32
of: %32
week
): %32
(
0
0
-
5
3
)
.: %13
weekday: %32
(
0
-
6
,: %32
Sunday: %32
is: %32
0
)
.: %13
week: %32
number: %32
of: %32
the: %32
year: %32
(
Monday: %32
as: %32
1
st: %32
day: %32
of: %32
week
): %32
(
0
0
-
5
3
)
.: %13
local: %32
date: %32
representation
.: %13
local: %32
time: %32
representation
.: %13
year: %32
without: %32
century: %32
(
0
0
-
9
9
)
.: %13
year: %32
with: %32
century
.: %13
time: %32
zone: %32
name
,: %32
if: %32
any
.: %13
%: %13
Appendix: %32
B: %32
-: %32
Standard: %32
Library: %13
B
.
1
1: %32
Implementation
-
defined: %32
Limits
:: %32
<
limits
.
h
>: %32
and: %13
<
float
.
h
>: %13
The: %32
header: %32
<
limits
.
h
>: %32
defines: %32
constants: %32
for: %32
the: %32
sizes: %32
of: %32
integral: %32
types
.: %32
The: %32
values: %32
below: %32
are: %13
acceptable: %32
minimum: %32
magnitudes
;: %32
larger: %32
values: %32
may: %32
be: %32
used
.: %13
CHAR
_
BIT: %13
CHAR
_
MAX: %13
CHAR
_
MIN: %13
INT
_
MAX: %13
INT
_
MIN: %13
LONG
_
MAX: %13
LONG
_
MIN: %13
SCHAR
_
MAX: %13
SCHAR
_
MIN: %13
SHRT
_
MAX: %13
SHRT
_
MIN: %13
UCHAR
_
MAX: %13
UINT
_
MAX: %13
ULONG
_
MAX: %13
USHRT
_
MAX: %13
8: %13
UCHAR
_
MAX: %32
or: %32
SCHAR
_
MAX: %13
0: %32
or: %32
SCHAR
_
MIN: %13
3
2
7
6
7: %13
-
3
2
7
6
7: %13
2
1
4
7
4
8
3
6
4
7: %13
-
2
1
4
7
4
8
3
6
4
7: %13
+
1
2
7: %13
-
1
2
7: %13
+
3
2
7
6
7: %13
-
3
2
7
6
7: %13
2
5
5: %13
6
5
5
3
5: %13
4
2
9
4
9
6
7
2
9
5: %13
6
5
5
3
5: %13
bits: %32
in: %32
a: %32
char: %13
maximum: %32
value: %32
of: %32
char: %13
maximum: %32
value: %32
of: %32
char: %13
maximum: %32
value: %32
of: %32
int: %13
minimum: %32
value: %32
of: %32
int: %13
maximum: %32
value: %32
of: %32
long: %13
minimum: %32
value: %32
of: %32
long: %13
maximum: %32
value: %32
of: %32
signed: %32
char: %13
minimum: %32
value: %32
of: %32
signed: %32
char: %13
maximum: %32
value: %32
of: %32
short: %13
minimum: %32
value: %32
of: %32
short: %13
maximum: %32
value: %32
of: %32
unsigned: %32
char: %13
maximum: %32
value: %32
of: %32
unsigned: %32
int: %13
maximum: %32
value: %32
of: %32
unsigned: %32
long: %13
maximum: %32
value: %32
of: %32
unsigned: %32
short: %13
The: %32
names: %32
in: %32
the: %32
table: %32
below
,: %32
a: %32
subset: %32
of: %32
<
float
.
h
>
,: %32
are: %32
constants: %32
related: %32
to: %32
floating
-
point: %32
arithmetic
.: %13
When: %32
a: %32
value: %32
is: %32
given
,: %32
it: %32
represents: %32
the: %32
minimum: %32
magnitude: %32
for: %32
the: %32
corresponding: %32
quantity
.: %32
Each: %13
implementation: %32
defines: %32
appropriate: %32
values
.: %13
FLT
_
RADIX: %13
FLT
_
ROUNDS: %13
FLT
_
DIG: %13
FLT
_
EPSILON: %13
FLT
_
MANT
_
DIG: %13
FLT
_
MAX: %13
1
E
+
3
7: %32
radix: %32
of: %32
exponent
,: %32
representation
,: %32
e
.
g
.
,: %32
2
,: %32
1
6: %13
: %32%32%32%32%32
floating
-
point: %32
rounding: %32
mode: %32
for: %32
addition: %13
: %32%32%32%32
decimal: %32
digits: %32
of: %32
precision: %13
: %32%32%32
smallest: %32
number: %32
x: %32
such: %32
that: %32
1
.
0
+
x: %32
!
=: %32
1
.
0: %13
: %32%32
number: %32
of: %32
base: %32
FLT
_
RADIX: %32
in: %32
mantissa: %13
: %32
maximum: %32
floating
-
point: %32
number: %13
1
E
-
3
7: %32
maximum: %32
n: %32
such: %32
that: %32
FLT
_
RADIXn
-
1: %32
is: %32
representable: %13
: %32%32%32%32%32
minimum: %32
normalized: %32
floating
-
point: %32
number: %13
2: %13
6: %13
1
E
-
5: %13
FLT
_
MAX
_
EXP: %13
FLT
_
MIN: %13
FLT
_
MIN
_
EXP: %13
minimum: %32
n: %32
such: %32
that: %32
1
0
n: %32
is: %32
a: %32
normalized: %32
number: %13
Appendix: %32
B: %32
-: %32
Standard: %32
Library: %13
DBL
_
DIG: %13
DBL
_
EPSILON: %13
DBL
_
MANT
_
DIG: %13
DBL
_
MAX: %13
1
E
+
3
7: %32
decimal: %32
digits: %32
of: %32
precision: %13
: %32%32%32%32%32
smallest: %32
number: %32
x: %32
such: %32
that: %32
1
.
0
+
x: %32
!
=: %32
1
.
0: %13
: %32%32%32%32
number: %32
of: %32
base: %32
FLT
_
RADIX: %32
in: %32
mantissa: %13
: %32%32%32
maximum: %32
double: %32
floating
-
point: %32
number: %13
1
E
-
3
7: %32
maximum: %32
n: %32
such: %32
that: %32
FLT
_
RADIXn
-
1: %32
is: %32
representable: %13
: %32%32%32%32%32
minimum: %32
normalized: %32
double: %32
floating
-
point: %32
number: %13
1
0: %13
1
E
-
9: %13
DBL
_
MAX
_
EXP: %13
DBL
_
MIN: %13
DBL
_
MIN
_
EXP: %13
minimum: %32
n: %32
such: %32
that: %32
1
0
n: %32
is: %32
a: %32
normalized: %32
number: %13
Back: %32
to: %32
Appendix: %32
A: %32
-
-: %32
Index: %32
-
-: %32
Appendix: %32
C: %13
Appendix: %32
C: %32
-: %32
Summary: %32
of: %32
Changes: %13
Back: %32
to: %32
Appendix: %32
B: %32
-
-: %32
Index: %13
Appendix: %32
C: %32
-: %32
Summary: %32
of: %32
Changes: %13
Since: %32
the: %32
publication: %32
of: %32
the: %32
first: %32
edition: %32
of: %32
this: %32
book
,: %32
the: %32
definition: %32
of: %32
the: %32
C: %32
language: %32
has: %32
undergone: %13
changes
.: %32
Almost: %32
all: %32
were: %32
extensions: %32
of: %32
the: %32
original: %32
language
,: %32
and: %32
were: %32
carefully: %32
designed: %32
to: %32
remain: %13
compatible: %32
with: %32
existing: %32
practice
;: %32
some: %32
repaired: %32
ambiguities: %32
in: %32
the: %32
original: %32
description
;: %32
and: %32
some: %13
represent: %32
modifications: %32
that: %32
change: %32
existing: %32
practice
.: %32
Many: %32
of: %32
the: %32
new: %32
facilities: %32
were: %32
announced: %32
in: %32
the: %13
documents: %32
accompanying: %32
compilers: %32
available: %32
from: %32
AT
&
T
,: %32
and: %32
have: %32
subsequently: %32
been: %32
adopted: %32
by: %13
other: %32
suppliers: %32
of: %32
C: %32
compilers
.: %32
More: %32
recently
,: %32
the: %32
ANSI: %32
committee: %32
standardizing: %32
the: %32
language: %13
incorporated: %32
most: %32
of: %32
the: %32
changes
,: %32
and: %32
also: %32
introduced: %32
other: %32
significant: %32
modifications
.: %32
Their: %32
report: %32
was: %32
in: %13
part: %32
participated: %32
by: %32
some: %32
commercial: %32
compilers: %32
even: %32
before: %32
issuance: %32
of: %32
the: %32
formal: %32
C: %32
standard
.: %13
This: %32
Appendix: %32
summarizes: %32
the: %32
differences: %32
between: %32
the: %32
language: %32
defined: %32
by: %32
the: %32
first: %32
edition: %32
of: %32
this: %32
book
,: %13
and: %32
that: %32
expected: %32
to: %32
be: %32
defined: %32
by: %32
the: %32
final: %32
standard
.: %32
It: %32
treats: %32
only: %32
the: %32
language: %32
itself
,: %32
not: %32
its: %13
environment: %32
and: %32
library
;: %32
although: %32
these: %32
are: %32
an: %32
important: %32
part: %32
of: %32
the: %32
standard
,: %32
there: %32
is: %32
little: %32
to: %32
compare: %13
with
,: %32
because: %32
the: %32
first: %32
edition: %32
did: %32
not: %32
attempt: %32
to: %32
prescribe: %32
an: %32
environment: %32
or: %32
library
.: %13
q: %13
q: %13
q: %13
q: %13
q: %13
q: %13
q: %13
Preprocessing: %32
is: %32
more: %32
carefully: %32
defined: %32
in: %32
the: %32
Standard: %32
than: %32
in: %32
the: %32
first: %32
edition
,: %32
and: %32
is: %32
extended
:: %32
it: %13
is: %32
explicitly: %32
token: %32
based
;: %32
there: %32
are: %32
new: %32
operators: %32
for: %32
concatenation: %32
of: %32
tokens: %32
(
#
#
)
,: %32
and: %32
creation: %32
of: %13
strings: %32
(
#
)
;: %32
there: %32
are: %32
new: %32
control: %32
lines: %32
like: %32
#
elif: %32
and: %32
#
pragma
;: %32
redeclaration: %32
of: %32
macros: %32
by: %32
the: %13
same: %32
token: %32
sequence: %32
is: %32
explicitly: %32
permitted
;: %32
parameters: %32
inside: %32
strings: %32
are: %32
no: %32
longer: %32
replaced
.: %13
Splicing: %32
of: %32
lines: %32
by: %32
\: %32
is: %32
permitted: %32
everywhere
,: %32
not: %32
just: %32
in: %32
strings: %32
and: %32
macro: %32
definitions
.: %32
See: %13
Par
.
A
.
1
2
.: %13
The: %32
minimum: %32
significance: %32
of: %32
all: %32
internal: %32
identifiers: %32
increased: %32
to: %32
3
1: %32
characters
;: %32
the: %32
smallest: %13
mandated: %32
significance: %32
of: %32
identifiers: %32
with: %32
external: %32
linkage: %32
remains: %32
6: %32
monocase: %32
letters
.: %32
(
Many: %13
implementations: %32
provide: %32
more
.
): %13
Trigraph: %32
sequences: %32
introduced: %32
by: %32
?
?: %32
allow: %32
representation: %32
of: %32
characters: %32
lacking: %32
in: %32
some: %32
character: %13
sets
.: %32
Escapes: %32
for: %32
#
\
^
[
]
{
}
|
~: %32
are: %32
defined
,: %32
see: %32
Par
.
A
.
1
2
.
1
.: %32
Observe: %32
that: %32
the: %32
introduction: %32
of: %13
trigraphs: %32
may: %32
change: %32
the: %32
meaning: %32
of: %32
strings: %32
containing: %32
the: %32
sequence: %32
?
?
.: %13
New: %32
keywords: %32
(
void
,: %32
const
,: %32
volatile
,: %32
signed
,: %32
enum
): %32
are: %32
introduced
.: %32
The: %13
stillborn: %32
entry: %32
keyword: %32
is: %32
withdrawn
.: %13
New: %32
escape: %32
sequences
,: %32
for: %32
use: %32
within: %32
character: %32
constants: %32
and: %32
string: %32
literals
,: %32
are: %32
defined
.: %32
The: %13
effect: %32
of: %32
following: %32
\: %32
by: %32
a: %32
character: %32
not: %32
part: %32
of: %32
an: %32
approved: %32
escape: %32
sequence: %32
is: %32
undefined
.: %32
See: %13
Par
.
A
.
2
.
5
.
2
.: %13
Everyone
'
s: %32
favorite: %32
trivial: %32
change
:: %32
8: %32
and: %32
9: %32
are: %32
not: %32
octal: %32
digits
.: %13
The: %32
standard: %32
introduces: %32
a: %32
larger: %32
set: %32
of: %32
suffixes: %32
to: %32
make: %32
the: %32
type: %32
of: %32
constants: %32
explicit
:: %32
U: %32
or: %32
L: %32
for: %13
Appendix: %32
C: %32
-: %32
Summary: %32
of: %32
Changes: %13
q: %13
q: %13
q: %13
q: %13
q: %13
q: %13
q: %13
q: %13
q: %13
q: %13
q: %13
q: %13
q: %13
q: %13
q: %13
q: %13
q: %13
q: %13
q: %13
q: %13
integers
,: %32
F: %32
or: %32
L: %32
for: %32
floating
.: %32
It: %32
also: %32
refines: %32
the: %32
rules: %32
for: %32
the: %32
type: %32
of: %32
unsiffixed: %32
constants: %13
(
Par
.
A
.
2
.
5
)
.: %13
Adjacent: %32
string: %32
literals: %32
are: %32
concatenated
.: %13
There: %32
is: %32
a: %32
notation: %32
for: %32
wide
-
character: %32
string: %32
literals: %32
and: %32
character: %32
constants
;: %32
see: %32
Par
.
A
.
2
.
6
.: %13
Characters: %32
as: %32
well: %32
as: %32
other: %32
types
,: %32
may: %32
be: %32
explicitly: %32
declared: %32
to: %32
carry
,: %32
or: %32
not: %32
to: %32
carry
,: %32
a: %32
sign: %32
by: %13
using: %32
the: %32
keywords: %32
signed: %32
or: %32
unsigned
.: %32
The: %32
locution: %32
long: %32
float: %32
as: %32
a: %32
synonym: %32
for: %13
double: %32
is: %32
withdrawn
,: %32
but: %32
long: %32
double: %32
may: %32
be: %32
used: %32
to: %32
declare: %32
an: %32
extra
-
precision: %32
floating: %13
quantity
.: %13
For: %32
some: %32
time
,: %32
type: %32
unsigned: %32
char: %32
has: %32
been: %32
available
.: %32
The: %32
standard: %32
introduces: %32
the: %32
signed: %13
keyword: %32
to: %32
make: %32
signedness: %32
explicit: %32
for: %32
char: %32
and: %32
other: %32
integral: %32
objects
.: %13
The: %32
void: %32
type: %32
has: %32
been: %32
available: %32
in: %32
most: %32
implementations: %32
for: %32
some: %32
years
.: %32
The: %32
Standard: %13
introduces: %32
the: %32
use: %32
of: %32
the: %32
void: %32
*: %32
type: %32
as: %32
a: %32
generic: %32
pointer: %32
type
;: %32
previously: %32
char: %32
*: %32
played: %32
this: %13
role
.: %32
At: %32
the: %32
same: %32
time
,: %32
explicit: %32
rules: %32
are: %32
enacted: %32
against: %32
mixing: %32
pointers: %32
and: %32
integers
,: %32
and: %13
pointers: %32
of: %32
different: %32
type
,: %32
without: %32
the: %32
use: %32
of: %32
casts
.: %13
The: %32
Standard: %32
places: %32
explicit: %32
minima: %32
on: %32
the: %32
ranges: %32
of: %32
the: %32
arithmetic: %32
types
,: %32
and: %32
mandates: %32
headers: %13
(
<
limits
.
h
>: %32
and: %32
<
float
.
h
>
): %32
giving: %32
the: %32
characteristics: %32
of: %32
each: %32
particular: %32
implementation
.: %13
Enumerations: %32
are: %32
new: %32
since: %32
the: %32
first: %32
edition: %32
of: %32
this: %32
book
.: %13
The: %32
Standard: %32
adopts: %32
from: %32
C
+
+: %32
the: %32
notion: %32
of: %32
type: %32
qualifier
,: %32
for: %32
example: %32
const: %32
(
Par
.
A
.
8
.
2
)
.: %13
Strings: %32
are: %32
no: %32
longer: %32
modifiable
,: %32
and: %32
so: %32
may: %32
be: %32
placed: %32
in: %32
read
-
only: %32
memory
.: %13
The: %32
`
`
usual: %32
arithmetic: %32
conversions
'
': %32
are: %32
changed
,: %32
essentially: %32
from: %32
`
`
for: %32
integers
,: %32
unsigned: %13
always: %32
wins
;: %32
for: %32
floating: %32
point
,: %32
always: %32
use: %32
double
'
': %32
to: %32
`
`
promote: %32
to: %32
the: %32
smallest: %32
capacious
-: %13
enough: %32
type
.
'
': %32
See: %32
Par
.
A
.
6
.
5
.: %13
The: %32
old: %32
assignment: %32
operators: %32
like: %32
=
+: %32
are: %32
truly: %32
gone
.: %32
Also
,: %32
assignment: %32
operators: %32
are: %32
now: %32
single: %13
tokens
;: %32
in: %32
the: %32
first: %32
edition
,: %32
they: %32
were: %32
pairs
,: %32
and: %32
could: %32
be: %32
separated: %32
by: %32
white: %32
space
.: %13
A: %32
compiler
'
s: %32
license: %32
to: %32
treat: %32
mathematically: %32
associative: %32
operators: %32
as: %32
computationally: %32
associative: %13
is: %32
revoked
.: %13
A: %32
unary: %32
+: %32
operator: %32
is: %32
introduced: %32
for: %32
symmetry: %32
with: %32
unary: %32
-
.: %13
A: %32
pointer: %32
to: %32
a: %32
function: %32
may: %32
be: %32
used: %32
as: %32
a: %32
function: %32
designator: %32
without: %32
an: %32
explicit: %32
*: %32
operator
.: %32
See: %13
Par
.
A
.
7
.
3
.
2
.: %13
Structures: %32
may: %32
be: %32
assigned
,: %32
passed: %32
to: %32
functions
,: %32
and: %32
returned: %32
by: %32
functions
.: %13
Applying: %32
the: %32
address
-
of: %32
operator: %32
to: %32
arrays: %32
is: %32
permitted
,: %32
and: %32
the: %32
result: %32
is: %32
a: %32
pointer: %32
to: %32
the: %32
array
.: %13
The: %32
sizeof: %32
operator
,: %32
in: %32
the: %32
first: %32
edition
,: %32
yielded: %32
type: %32
int
;: %32
subsequently
,: %32
many: %13
implementations: %32
made: %32
it: %32
unsigned
.: %32
The: %32
Standard: %32
makes: %32
its: %32
type: %32
explicitly: %32
implementation
-: %13
dependent
,: %32
but: %32
requires: %32
the: %32
type
,: %32
size
_
t
,: %32
to: %32
be: %32
defined: %32
in: %32
a: %32
standard: %32
header: %32
(
<
stddef
.
h
>
)
.: %32
A: %13
similar: %32
change: %32
occurs: %32
in: %32
the: %32
type: %32
(
ptrdiff
_
t
): %32
of: %32
the: %32
difference: %32
between: %32
pointers
.: %32
See: %13
Par
.
A
.
7
.
4
.
8: %32
and: %32
Par
.
A
.
7
.
7
.: %13
The: %32
address
-
of: %32
operator: %32
&: %32
may: %32
not: %32
be: %32
applied: %32
to: %32
an: %32
object: %32
declared: %32
register
,: %32
even: %32
if: %32
the: %13
implementation: %32
chooses: %32
not: %32
to: %32
keep: %32
the: %32
object: %32
in: %32
a: %32
register
.: %13
The: %32
type: %32
of: %32
a: %32
shift: %32
expression: %32
is: %32
that: %32
of: %32
the: %32
left: %32
operand
;: %32
the: %32
right: %32
operand: %32
can
'
t: %32
promote: %32
the: %32
result
.: %13
See: %32
Par
.
A
.
7
.
8
.: %13
The: %32
Standard: %32
legalizes: %32
the: %32
creation: %32
of: %32
a: %32
pointer: %32
just: %32
beyond: %32
the: %32
end: %32
of: %32
an: %32
array
,: %32
and: %32
allows: %13
arithmetic: %32
and: %32
relations: %32
on: %32
it
;: %32
see: %32
Par
.
A
.
7
.
7
.: %13
Appendix: %32
C: %32
-: %32
Summary: %32
of: %32
Changes: %13
q: %13
q: %13
q: %13
q: %13
q: %13
q: %13
q: %13
q: %13
q: %13
q: %13
The: %32
Standard: %32
introduces: %32
(
borrowing: %32
from: %32
C
+
+
): %32
the: %32
notion: %32
of: %32
a: %32
function: %32
prototype: %32
declaration: %32
that: %13
incorporates: %32
the: %32
types: %32
of: %32
the: %32
parameters
,: %32
and: %32
includes: %32
an: %32
explicit: %32
recognition: %32
of: %32
variadic: %32
functions: %13
together: %32
with: %32
an: %32
approved: %32
way: %32
of: %32
dealing: %32
with: %32
them
.: %32
See: %32
Pars
.: %32
A
.
7
.
3
.
2
,: %32
A
.
8
.
6
.
3
,: %32
B
.
7
.: %32
The: %32
older: %13
style: %32
is: %32
still: %32
accepted
,: %32
with: %32
restrictions
.: %13
Empty: %32
declarations
,: %32
which: %32
have: %32
no: %32
declarators: %32
and: %32
don
'
t: %32
declare: %32
at: %32
least: %32
a: %32
structure
,: %32
union
,: %32
or: %13
enumeration
,: %32
are: %32
forbidden: %32
by: %32
the: %32
Standard
.: %32
On: %32
the: %32
other: %32
hand
,: %32
a: %32
declaration: %32
with: %32
just: %32
a: %32
structure: %13
or: %32
union: %32
tag: %32
redeclares: %32
that: %32
tag: %32
even: %32
if: %32
it: %32
was: %32
declared: %32
in: %32
an: %32
outer: %32
scope
.: %13
External: %32
data: %32
declarations: %32
without: %32
any: %32
specifiers: %32
or: %32
qualifiers: %32
(
just: %32
a: %32
naked: %32
declarator
): %32
are: %13
forbidden
.: %13
Some: %32
implementations
,: %32
when: %32
presented: %32
with: %32
an: %32
extern: %32
declaration: %32
in: %32
an: %32
inner: %32
block
,: %32
would: %13
export: %32
the: %32
declaration: %32
to: %32
the: %32
rest: %32
of: %32
the: %32
file
.: %32
The: %32
Standard: %32
makes: %32
it: %32
clear: %32
that: %32
the: %32
scope: %32
of: %32
such: %32
a: %13
declaration: %32
is: %32
just: %32
the: %32
block
.: %13
The: %32
scope: %32
of: %32
parameters: %32
is: %32
injected: %32
into: %32
a: %32
function
'
s: %32
compound: %32
statement
,: %32
so: %32
that: %32
variable: %13
declarations: %32
at: %32
the: %32
top: %32
level: %32
of: %32
the: %32
function: %32
cannot: %32
hide: %32
the: %32
parameters
.: %13
The: %32
name: %32
spaces: %32
of: %32
identifiers: %32
are: %32
somewhat: %32
different
.: %32
The: %32
Standard: %32
puts: %32
all: %32
tags: %32
in: %32
a: %32
single: %32
name: %13
space
,: %32
and: %32
also: %32
introduces: %32
a: %32
separate: %32
name: %32
space: %32
for: %32
labels
;: %32
see: %32
Par
.
A
.
1
1
.
1
.: %32
Also
,: %32
member: %32
names: %13
are: %32
associated: %32
with: %32
the: %32
structure: %32
or: %32
union: %32
of: %32
which: %32
they: %32
are: %32
a: %32
part
.: %32
(
This: %32
has: %32
been: %32
common: %13
practice: %32
from: %32
some: %32
time
.
): %13
Unions: %32
may: %32
be: %32
initialized
;: %32
the: %32
initializer: %32
refers: %32
to: %32
the: %32
first: %32
member
.: %13
Automatic: %32
structures
,: %32
unions
,: %32
and: %32
arrays: %32
may: %32
be: %32
initialized
,: %32
albeit: %32
in: %32
a: %32
restricted: %32
way
.: %13
Character: %32
arrays: %32
with: %32
an: %32
explicit: %32
size: %32
may: %32
be: %32
initialized: %32
by: %32
a: %32
string: %32
literal: %32
with: %32
exactly: %32
that: %32
many: %13
characters: %32
(
the: %32
\
0: %32
is: %32
quietly: %32
squeezed: %32
out
)
.: %13
The: %32
controlling: %32
expression
,: %32
and: %32
the: %32
case: %32
labels
,: %32
of: %32
a: %32
switch: %32
may: %32
have: %32
any: %32
integral: %32
type
.: %13
Back: %32
to: %32
Appendix: %32
B: %32
-
-: %32
Index: %13
: %13
